"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalSigningManager = exports.KeyringSigner = void 0;
const tslib_1 = require("tslib");
const api_1 = require("@polkadot/api");
const types_1 = require("@polkadot/types");
const util_1 = require("@polkadot/util");
const util_crypto_1 = require("@polkadot/util-crypto");
const signing_manager_types_1 = require("@polymeshassociation/signing-manager-types");
/**
 * Manages signing payloads with a set of pre-loaded accounts in a Keyring
 */
class KeyringSigner {
    /**
     * @hidden
     */
    constructor(keyring, registry) {
        this.keyring = keyring;
        this.registry = registry;
        this.currentId = -1;
    }
    /**
     * Sign a payload
     */
    signPayload(payload) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const { registry } = this;
            const { address, version } = payload;
            const pair = this.getPair(address);
            const signablePayload = registry.createType('ExtrinsicPayload', payload, {
                version,
            });
            const { signature } = signablePayload.sign(pair);
            const id = (this.currentId += 1);
            return {
                signature,
                id,
            };
        });
    }
    /**
     * Sign raw data
     */
    signRaw(raw) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const { address, data } = raw;
            const pair = this.getPair(address);
            const signature = (0, util_1.u8aToHex)(pair.sign((0, util_1.hexToU8a)(data)));
            const id = (this.currentId += 1);
            return {
                id,
                signature,
            };
        });
    }
    /**
     * @hidden
     *
     * Get a pair from the keyring
     *
     * @throws if there is no pair with that address
     */
    getPair(address) {
        const { keyring } = this;
        try {
            return keyring.getPair(address);
        }
        catch (err) {
            if (err instanceof Error && err.message.includes('Unable to retrieve keypair')) {
                throw new Error('The signer cannot sign transactions on behalf of the calling Account');
            }
            else {
                throw err;
            }
        }
    }
}
exports.KeyringSigner = KeyringSigner;
/**
 * Signing manager that holds private keys in memory
 */
class LocalSigningManager {
    /**
     * @hidden
     */
    constructor(accounts, type) {
        this.keyring = new api_1.Keyring({
            type: type || 'sr25519',
        });
        const registry = new types_1.TypeRegistry();
        registry.setSignedExtensions(signing_manager_types_1.signedExtensions);
        this.externalSigner = new KeyringSigner(this.keyring, registry);
        accounts.forEach(account => {
            this._addAccount(account);
        });
    }
    /**
     * Create an instance of the Local Signing Manager and populates it with the passed Accounts
     *
     * @param args.accounts - array of private keys
     */
    static create(args) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            yield (0, util_crypto_1.cryptoWaitReady)();
            const { accounts, type } = args;
            return new LocalSigningManager(accounts, type);
        });
    }
    /**
     * Generate a new Polymesh account and return its mnemonic. This account can be used with the Local Signing Manager to sign transactions via the Polymesh SDK
     *
     * @note make sure to store the returned mnemonic somewhere safe since it will not be accessible by any means after being returned, and it gives full control over the account
     */
    static generateAccount() {
        return (0, util_crypto_1.mnemonicGenerate)();
    }
    /**
     * Set the SS58 format in which returned addresses will be encoded
     */
    setSs58Format(ss58Format) {
        this.hasFormat = true;
        this.keyring.setSS58Format(ss58Format);
    }
    /**
     * Return the addresses of all Accounts in the Signing Manager
     *
     * @throws if called before calling `setSs58Format`. Normally, `setSs58Format` will be called by the SDK when instantiated
     */
    getAccounts() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            this.assertFormatSet('getAccounts');
            return this.keyring.getPairs().map(({ address }) => address);
        });
    }
    /**
     * Return a signer object that uses the underlying keyring pairs to sign
     */
    getExternalSigner() {
        return this.externalSigner;
    }
    /**
     * Add a new Account to the Signing Manager via private key
     *
     * @returns the newly added Account's address, encoded with the Signing Manager's
     *   current SS58 format
     *
     * @throws if called before calling `setSs58Format`. Normally, `setSs58Format` will be called by the SDK when instantiated.
     *   If Accounts need to be pre-loaded, it should be done by passing them to the `create` method
     */
    addAccount(account) {
        this.assertFormatSet('addAccount');
        return this._addAccount(account);
    }
    /**
     * @hidden
     */
    _addAccount(account) {
        const { keyring } = this;
        let address;
        if ('uri' in account) {
            const accountUri = account.derivationPath
                ? `${account.uri}${account.derivationPath}`
                : account.uri;
            address = keyring.addFromUri(accountUri).address;
        }
        else if ('mnemonic' in account) {
            const accountMnemonic = account.derivationPath
                ? `${account.mnemonic}${account.derivationPath}`
                : account.mnemonic;
            address = keyring.addFromUri(accountMnemonic).address;
        }
        else {
            const seedInU8a = (0, util_1.hexToU8a)(account.seed);
            if (account.derivationPath) {
                address = keyring.addPair(new api_1.Keyring({ type: this.keyring.type })
                    .addFromSeed(seedInU8a)
                    .derive(account.derivationPath)).address;
            }
            else {
                address = keyring.addFromSeed(seedInU8a).address;
            }
        }
        return address;
    }
    /**
     * @hidden
     *
     * Throw an error if the SS58 format hasn't been set yet
     */
    assertFormatSet(methodName) {
        const { hasFormat } = this;
        if (!hasFormat) {
            throw new Error(`Cannot call '${methodName}' before calling 'setSs58Format'. Did you forget to use this Signing Manager to connect with the Polymesh SDK?`);
        }
    }
}
exports.LocalSigningManager = LocalSigningManager;
//# sourceMappingURL=local-signing-manager.js.map