"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountManagement = void 0;
const MultiSig_1 = require("../entities/Account/MultiSig");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * Handles functionality related to Account Management
 */
class AccountManagement {
    /**
     * @hidden
     */
    constructor(context) {
        this.context = context;
        this.leaveIdentity = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: () => [internal_1.leaveIdentity, undefined], voidArgs: true }, context);
        this.removeSecondaryAccounts = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [internal_1.removeSecondaryAccounts, Object.assign({}, args)],
        }, context);
        this.revokePermissions = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => {
                const { secondaryAccounts } = args;
                const accounts = secondaryAccounts.map(account => {
                    return {
                        account,
                        permissions: {
                            tokens: { type: types_1.PermissionType.Include, values: [] },
                            transactions: { type: types_1.PermissionType.Include, values: [] },
                            portfolios: { type: types_1.PermissionType.Include, values: [] },
                        },
                    };
                });
                return [internal_1.modifySignerPermissions, { secondaryAccounts: accounts }];
            },
        }, context);
        this.modifyPermissions = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.modifySignerPermissions, Object.assign({}, args)] }, context);
        this.inviteAccount = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.inviteAccount, Object.assign({}, args)] }, context);
        this.freezeSecondaryAccounts = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: () => [internal_1.toggleFreezeSecondaryAccounts, { freeze: true }],
            voidArgs: true,
        }, context);
        this.unfreezeSecondaryAccounts = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: () => [internal_1.toggleFreezeSecondaryAccounts, { freeze: false }],
            voidArgs: true,
        }, context);
        this.subsidizeAccount = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.subsidizeAccount, Object.assign({}, args)] }, context);
        this.createMultiSigAccount = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.createMultiSigAccount, args] }, context);
        this.acceptPrimaryKey = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.acceptPrimaryKeyRotation, args] }, context);
    }
    // eslint-disable-next-line require-jsdoc
    getAccountBalance(args, callback) {
        const { context } = this;
        let account;
        let cb = callback;
        switch (typeof args) {
            case 'undefined': {
                break;
            }
            case 'function': {
                cb = args;
                break;
            }
            default: {
                ({ account } = args);
                break;
            }
        }
        if (!account) {
            account = context.getSigningAccount();
        }
        else {
            account = (0, internal_2.asAccount)(account, context);
        }
        if (cb) {
            return account.getBalance(cb);
        }
        return account.getBalance();
    }
    /**
     * Return an Account instance from an address. If the Account has multiSig signers, the returned value will be a {@link api/entities/Account/MultiSig!MultiSig} instance
     */
    getAccount(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context, context: { polymeshApi: { query: { multiSig }, }, }, } = this;
            const { address } = args;
            const rawAddress = (0, conversion_1.stringToAccountId)(address, context);
            const rawSigners = yield multiSig.multiSigSigners.entries(rawAddress);
            if (rawSigners.length > 0) {
                return new MultiSig_1.MultiSig(args, context);
            }
            return new internal_1.Account(args, context);
        });
    }
    /**
     * Return the signing Account, or null if no signing Account has been set
     */
    getSigningAccount() {
        try {
            return this.context.getSigningAccount();
        }
        catch (err) {
            return null;
        }
    }
    /**
     * Return a list that contains all the signing Accounts associated to the SDK instance's Signing Manager
     *
     * @throws â€” if there is no Signing Manager attached to the SDK
     */
    getSigningAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.getSigningAccounts();
        });
    }
    /**
     * Return an Subsidy instance for a pair of beneficiary and subsidizer Account
     */
    getSubsidy(args) {
        const { context } = this;
        const { beneficiary, subsidizer } = args;
        const { address: beneficiaryAddress } = (0, internal_2.asAccount)(beneficiary, context);
        const { address: subsidizerAddress } = (0, internal_2.asAccount)(subsidizer, context);
        return new internal_1.Subsidy({ beneficiary: beneficiaryAddress, subsidizer: subsidizerAddress }, context);
    }
    /**
     * Returns `true` @param args.address is a valid ss58 address for the connected network
     */
    isValidAddress(args) {
        try {
            (0, internal_2.assertAddressValid)(args.address, this.context.ss58Format);
        }
        catch (error) {
            return false;
        }
        return true;
    }
}
exports.AccountManagement = AccountManagement;
//# sourceMappingURL=AccountManagement.js.map