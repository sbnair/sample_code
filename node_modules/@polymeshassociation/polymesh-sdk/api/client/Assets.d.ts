import { Context, FungibleAsset, Identity, NftCollection, TickerReservation } from "../../internal";
import { CreateAssetWithTickerParams, CreateNftCollectionParams, GlobalMetadataKey, PaginationOptions, ProcedureMethod, ReserveTickerParams, ResultSet, SubCallback, UnsubCallback } from "../../types";
/**
 * Handles all Asset related functionality
 */
export declare class Assets {
    private context;
    /**
     * @hidden
     */
    constructor(context: Context);
    /**
     * Reserve a ticker symbol under the ownership of the signing Identity to later use in the creation of an Asset.
     *   The ticker will expire after a set amount of time, after which other users can reserve it
     */
    reserveTicker: ProcedureMethod<ReserveTickerParams, TickerReservation>;
    /**
     * Create an Asset
     *
     * @note if ticker is already reserved, then required role:
     *   - Ticker Owner
     */
    createAsset: ProcedureMethod<CreateAssetWithTickerParams, FungibleAsset>;
    /**
     * Create an NftCollection
     *
     * @note if ticker is already reserved, then required role:
     *   - Ticker Owner
     */
    createNftCollection: ProcedureMethod<CreateNftCollectionParams, NftCollection>;
    /**
     * Check if a ticker hasn't been reserved
     *
     * @note can be subscribed to
     */
    isTickerAvailable(args: {
        ticker: string;
    }): Promise<boolean>;
    isTickerAvailable(args: {
        ticker: string;
    }, callback: SubCallback<boolean>): Promise<UnsubCallback>;
    /**
     * Retrieve all the ticker reservations currently owned by an Identity. This doesn't include Assets that
     *   have already been launched
     *
     * @param args.owner - defaults to the signing Identity
     *
     * @note reservations with unreadable characters in their tickers will be left out
     */
    getTickerReservations(args?: {
        owner: string | Identity;
    }): Promise<TickerReservation[]>;
    /**
     * Retrieve a Ticker Reservation
     *
     * @param args.ticker - Asset ticker
     */
    getTickerReservation(args: {
        ticker: string;
    }): TickerReservation;
    /**
     * Retrieve all of the Assets owned by an Identity
     *
     * @param args.owner - Identity representation or Identity ID as stored in the blockchain
     *
     * @note Assets with unreadable characters in their tickers will be left out
     */
    getAssets(args?: {
        owner: string | Identity;
    }): Promise<(FungibleAsset | NftCollection)[]>;
    /**
     * Retrieve a FungibleAsset
     *
     * @param args.ticker - Asset ticker
     */
    getFungibleAsset(args: {
        ticker: string;
    }): Promise<FungibleAsset>;
    /**
     * Retrieve an NftCollection
     *
     * @param args.ticker - NftCollection ticker
     */
    getNftCollection(args: {
        ticker: string;
    }): Promise<NftCollection>;
    /**
     * Retrieve all the Assets on chain
     *
     * @note supports pagination
     */
    get(paginationOpts?: PaginationOptions): Promise<ResultSet<FungibleAsset | NftCollection>>;
    /**
     * Retrieve all the Asset Global Metadata on chain. This includes metadata id, name and specs
     */
    getGlobalMetadataKeys(): Promise<GlobalMetadataKey[]>;
}
//# sourceMappingURL=Assets.d.ts.map