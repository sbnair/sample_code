"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Claims = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const lodash_1 = require("lodash");
const internal_1 = require("../../internal");
const enums_1 = require("../../middleware/enums");
const queries_1 = require("../../middleware/queries");
const types_1 = require("../../middleware/types");
const types_2 = require("../../types");
const constants_1 = require("../../utils/constants");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * Handles all Claims related functionality
 */
class Claims {
    /**
     * @hidden
     */
    constructor(context) {
        this.context = context;
        this.addClaims = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [
                internal_1.modifyClaims,
                Object.assign(Object.assign({}, args), { operation: types_2.ClaimOperation.Add }),
            ],
        }, context);
        this.editClaims = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [
                internal_1.modifyClaims,
                Object.assign(Object.assign({}, args), { operation: types_2.ClaimOperation.Edit }),
            ],
        }, context);
        this.revokeClaims = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [
                internal_1.modifyClaims,
                Object.assign(Object.assign({}, args), { operation: types_2.ClaimOperation.Revoke }),
            ],
        }, context);
        this.registerCustomClaimType = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.registerCustomClaimType, args] }, context);
    }
    /**
     * Retrieve all claims issued by an Identity
     *
     * @param opts.target - Identity (optional, defaults to the signing Identity)
     * @param opts.includeExpired - whether to include expired claims. Defaults to true
     *
     * @note supports pagination
     * @note uses the middlewareV2
     */
    getIssuedClaims(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const { target, includeExpired = true, size, start } = opts;
            const did = yield (0, internal_2.getDid)(target, context);
            return context.getIdentityClaimsFromMiddleware({
                trustedClaimIssuers: [did],
                includeExpired,
                size,
                start,
            });
        });
    }
    /**
     * Retrieve a list of Identities with claims associated to them. Can be filtered using parameters
     *
     * @param opts.targets - Identities (or Identity IDs) for which to fetch targeting claims. Defaults to all targets
     * @param opts.trustedClaimIssuers - Identity IDs of claim issuers. Defaults to all claim issuers
     * @param opts.scope - scope of the claims to fetch. Defaults to any scope
     * @param opts.claimTypes - types of the claims to fetch. Defaults to any type
     * @param opts.includeExpired - whether to include expired claims. Defaults to true
     * @param opts.size - page size
     * @param opts.start - page offset
     *
     * @note supports pagination
     * @note uses the middleware V2
     */
    getIdentitiesWithClaims(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const { targets, trustedClaimIssuers, scope, claimTypes, includeExpired = true, size = new bignumber_js_1.default(constants_1.DEFAULT_GQL_PAGE_SIZE), start = new bignumber_js_1.default(0), } = opts;
            let targetIssuers;
            const filters = {
                scope: scope ? (0, conversion_1.scopeToMiddlewareScope)(scope, false) : undefined,
                trustedClaimIssuers: trustedClaimIssuers === null || trustedClaimIssuers === void 0 ? void 0 : trustedClaimIssuers.map(trustedClaimIssuer => (0, conversion_1.signerToString)(trustedClaimIssuer)),
                claimTypes: claimTypes === null || claimTypes === void 0 ? void 0 : claimTypes.map(ct => enums_1.ClaimTypeEnum[ct]),
                includeExpired,
            };
            if (!targets) {
                const { data: { claims: { groupedAggregates: groupedTargets }, }, } = yield context.queryMiddleware((0, queries_1.claimsGroupingQuery)(Object.assign({}, filters)));
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                targetIssuers = (0, lodash_1.flatten)(groupedTargets.map(groupedTarget => groupedTarget.keys));
            }
            else {
                targetIssuers = targets.map(target => (0, conversion_1.signerToString)(target));
            }
            // note: pagination count is based on the target issuers and not the claims count
            const count = new bignumber_js_1.default(targetIssuers.length);
            // tooling-gql does pagination based on sorted target issuers, hence the explicit `sort()` function (as graphql doesn't sort the final data)
            targetIssuers.sort();
            targetIssuers = targetIssuers.slice(start.toNumber(), size.plus(start).toNumber());
            const { data: { claims: { nodes }, }, } = yield context.queryMiddleware((0, queries_1.claimsQuery)(Object.assign({ dids: targetIssuers }, filters)));
            const data = (0, conversion_1.toIdentityWithClaimsArray)(nodes, context, 'targetId');
            const next = (0, internal_2.calculateNextKey)(count, data.length, start);
            return {
                data,
                next,
                count,
            };
        });
    }
    /**
     * Retrieve all scopes in which claims have been made for the target Identity.
     *   If the scope is an asset DID, the corresponding ticker is returned as well
     *
     * @param opts.target - Identity for which to fetch claim scopes (optional, defaults to the signing Identity)
     */
    getClaimScopes(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const { target } = opts;
            const did = yield (0, internal_2.getDid)(target, context);
            const identityClaimsFromChain = yield context.getIdentityClaimsFromChain({
                targets: [did],
                claimTypes: [
                    types_2.ClaimType.Accredited,
                    types_2.ClaimType.Affiliate,
                    types_2.ClaimType.Blocked,
                    types_2.ClaimType.BuyLockup,
                    types_2.ClaimType.Exempted,
                    types_2.ClaimType.Jurisdiction,
                    types_2.ClaimType.KnowYourCustomer,
                    types_2.ClaimType.SellLockup,
                ],
                trustedClaimIssuers: undefined,
                includeExpired: true,
            });
            const claimScopeList = identityClaimsFromChain.map(({ claim }) => {
                // only Scoped Claims were fetched so this assertion is reasonable
                const { scope: { type, value }, } = claim;
                let ticker;
                if (type === types_2.ScopeType.Ticker) {
                    ticker = (0, internal_2.removePadding)(value);
                }
                return {
                    scope: { type, value: ticker !== null && ticker !== void 0 ? ticker : value },
                    ticker,
                };
            });
            return (0, lodash_1.uniqWith)(claimScopeList, lodash_1.isEqual);
        });
    }
    /**
     * Retrieve the list of CDD claims for a target Identity
     *
     * @param opts.target - Identity for which to fetch CDD claims (optional, defaults to the signing Identity)
     * @param opts.includeExpired - whether to include expired claims. Defaults to true
     */
    getCddClaims(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context, context: { polymeshApi: { rpc: { identity }, }, }, } = this;
            const { target, includeExpired = true } = opts;
            const did = yield (0, internal_2.getDid)(target, context);
            const rawDid = (0, conversion_1.stringToIdentityId)(did, context);
            const result = yield identity.validCDDClaims(rawDid);
            const data = [];
            result.forEach(optClaim => {
                const { claim_issuer: claimIssuer, issuance_date: issuanceDate, last_update_date: lastUpdateDate, expiry: rawExpiry, claim, } = optClaim;
                const expiry = !rawExpiry.isEmpty ? (0, conversion_1.momentToDate)(rawExpiry.unwrap()) : null;
                if ((!includeExpired && (expiry === null || expiry > new Date())) || includeExpired) {
                    data.push({
                        target: new internal_1.Identity({ did }, context),
                        issuer: new internal_1.Identity({ did: (0, conversion_1.identityIdToString)(claimIssuer) }, context),
                        issuedAt: (0, conversion_1.momentToDate)(issuanceDate),
                        lastUpdatedAt: (0, conversion_1.momentToDate)(lastUpdateDate),
                        expiry,
                        claim: (0, conversion_1.meshClaimToClaim)(claim),
                    });
                }
            });
            return data;
        });
    }
    /**
     * @hidden
     */
    getClaimsFromChain(context, did, trustedClaimIssuers, includeExpired) {
        return __awaiter(this, void 0, void 0, function* () {
            const identityClaimsFromChain = yield context.getIdentityClaimsFromChain({
                targets: [did],
                trustedClaimIssuers: trustedClaimIssuers === null || trustedClaimIssuers === void 0 ? void 0 : trustedClaimIssuers.map(conversion_1.signerToString),
                includeExpired,
            });
            const issuers = (0, lodash_1.uniqBy)(identityClaimsFromChain.map(i => i.issuer), identity => identity.did);
            const identitiesWithClaims = issuers.map(identity => ({
                identity,
                claims: (0, lodash_1.filter)(identityClaimsFromChain, ({ issuer }) => issuer.isEqual(identity)),
            }));
            return {
                data: identitiesWithClaims,
                next: null,
                count: new bignumber_js_1.default(identitiesWithClaims.length),
            };
        });
    }
    /**
     * Retrieve all claims issued about an Identity, grouped by claim issuer
     *
     * @param opts.target - Identity for which to fetch targeting claims (optional, defaults to the signing Identity)
     * @param opts.includeExpired - whether to include expired claims. Defaults to true
     *
     * @note supports pagination
     * @note uses the middlewareV2 (optional)
     */
    getTargetingClaims(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const { target, trustedClaimIssuers, scope, includeExpired = true, size = new bignumber_js_1.default(constants_1.DEFAULT_GQL_PAGE_SIZE), start = new bignumber_js_1.default(0), } = opts;
            const did = yield (0, internal_2.getDid)(target, context);
            const isMiddlewareAvailable = yield context.isMiddlewareAvailable();
            if (isMiddlewareAvailable) {
                const filters = {
                    dids: [did],
                    scope: scope ? (0, conversion_1.scopeToMiddlewareScope)(scope, false) : undefined,
                    includeExpired,
                };
                let claimIssuers;
                if (!trustedClaimIssuers) {
                    const { data: { claims: { groupedAggregates: groupedIssuers }, }, } = yield context.queryMiddleware((0, queries_1.claimsGroupingQuery)(filters, types_1.ClaimsOrderBy.IssuerIdAsc, types_1.ClaimsGroupBy.IssuerId));
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    claimIssuers = (0, lodash_1.flatten)(groupedIssuers.map(groupedAggregate => groupedAggregate.keys));
                }
                else {
                    claimIssuers = trustedClaimIssuers.map(conversion_1.signerToString);
                }
                // note: pagination count is based on the claim issuers and not the claims count
                const count = new bignumber_js_1.default(claimIssuers.length);
                claimIssuers.sort();
                claimIssuers = claimIssuers.slice(start.toNumber(), size.plus(start).toNumber());
                const { data: { claims: { nodes }, }, } = yield context.queryMiddleware((0, queries_1.claimsQuery)(Object.assign({ trustedClaimIssuers: claimIssuers }, filters)));
                const data = (0, conversion_1.toIdentityWithClaimsArray)(nodes, context, 'issuerId');
                const next = (0, internal_2.calculateNextKey)(count, data.length, start);
                return {
                    data,
                    next,
                    count,
                };
            }
            return this.getClaimsFromChain(context, did, trustedClaimIssuers, includeExpired);
        });
    }
}
exports.Claims = Claims;
//# sourceMappingURL=Claims.js.map