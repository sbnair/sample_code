import { AuthorizationRequest, ChildIdentity, Context, Identity, NumberedPortfolio } from "../../internal";
import { AttestPrimaryKeyRotationParams, CreateChildIdentityParams, ProcedureMethod, RegisterIdentityParams, RotatePrimaryKeyParams } from "../../types";
/**
 * Handles all Identity related functionality
 */
export declare class Identities {
    private context;
    /**
     * @hidden
     */
    constructor(context: Context);
    /**
     * Register an Identity, possibly with a CDD claim
     *
     * @note the transaction signer must be a CDD provider
     * @note this may create {@link api/entities/AuthorizationRequest!AuthorizationRequest | Authorization Requests} which have to be accepted by the `targetAccount`.
     *   An {@link api/entities/Account!Account} or {@link api/entities/Identity!Identity} can fetch its pending Authorization Requests by calling {@link api/entities/common/namespaces/Authorizations!Authorizations.getReceived | authorizations.getReceived}.
     *   Also, an Account or Identity can directly fetch the details of an Authorization Request by calling {@link api/entities/common/namespaces/Authorizations!Authorizations.getOne | authorizations.getOne}
     *
     * @note required role:
     *   - Customer Due Diligence Provider
     */
    registerIdentity: ProcedureMethod<RegisterIdentityParams, Identity>;
    /**
     * Get CDD Provider's attestation to change primary key
     *
     * @note the transaction signer must be a CDD provider
     * @note this creates an {@link api/entities/AuthorizationRequest!AuthorizationRequest | Authorization Requests} which have to be accepted by the `targetAccount` along with the authorization for `RotatingPrimaryKey`.
     *   An {@link api/entities/Account!Account} or {@link api/entities/Identity!Identity} can fetch its pending Authorization Requests by calling {@link api/entities/common/namespaces/Authorizations!Authorizations.getReceived | authorizations.getReceived}.
     *   Also, an Account or Identity can directly fetch the details of an Authorization Request by calling {@link api/entities/common/namespaces/Authorizations!Authorizations.getOne | authorizations.getOne}
     *
     * @note required role:
     *   - Customer Due Diligence Provider
     */
    attestPrimaryKeyRotation: ProcedureMethod<AttestPrimaryKeyRotationParams, AuthorizationRequest>;
    /**
     * Creates an Authorization to rotate primary key of the signing Identity by the `targetAccount`
     *
     * @note this creates an {@link api/entities/AuthorizationRequest!AuthorizationRequest | Authorization Requests} which have to be accepted by the `targetAccount` along with the optional CDD authorization generated by CDD provider attesting the rotation of primary key
     *   An {@link api/entities/Account!Account} or {@link api/entities/Identity!Identity} can fetch its pending Authorization Requests by calling {@link api/entities/common/namespaces/Authorizations!Authorizations.getReceived | authorizations.getReceived}.
     *   Also, an Account or Identity can directly fetch the details of an Authorization Request by calling {@link api/entities/common/namespaces/Authorizations!Authorizations.getOne | authorizations.getOne}
     */
    rotatePrimaryKey: ProcedureMethod<RotatePrimaryKeyParams, AuthorizationRequest>;
    /**
     * Create a new Portfolio under the ownership of the signing Identity
     */
    createPortfolio: ProcedureMethod<{
        name: string;
    }, NumberedPortfolio[], NumberedPortfolio>;
    /**
     * Creates a set of new Portfolios under the ownership of the signing Identity
     */
    createPortfolios: ProcedureMethod<{
        names: string[];
    }, NumberedPortfolio[]>;
    /**
     * Create an Identity instance from a DID
     *
     * @throws if there is no Identity with the passed DID
     */
    getIdentity(args: {
        did: string;
    }): Promise<Identity>;
    /**
     * Create a ChildIdentity instance from a DID
     *
     * @throws if there is no ChildIdentity with the passed DID
     */
    getChildIdentity(args: {
        did: string;
    }): Promise<ChildIdentity>;
    /**
     * Return whether the supplied Identity/DID exists
     */
    isIdentityValid(args: {
        identity: Identity | string;
    }): Promise<boolean>;
    /**
     * Creates a child identity and makes the `secondaryKey` as the primary key of the child identity
     *
     * @note the given `secondaryKey` is removed as secondary key from the signing Identity
     *
     * @throws if
     *  - the transaction signer is not the primary account of which the `secondaryKey` is a secondary key
     *  - the `secondaryKey` can't be unlinked (can happen when it's part of a multisig with some balance)
     *  - the signing account is not a primary key
     *  - the signing Identity is already a child of some other identity
     */
    createChild: ProcedureMethod<CreateChildIdentityParams, ChildIdentity>;
}
//# sourceMappingURL=Identities.d.ts.map