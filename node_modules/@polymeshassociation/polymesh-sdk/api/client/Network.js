"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Network = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const internal_1 = require("../../internal");
const queries_1 = require("../../middleware/queries");
const constants_1 = require("../../utils/constants");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * Handles all Network related functionality, including querying for historical events from middleware
 */
class Network {
    /**
     * @hidden
     */
    constructor(context) {
        this.context = context;
        this.transferPolyx = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.transferPolyx, args] }, context);
    }
    /**
     * Retrieve the number of the latest finalized block in the chain
     */
    getLatestBlock() {
        return this.context.getLatestBlock();
    }
    /**
     * Fetch the current network version (e.g. 3.1.0)
     */
    getVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.getNetworkVersion();
        });
    }
    /**
     * Retrieve the chain's SS58 format
     */
    getSs58Format() {
        return this.context.ss58Format;
    }
    /**
     * Retrieve information for the current network
     */
    getNetworkProperties() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { runtimeVersion: { specVersion }, rpc: { system: { chain }, }, }, }, } = this;
            const name = yield chain();
            return {
                name: (0, conversion_1.textToString)(name),
                version: (0, conversion_1.u32ToBigNumber)(specVersion),
            };
        });
    }
    /**
     * Retrieve the protocol fees associated with running specific transactions
     *
     * @param args.tags - list of transaction tags (e.g. [TxTags.asset.CreateAsset, TxTags.asset.RegisterTicker] or ["asset.createAsset", "asset.registerTicker"])
     */
    getProtocolFees(args) {
        return this.context.getProtocolFees(args);
    }
    /**
     * Get the treasury wallet address
     */
    getTreasuryAccount() {
        const { context } = this;
        return new internal_1.Account({ address: (0, conversion_1.moduleAddressToString)(constants_1.TREASURY_MODULE_ADDRESS, context) }, context);
    }
    // eslint-disable-next-line require-jsdoc
    getTreasuryBalance(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = this.getTreasuryAccount();
            if (callback) {
                return account.getBalance(({ free: freeBalance }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises -- callback errors should be handled by the caller
                    callback(freeBalance);
                });
            }
            const { free } = yield account.getBalance();
            return free;
        });
    }
    /**
     * Retrieve a single event by any of its indexed arguments. Can be filtered using parameters
     *
     * @param opts.moduleId - type of the module to fetch
     * @param opts.eventId - type of the event to fetch
     * @param opts.eventArg0 - event parameter value to filter by in position 0
     * @param opts.eventArg1 - event parameter value to filter by in position 1
     * @param opts.eventArg2 - event parameter value to filter by in position 2
     *
     * @note uses the middlewareV2
     */
    getEventByIndexedArgs(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const { moduleId, eventId, eventArg0, eventArg1, eventArg2 } = opts;
            const { data: { events: { nodes: [event], }, }, } = yield context.queryMiddleware((0, queries_1.eventsByArgs)({
                moduleId,
                eventId,
                eventArg0,
                eventArg1,
                eventArg2,
            }, new bignumber_js_1.default(1)));
            return (0, internal_2.optionize)(conversion_1.middlewareEventDetailsToEventIdentifier)(event === null || event === void 0 ? void 0 : event.block, event === null || event === void 0 ? void 0 : event.eventIdx);
        });
    }
    /**
     * Retrieve a list of events. Can be filtered using parameters
     *
     * @param opts.moduleId - type of the module to fetch
     * @param opts.eventId - type of the event to fetch
     * @param opts.eventArg0 - event parameter value to filter by in position 0
     * @param opts.eventArg1 - event parameter value to filter by in position 1
     * @param opts.eventArg2 - event parameter value to filter by in position 2
     * @param opts.size - page size
     * @param opts.start - page offset
     *
     * @note uses the middlewareV2
     */
    getEventsByIndexedArgs(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const { moduleId, eventId, eventArg0, eventArg1, eventArg2, size, start } = opts;
            const { data: { events: { nodes: events }, }, } = yield context.queryMiddleware((0, queries_1.eventsByArgs)({
                moduleId,
                eventId,
                eventArg0,
                eventArg1,
                eventArg2,
            }, size, start));
            if (events.length) {
                return events.map(({ block, eventIdx }) => 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                (0, conversion_1.middlewareEventDetailsToEventIdentifier)(block, eventIdx));
            }
            return null;
        });
    }
    /**
     * Retrieve a transaction by hash
     *
     * @param opts.txHash - hash of the transaction
     *
     * @note uses the middlewareV2
     */
    getTransactionByHash(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { rpc: { chain: { getBlock }, payment: { queryInfo }, }, }, }, context, } = this;
            const { data: { extrinsics: { nodes: [transaction], }, }, } = yield context.queryMiddleware((0, queries_1.extrinsicByHash)({
                extrinsicHash: opts.txHash,
            }));
            if (transaction) {
                const { extrinsicIdx, address: rawAddress, nonce, moduleId, callId, paramsTxt, success: txSuccess, specVersionId, extrinsicHash, block, } = transaction;
                const txTag = (0, conversion_1.extrinsicIdentifierToTxTag)({
                    moduleId,
                    callId,
                });
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const { hash: blockHash, blockId: blockNumber, datetime } = block;
                const rawBlockHash = (0, conversion_1.stringToBlockHash)(blockHash, context);
                const { block: { extrinsics: blockExtrinsics }, } = yield getBlock(rawBlockHash);
                const [{ partialFee }, [{ fees: protocol }]] = yield Promise.all([
                    queryInfo(blockExtrinsics[extrinsicIdx].toHex(), rawBlockHash),
                    context.getProtocolFees({ tags: [txTag], blockHash }),
                ]);
                const gas = (0, conversion_1.balanceToBigNumber)(partialFee);
                return {
                    blockNumber: new bignumber_js_1.default(blockNumber),
                    blockHash,
                    blockDate: new Date(`${datetime}Z`),
                    extrinsicIdx: new bignumber_js_1.default(extrinsicIdx),
                    address: rawAddress !== null && rawAddress !== void 0 ? rawAddress : null,
                    nonce: nonce ? new bignumber_js_1.default(nonce) : null,
                    txTag,
                    params: JSON.parse(paramsTxt),
                    success: !!txSuccess,
                    specVersionId: new bignumber_js_1.default(specVersionId),
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    extrinsicHash: extrinsicHash,
                    fee: {
                        gas,
                        protocol,
                        total: gas.plus(protocol),
                    },
                };
            }
            return null;
        });
    }
    /**
     * Retrieve middleware metadata.
     * Returns null if middleware is disabled
     *
     * @note uses the middleware V2
     */
    getMiddlewareMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.getMiddlewareMetadata();
        });
    }
    /**
     * Get the number of blocks the middleware needs to process to be synced with chain.
     * The lag can be around somewhere upto 15 blocks, but this can increase if the block size being processed by the Middleware is too large.
     * If the lag is too large, its recommended to check the indexer health to make sure the Middleware is processing the blocks.
     *
     * @note uses the middleware V2
     */
    getMiddlewareLag() {
        return __awaiter(this, void 0, void 0, function* () {
            let lastProcessedBlockFromMiddleware = new bignumber_js_1.default(0);
            const [latestBlockFromChain, middlewareMetadata] = yield Promise.all([
                this.context.getLatestBlock(),
                this.context.getMiddlewareMetadata(),
            ]);
            if (middlewareMetadata) {
                lastProcessedBlockFromMiddleware = middlewareMetadata.lastProcessedHeight;
            }
            return latestBlockFromChain.minus(lastProcessedBlockFromMiddleware);
        });
    }
}
exports.Network = Network;
//# sourceMappingURL=Network.js.map