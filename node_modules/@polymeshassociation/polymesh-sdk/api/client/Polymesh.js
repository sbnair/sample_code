"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Polymesh = void 0;
const core_1 = require("@apollo/client/core");
const api_1 = require("@polkadot/api");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const schema_1 = __importDefault(require("../../polkadot/schema"));
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
const AccountManagement_1 = require("./AccountManagement");
const Assets_1 = require("./Assets");
const Claims_1 = require("./Claims");
const Identities_1 = require("./Identities");
const Network_1 = require("./Network");
const Settlements_1 = require("./Settlements");
/**
 * @hidden
 */
function createMiddlewareApi(middleware) {
    return middleware
        ? new core_1.ApolloClient({
            link: (0, core_1.createHttpLink)({
                uri: middleware.link,
                fetch: cross_fetch_1.default,
                // eslint-disable-next-line @typescript-eslint/naming-convention
                headers: { 'x-api-key': middleware.key },
            }),
            cache: new core_1.InMemoryCache(),
            defaultOptions: {
                watchQuery: {
                    fetchPolicy: 'no-cache',
                },
                query: {
                    fetchPolicy: 'no-cache',
                },
            },
        })
        : null;
}
/**
 * Main entry point of the Polymesh SDK
 */
class Polymesh {
    /**
     * @hidden
     */
    constructor(context) {
        this.context = {};
        this.context = context;
        this.claims = new Claims_1.Claims(context);
        this.network = new Network_1.Network(context);
        this.settlements = new Settlements_1.Settlements(context);
        this.accountManagement = new AccountManagement_1.AccountManagement(context);
        this.identities = new Identities_1.Identities(context);
        this.assets = new Assets_1.Assets(context);
        this.createTransactionBatch = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [internal_1.createTransactionBatch, Object.assign({}, args)],
        }, context);
    }
    /**
     * Create an SDK instance and connect to a Polymesh node
     *
     * @param params.nodeUrl - URL of the Polymesh node this instance will be connecting to
     * @param params.signingManager - object in charge of managing keys and signing transactions
     *   (optional, if not passed the SDK will not be able to submit transactions). Can be set later with
     *   `setSigningManager`
     * @param params.middlewareV2 - middleware V2 API URL (optional, used for historic queries)
     * @param params.polkadot - optional config for polkadot `ApiPromise`
     */
    static connect(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { nodeUrl, signingManager, middlewareV2, polkadot } = params;
            let context;
            let polymeshApi;
            const { metadata, noInitWarn, typesBundle } = polkadot !== null && polkadot !== void 0 ? polkadot : {};
            // Defer `await` on any checks to minimize total startup time
            const requiredChecks = [(0, internal_2.assertExpectedChainVersion)(nodeUrl)];
            try {
                const { types, rpc, signedExtensions } = schema_1.default;
                polymeshApi = yield api_1.ApiPromise.create({
                    provider: new api_1.WsProvider(nodeUrl),
                    types,
                    rpc,
                    signedExtensions,
                    metadata,
                    noInitWarn,
                    typesBundle,
                });
                context = yield internal_1.Context.create({
                    polymeshApi,
                    middlewareApiV2: createMiddlewareApi(middlewareV2),
                    signingManager,
                });
            }
            catch (err) {
                const { message, code } = err;
                throw new internal_1.PolymeshError({
                    code,
                    message: `Error while connecting to "${nodeUrl}": "${message || 'The node couldnâ€™t be reached'}"`,
                });
            }
            if (middlewareV2) {
                let middlewareMetadata = null;
                const checkMiddleware = () => __awaiter(this, void 0, void 0, function* () {
                    try {
                        middlewareMetadata = yield context.getMiddlewareMetadata();
                    }
                    catch (err) {
                        throw new internal_1.PolymeshError({
                            code: types_1.ErrorCode.FatalError,
                            message: 'Could not query for middleware V2 metadata',
                        });
                    }
                    if (!middlewareMetadata ||
                        middlewareMetadata.genesisHash !== polymeshApi.genesisHash.toString()) {
                        throw new internal_1.PolymeshError({
                            code: types_1.ErrorCode.FatalError,
                            message: 'Middleware V2 URL is for a different chain than the given node URL',
                        });
                    }
                });
                requiredChecks.push(checkMiddleware(), (0, internal_2.assertExpectedSqVersion)(context));
            }
            yield Promise.all(requiredChecks);
            return new Polymesh(context);
        });
    }
    /**
     * Retrieve the Identity associated to the signing Account (null if there is none)
     *
     * @throws if there is no signing Account associated to the SDK
     */
    getSigningIdentity() {
        return this.context.getSigningAccount().getIdentity();
    }
    /**
     * Handle connection errors
     *
     * @returns an unsubscribe callback
     */
    onConnectionError(callback) {
        const { context: { polymeshApi }, } = this;
        polymeshApi.on('error', callback);
        return () => {
            polymeshApi.off('error', callback);
        };
    }
    /**
     * Handle disconnection
     *
     * @returns an unsubscribe callback
     */
    onDisconnect(callback) {
        const { context: { polymeshApi }, } = this;
        polymeshApi.on('disconnected', callback);
        return () => {
            polymeshApi.off('disconnected', callback);
        };
    }
    /**
     * Disconnect the client and close all open connections and subscriptions
     *
     * @note the SDK will become unusable after this operation. It will throw an error when attempting to
     *   access any chain or middleware data. If you wish to continue using the SDK, you must
     *   create a new instance by calling {@link connect}
     */
    disconnect() {
        return this.context.disconnect();
    }
    /**
     * Set the SDK's signing Account to the provided one
     *
     * @throws if the passed Account is not present in the Signing Manager (or there is no Signing Manager)
     */
    setSigningAccount(signer) {
        return this.context.setSigningAddress((0, conversion_1.signerToString)(signer));
    }
    /**
     * Set the SDK's Signing Manager to the provided one.
     *
     * @note Pass `null` to unset the current signing manager
     */
    setSigningManager(signingManager) {
        return this.context.setSigningManager(signingManager);
    }
    /* eslint-disable @typescript-eslint/naming-convention */
    /* istanbul ignore next: not part of the official public API */
    /**
     * Polkadot client
     */
    get _polkadotApi() {
        return this.context.getPolymeshApi();
    }
    /* istanbul ignore next: not part of the official public API */
    /**
     * signing address (to manually submit transactions with the polkadot API)
     */
    get _signingAddress() {
        return this.context.getSigningAddress();
    }
    /* istanbul ignore next: not part of the official public API */
    /**
     * MiddlewareV2 client
     */
    get _middlewareApiV2() {
        return this.context.middlewareApi;
    }
}
exports.Polymesh = Polymesh;
//# sourceMappingURL=Polymesh.js.map