"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Settlements = void 0;
const addInstruction_1 = require("../procedures/addInstruction");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const internal_2 = require("../../utils/internal");
/**
 * Handles all Settlement related functionality
 */
class Settlements {
    /**
     * @hidden
     */
    constructor(context) {
        this.context = context;
        this.createVenue = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.createVenue, args] }, context);
        this.addInstruction = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => {
                const { venueId } = args, instruction = __rest(args, ["venueId"]);
                return [addInstruction_1.addInstruction, { instructions: [instruction], venueId }];
            },
            transformer: internal_1.addInstructionTransformer,
        }, context);
        this.affirmInstruction = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [
                internal_1.modifyInstructionAffirmation,
                { id: args.id, operation: types_1.InstructionAffirmationOperation.Affirm },
            ],
        }, context);
    }
    /**
     * Retrieve a Venue by its ID
     *
     * @param args.id - identifier number of the Venue
     */
    getVenue(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const venue = new internal_1.Venue(args, context);
            const venueExists = yield venue.exists();
            if (!venueExists) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: "The Venue doesn't exist",
                });
            }
            return venue;
        });
    }
    /**
     * Retrieve an Instruction by its ID
     *
     * @param args.id - identifier number of the Instruction
     */
    getInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const instruction = new internal_1.Instruction(args, context);
            const instructionExists = yield instruction.exists();
            if (!instructionExists) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: "The Instruction doesn't exist",
                });
            }
            return instruction;
        });
    }
}
exports.Settlements = Settlements;
//# sourceMappingURL=Settlements.js.map