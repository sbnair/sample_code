import BigNumber from 'bignumber.js';
import { AccountTypeInfo, HistoricPolyxTransaction } from "./types";
import { Subsidies } from "../Subsidies";
import { Authorizations, Context, Entity, Identity, MultiSig } from "../../../internal";
import { ExtrinsicsOrderBy } from "../../../middleware/types";
import { AccountBalance, CheckPermissionsResult, ExtrinsicData, Permissions, ResultSet, SignerType, SimplePermissions, SubCallback, SubsidyWithAllowance, TxTag, UnsubCallback } from "../../../types";
/**
 * @hidden
 */
export interface UniqueIdentifiers {
    address: string;
}
/**
 * Represents an Account in the Polymesh blockchain. Accounts can hold POLYX, control Identities and vote on proposals (among other things)
 */
export declare class Account extends Entity<UniqueIdentifiers, string> {
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier: unknown): identifier is UniqueIdentifiers;
    /**
     * Polymesh-specific address of the Account. Serves as an identifier
     */
    address: string;
    /**
     * A hex representation of the cryptographic public key of the Account. This is consistent across
     * Substrate chains, while the address depends on the chain as well.
     */
    key: string;
    authorizations: Authorizations<Account>;
    subsidies: Subsidies;
    /**
     * @hidden
     */
    constructor(identifiers: UniqueIdentifiers, context: Context);
    /**
     * Get the free/locked POLYX balance of the Account
     *
     * @note can be subscribed to
     */
    getBalance(): Promise<AccountBalance>;
    getBalance(callback: SubCallback<AccountBalance>): Promise<UnsubCallback>;
    /**
     * Get the subsidized balance of this Account and the subsidizer Account. If
     *   this Account isn't being subsidized, return null
     *
     * @note can be subscribed to
     *
     * @deprecated in favour of {@link api/entities/Subsidies!Subsidies.getSubsidizer | subsidies.getSubsidizer}
     */
    getSubsidy(): Promise<SubsidyWithAllowance | null>;
    getSubsidy(callback: SubCallback<SubsidyWithAllowance | null>): Promise<UnsubCallback>;
    /**
     * Retrieve the Identity associated to this Account (null if there is none)
     */
    getIdentity(): Promise<Identity | null>;
    /**
     * Retrieve a list of transactions signed by this Account. Can be filtered using parameters
     *
     * @note if both `blockNumber` and `blockHash` are passed, only `blockNumber` is taken into account.
     * Also, for ordering by block_id, one should pass `ExtrinsicsOrderBy.CreatedAtAsc` or `ExtrinsicsOrderBy.CreatedAtDesc`
     * in order of their choice (since block ID is a string field in middleware v2)
     *
     * @param filters.tag - tag associated with the transaction
     * @param filters.success - whether the transaction was successful or not
     * @param filters.size - page size
     * @param filters.start - page offset
     *
     * @note uses the middleware v2
     */
    getTransactionHistory(filters?: {
        blockNumber?: BigNumber;
        blockHash?: string;
        tag?: TxTag;
        success?: boolean;
        size?: BigNumber;
        start?: BigNumber;
        orderBy?: ExtrinsicsOrderBy;
    }): Promise<ResultSet<ExtrinsicData>>;
    /**
     * Check whether this Account is frozen. If frozen, it cannot perform any Identity related action until the primary Account of the Identity unfreezes all secondary Accounts
     *
     * @note returns false if the Account isn't associated to any Identity
     */
    isFrozen(): Promise<boolean>;
    /**
     * Retrieve the Permissions this Account has as a Permissioned Account for its corresponding Identity
     *
     * @throws if there is no Identity associated with the Account
     */
    getPermissions(): Promise<Permissions>;
    /**
     * Check if this Account possesses certain Permissions to act on behalf of its corresponding Identity
     *
     * @return which permissions the Account is missing (if any) and the final result
     */
    checkPermissions(permissions: SimplePermissions): Promise<CheckPermissionsResult<SignerType.Account>>;
    /**
     * Fetch the MultiSig this Account is part of. If this Account is not a signer on any MultiSig, return null
     */
    getMultiSig(): Promise<MultiSig | null>;
    /**
     * Determine whether this Account exists on chain
     */
    exists(): Promise<boolean>;
    /**
     * Return the Account's address
     */
    toHuman(): string;
    /**
     * Retrieve the current nonce for this Account
     */
    getCurrentNonce(): Promise<BigNumber>;
    /**
     * Retrieve the type of Account, and its relation to an Identity, if applicable
     */
    getTypeInfo(): Promise<AccountTypeInfo>;
    /**
     * Returns POLYX transactions associated with this account
     *
     * @param filters.size - page size
     * @param filters.start - page offset
     *
     * @note uses the middleware
     */
    getPolyxTransactions(filters: {
        size?: BigNumber;
        start?: BigNumber;
    }): Promise<ResultSet<HistoricPolyxTransaction>>;
}
//# sourceMappingURL=index.d.ts.map