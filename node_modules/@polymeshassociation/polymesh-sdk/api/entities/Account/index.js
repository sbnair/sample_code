"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = void 0;
const util_1 = require("@polkadot/util");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const helpers_1 = require("./helpers");
const types_1 = require("./types");
const Subsidies_1 = require("../Subsidies");
const internal_1 = require("../../../internal");
const queries_1 = require("../../../middleware/queries");
const types_2 = require("../../../middleware/types");
const types_3 = require("../../../types");
const conversion_1 = require("../../../utils/conversion");
const internal_2 = require("../../../utils/internal");
/**
 * Represents an Account in the Polymesh blockchain. Accounts can hold POLYX, control Identities and vote on proposals (among other things)
 */
class Account extends internal_1.Entity {
    /**
     * @hidden
     */
    constructor(identifiers, context) {
        super(identifiers, context);
        const { address } = identifiers;
        (0, internal_2.assertAddressValid)(address, context.ss58Format);
        this.address = address;
        this.key = (0, conversion_1.addressToKey)(address, context);
        this.authorizations = new internal_1.Authorizations(this, context);
        this.subsidies = new Subsidies_1.Subsidies(this, context);
    }
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier) {
        const { address } = identifier;
        return typeof address === 'string';
    }
    // eslint-disable-next-line require-jsdoc
    getBalance(callback) {
        const { context, address } = this;
        if (callback) {
            return context.accountBalance(address, callback);
        }
        return context.accountBalance(address);
    }
    // eslint-disable-next-line require-jsdoc
    getSubsidy(callback) {
        const { context, address } = this;
        if (callback) {
            return context.accountSubsidy(address, callback);
        }
        return context.accountSubsidy(address);
    }
    /**
     * Retrieve the Identity associated to this Account (null if there is none)
     */
    getIdentity() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { identity }, }, }, context, address, } = this;
            const optKeyRecord = yield identity.keyRecords((0, conversion_1.stringToAccountId)(address, context));
            if (optKeyRecord.isNone) {
                return null;
            }
            const keyRecord = optKeyRecord.unwrap();
            return (0, internal_2.getIdentityFromKeyRecord)(keyRecord, context);
        });
    }
    /**
     * Retrieve a list of transactions signed by this Account. Can be filtered using parameters
     *
     * @note if both `blockNumber` and `blockHash` are passed, only `blockNumber` is taken into account.
     * Also, for ordering by block_id, one should pass `ExtrinsicsOrderBy.CreatedAtAsc` or `ExtrinsicsOrderBy.CreatedAtDesc`
     * in order of their choice (since block ID is a string field in middleware v2)
     *
     * @param filters.tag - tag associated with the transaction
     * @param filters.success - whether the transaction was successful or not
     * @param filters.size - page size
     * @param filters.start - page offset
     *
     * @note uses the middleware v2
     */
    getTransactionHistory(filters = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { tag, success, size, start, orderBy = types_2.ExtrinsicsOrderBy.CreatedAtAsc, blockHash, } = filters;
            const { context, address } = this;
            let moduleId;
            let callId;
            if (tag) {
                ({ moduleId, callId } = (0, conversion_1.txTagToExtrinsicIdentifier)(tag));
            }
            let successFilter;
            if (success !== undefined) {
                successFilter = success ? 1 : 0;
            }
            let { blockNumber } = filters;
            if (!blockNumber && blockHash) {
                const { block: { header: { number }, }, } = yield context.polymeshApi.rpc.chain.getBlock((0, conversion_1.stringToHash)(blockHash, context));
                blockNumber = (0, conversion_1.u32ToBigNumber)(number.unwrap());
            }
            const { data: { extrinsics: { nodes: transactionList, totalCount }, }, } = yield context.queryMiddleware((0, queries_1.extrinsicsByArgs)({
                blockId: blockNumber ? blockNumber.toString() : undefined,
                address: (0, util_1.hexStripPrefix)((0, conversion_1.addressToKey)(address, context)),
                moduleId,
                callId,
                success: successFilter,
            }, size, start, orderBy));
            const count = new bignumber_js_1.default(totalCount);
            /* eslint-disable @typescript-eslint/no-non-null-assertion */
            const data = transactionList.map(({ blockId, extrinsicIdx, address: rawAddress, nonce, moduleId: extrinsicModuleId, callId: extrinsicCallId, paramsTxt, success: txSuccess, specVersionId, extrinsicHash, block, }) => {
                const { hash, datetime } = block;
                return {
                    blockNumber: new bignumber_js_1.default(blockId),
                    blockHash: hash,
                    blockDate: new Date(`${datetime}Z`),
                    extrinsicIdx: new bignumber_js_1.default(extrinsicIdx),
                    address: rawAddress ? (0, conversion_1.keyToAddress)(rawAddress, context) : null,
                    nonce: nonce ? new bignumber_js_1.default(nonce) : null,
                    txTag: (0, conversion_1.extrinsicIdentifierToTxTag)({
                        moduleId: extrinsicModuleId,
                        callId: extrinsicCallId,
                    }),
                    params: JSON.parse(paramsTxt),
                    success: !!txSuccess,
                    specVersionId: new bignumber_js_1.default(specVersionId),
                    extrinsicHash: extrinsicHash,
                };
            });
            /* eslint-enable @typescript-eslint/no-non-null-assertion */
            const next = (0, internal_2.calculateNextKey)(count, data.length, start);
            return {
                data,
                next,
                count,
            };
        });
    }
    /**
     * Check whether this Account is frozen. If frozen, it cannot perform any Identity related action until the primary Account of the Identity unfreezes all secondary Accounts
     *
     * @note returns false if the Account isn't associated to any Identity
     */
    isFrozen() {
        return __awaiter(this, void 0, void 0, function* () {
            const identity = yield this.getIdentity();
            if (identity === null) {
                return false;
            }
            const { account } = yield identity.getPrimaryAccount();
            if (account.isEqual(this)) {
                return false;
            }
            return identity.areSecondaryAccountsFrozen();
        });
    }
    /**
     * Retrieve the Permissions this Account has as a Permissioned Account for its corresponding Identity
     *
     * @throws if there is no Identity associated with the Account
     */
    getPermissions() {
        return __awaiter(this, void 0, void 0, function* () {
            const { address, context } = this;
            const identity = yield this.getIdentity();
            if (identity === null) {
                throw new internal_1.PolymeshError({
                    code: types_3.ErrorCode.DataUnavailable,
                    message: 'There is no Identity associated with this Account',
                });
            }
            const [{ account: { address: primaryAccountAddress }, }, [permissionedAccount],] = yield Promise.all([
                identity.getPrimaryAccount(),
                (0, internal_2.getSecondaryAccountPermissions)({ accounts: [this], identity }, context),
            ]);
            if (address === primaryAccountAddress) {
                return {
                    assets: null,
                    transactions: null,
                    transactionGroups: [],
                    portfolios: null,
                };
            }
            return permissionedAccount.permissions;
        });
    }
    /**
     * Check if this Account possesses certain Permissions to act on behalf of its corresponding Identity
     *
     * @return which permissions the Account is missing (if any) and the final result
     */
    checkPermissions(permissions) {
        return __awaiter(this, void 0, void 0, function* () {
            const { assets, transactions, portfolios } = permissions;
            const { assets: currentAssets, transactions: currentTransactions, portfolios: currentPortfolios, } = yield this.getPermissions();
            const missingPermissions = {};
            const missingAssetPermissions = (0, helpers_1.getMissingAssetPermissions)(assets, currentAssets);
            const hasAssets = missingAssetPermissions === undefined;
            if (!hasAssets) {
                missingPermissions.assets = missingAssetPermissions;
            }
            const missingTransactionPermissions = (0, helpers_1.getMissingTransactionPermissions)(transactions, currentTransactions);
            const hasTransactions = missingTransactionPermissions === undefined;
            if (!hasTransactions) {
                missingPermissions.transactions = missingTransactionPermissions;
            }
            const missingPortfolioPermissions = (0, helpers_1.getMissingPortfolioPermissions)(portfolios, currentPortfolios);
            const hasPortfolios = missingPortfolioPermissions === undefined;
            if (!hasPortfolios) {
                missingPermissions.portfolios = missingPortfolioPermissions;
            }
            const result = hasAssets && hasTransactions && hasPortfolios;
            if (result) {
                return { result };
            }
            return {
                result,
                missingPermissions,
            };
        });
    }
    /**
     * Fetch the MultiSig this Account is part of. If this Account is not a signer on any MultiSig, return null
     */
    getMultiSig() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { identity }, }, }, context, address, } = this;
            const rawAddress = (0, conversion_1.stringToAccountId)(address, context);
            const rawOptKeyRecord = yield identity.keyRecords(rawAddress);
            if (rawOptKeyRecord.isNone) {
                return null;
            }
            const rawKeyRecord = rawOptKeyRecord.unwrap();
            if (!rawKeyRecord.isMultiSigSignerKey) {
                return null;
            }
            return new internal_1.MultiSig({ address }, context);
        });
    }
    /**
     * Determine whether this Account exists on chain
     */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    /**
     * Return the Account's address
     */
    toHuman() {
        return this.address;
    }
    /**
     * Retrieve the current nonce for this Account
     */
    getCurrentNonce() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { rpc: { system: { accountNextIndex }, }, }, }, address, context, } = this;
            const index = yield accountNextIndex((0, conversion_1.stringToAccountId)(address, context));
            return (0, conversion_1.u32ToBigNumber)(index);
        });
    }
    /**
     * Retrieve the type of Account, and its relation to an Identity, if applicable
     */
    getTypeInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { identity, multiSig, contracts }, }, }, context, address, } = this;
            const accountId = (0, conversion_1.stringToAccountId)(address, context);
            const [optKeyRecord, multiSignsRequired, smartContract] = yield (0, internal_2.requestMulti)(context, [
                [identity.keyRecords, accountId],
                [multiSig.multiSigSignsRequired, accountId],
                [contracts.contractInfoOf, accountId],
            ]);
            let keyType = types_1.AccountKeyType.Normal;
            if (!multiSignsRequired.isZero()) {
                keyType = types_1.AccountKeyType.MultiSig;
            }
            else if (smartContract.isSome) {
                keyType = types_1.AccountKeyType.SmartContract;
            }
            if (optKeyRecord.isNone) {
                return {
                    keyType,
                    relation: types_1.AccountIdentityRelation.Unassigned,
                };
            }
            const keyRecord = optKeyRecord.unwrap();
            let relation;
            if (keyRecord.isPrimaryKey) {
                relation = types_1.AccountIdentityRelation.Primary;
            }
            else if (keyRecord.isSecondaryKey) {
                relation = types_1.AccountIdentityRelation.Secondary;
            }
            else {
                relation = types_1.AccountIdentityRelation.MultiSigSigner;
            }
            return {
                keyType,
                relation,
            };
        });
    }
    /**
     * Returns POLYX transactions associated with this account
     *
     * @param filters.size - page size
     * @param filters.start - page offset
     *
     * @note uses the middleware
     */
    getPolyxTransactions(filters) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            return context.getPolyxTransactions(Object.assign({ accounts: [this] }, filters));
        });
    }
}
exports.Account = Account;
//# sourceMappingURL=index.js.map