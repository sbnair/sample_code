import { Compliance } from "./Compliance";
import { Documents } from "./Documents";
import { Metadata } from "./Metadata";
import { Permissions } from "./Permissions";
import { Context, Entity } from "../../../../internal";
import { AssetDetails, AuthorizationRequest, NoArgsProcedureMethod, ProcedureMethod, SecurityIdentifier, SubCallback, TransferAssetOwnershipParams, UniqueIdentifiers, UnsubCallback } from "../../../../types";
/**
 * Class used to manage functionality common to all assets.
 *
 */
export declare class BaseAsset extends Entity<UniqueIdentifiers, string> {
    compliance: Compliance;
    documents: Documents;
    metadata: Metadata;
    permissions: Permissions;
    /**
     * Identity ID of the Asset (used for Claims)
     */
    did: string;
    /**
     * ticker of the Asset
     */
    ticker: string;
    /**
     * Transfer ownership of the Asset to another Identity. This generates an authorization request that must be accepted
     *   by the recipient
     *
     * @note this will create {@link api/entities/AuthorizationRequest!AuthorizationRequest | Authorization Request} which has to be accepted by the `target` Identity.
     *   An {@link api/entities/Account!Account} or {@link api/entities/Identity!Identity} can fetch its pending Authorization Requests by calling {@link api/entities/common/namespaces/Authorizations!Authorizations.getReceived | authorizations.getReceived}.
     *   Also, an Account or Identity can directly fetch the details of an Authorization Request by calling {@link api/entities/common/namespaces/Authorizations!Authorizations.getOne | authorizations.getOne}
     */
    transferOwnership: ProcedureMethod<TransferAssetOwnershipParams, AuthorizationRequest>;
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier: unknown): identifier is UniqueIdentifiers;
    /**
     * @hidden
     *
     * @note It is generally preferable to instantiate `FungibleAsset` or `NftCollection`
     */
    constructor(identifiers: UniqueIdentifiers, context: Context);
    /**
     * Freeze transfers of the Asset
     */
    freeze: NoArgsProcedureMethod<void>;
    /**
     * Unfreeze transfers of the Asset
     */
    unfreeze: NoArgsProcedureMethod<void>;
    /**
     * Retrieve the Asset's identifiers list
     *
     * @note can be subscribed to
     */
    getIdentifiers(): Promise<SecurityIdentifier[]>;
    getIdentifiers(callback?: SubCallback<SecurityIdentifier[]>): Promise<UnsubCallback>;
    /**
     * Check whether transfers are frozen for the Asset
     *
     * @note can be subscribed to
     */
    isFrozen(): Promise<boolean>;
    isFrozen(callback: SubCallback<boolean>): Promise<UnsubCallback>;
    /**
     * Retrieve the Asset's data
     *
     * @note can be subscribed to
     */
    details(): Promise<AssetDetails>;
    details(callback: SubCallback<AssetDetails>): Promise<UnsubCallback>;
    /**
     * @hidden
     */
    exists(): Promise<boolean>;
    /**
     * Return the NftCollection's ticker
     */
    toHuman(): string;
}
//# sourceMappingURL=BaseAsset.d.ts.map