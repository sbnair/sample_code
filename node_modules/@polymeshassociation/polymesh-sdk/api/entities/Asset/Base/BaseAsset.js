"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseAsset = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const Compliance_1 = require("./Compliance");
const Documents_1 = require("./Documents");
const Metadata_1 = require("./Metadata");
const Permissions_1 = require("./Permissions");
const internal_1 = require("../../../../internal");
const types_1 = require("../../../../types");
const utils_1 = require("../../../../utils");
const conversion_1 = require("../../../../utils/conversion");
const internal_2 = require("../../../../utils/internal");
/**
 * Class used to manage functionality common to all assets.
 *
 */
class BaseAsset extends internal_1.Entity {
    /**
     * @hidden
     *
     * @note It is generally preferable to instantiate `FungibleAsset` or `NftCollection`
     */
    constructor(identifiers, context) {
        super(identifiers, context);
        const { ticker } = identifiers;
        this.ticker = ticker;
        this.did = (0, utils_1.tickerToDid)(ticker);
        this.compliance = new Compliance_1.Compliance(this, context);
        this.documents = new Documents_1.Documents(this, context);
        this.metadata = new Metadata_1.Metadata(this, context);
        this.permissions = new Permissions_1.Permissions(this, context);
        this.freeze = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: () => [internal_1.toggleFreezeTransfers, { ticker, freeze: true }],
            voidArgs: true,
        }, context);
        this.unfreeze = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: () => [internal_1.toggleFreezeTransfers, { ticker, freeze: false }],
            voidArgs: true,
        }, context);
        this.transferOwnership = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.transferAssetOwnership, Object.assign({ ticker }, args)] }, context);
    }
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier) {
        const { ticker } = identifier;
        return typeof ticker === 'string';
    }
    // eslint-disable-next-line require-jsdoc
    getIdentifiers(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { asset }, }, }, ticker, context, } = this;
            const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
            if (callback) {
                return asset.identifiers(rawTicker, identifiers => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises -- callback errors should be handled by the caller
                    callback(identifiers.map(conversion_1.assetIdentifierToSecurityIdentifier));
                });
            }
            const assetIdentifiers = yield asset.identifiers(rawTicker);
            return assetIdentifiers.map(conversion_1.assetIdentifierToSecurityIdentifier);
        });
    }
    // eslint-disable-next-line require-jsdoc
    isFrozen(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const { ticker, context: { polymeshApi: { query: { asset }, }, }, context, } = this;
            const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
            if (callback) {
                return asset.frozen(rawTicker, frozen => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises -- callback errors should be handled by the caller
                    callback((0, conversion_1.boolToBoolean)(frozen));
                });
            }
            const result = yield asset.frozen(rawTicker);
            return (0, conversion_1.boolToBoolean)(result);
        });
    }
    // eslint-disable-next-line require-jsdoc
    details(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { asset, externalAgents }, }, }, ticker, context, } = this;
            const assembleResult = (optToken, agentGroups, assetName) => __awaiter(this, void 0, void 0, function* () {
                const fullAgents = [];
                if (optToken.isNone) {
                    throw new internal_1.PolymeshError({
                        message: 'Asset detail information not found',
                        code: types_1.ErrorCode.DataUnavailable,
                    });
                }
                const { totalSupply, divisible, ownerDid, assetType: rawAssetType } = optToken.unwrap();
                agentGroups.forEach(([storageKey, agentGroup]) => {
                    const rawAgentGroup = agentGroup.unwrap();
                    if (rawAgentGroup.isFull) {
                        fullAgents.push(new internal_1.Identity({ did: (0, conversion_1.identityIdToString)(storageKey.args[1]) }, context));
                    }
                });
                const owner = new internal_1.Identity({ did: (0, conversion_1.identityIdToString)(ownerDid) }, context);
                const { value, type } = (0, conversion_1.assetTypeToKnownOrId)(rawAssetType);
                let assetType;
                if (value instanceof bignumber_js_1.default) {
                    const customType = yield asset.customTypes((0, conversion_1.bigNumberToU32)(value, context));
                    assetType = (0, conversion_1.bytesToString)(customType);
                }
                else {
                    assetType = value;
                }
                return {
                    assetType,
                    nonFungible: type === 'NonFungible',
                    isDivisible: (0, conversion_1.boolToBoolean)(divisible),
                    name: (0, conversion_1.bytesToString)(assetName.unwrap()),
                    owner,
                    totalSupply: (0, conversion_1.balanceToBigNumber)(totalSupply),
                    fullAgents,
                };
            });
            const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
            const groupOfAgentPromise = externalAgents.groupOfAgent.entries(rawTicker);
            const namePromise = asset.assetNames(rawTicker);
            if (callback) {
                const groupEntries = yield groupOfAgentPromise;
                const assetName = yield namePromise;
                return asset.tokens(rawTicker, (securityToken) => __awaiter(this, void 0, void 0, function* () {
                    const result = yield assembleResult(securityToken, groupEntries, assetName);
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises -- callback errors should be handled by the caller
                    callback(result);
                }));
            }
            const [token, groups, name] = yield Promise.all([
                asset.tokens(rawTicker),
                groupOfAgentPromise,
                namePromise,
            ]);
            return assembleResult(token, groups, name);
        });
    }
    /**
     * @hidden
     */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            const { ticker, context, context: { polymeshApi: { query }, }, } = this;
            const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
            const [tokenSize, nftId] = yield Promise.all([
                query.asset.tokens.size(rawTicker),
                query.nft.collectionTicker(rawTicker),
            ]);
            return !tokenSize.isZero() && nftId.isZero();
        });
    }
    /**
     * Return the NftCollection's ticker
     */
    toHuman() {
        return this.ticker;
    }
}
exports.BaseAsset = BaseAsset;
//# sourceMappingURL=BaseAsset.js.map