"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Requirements = void 0;
const internal_1 = require("../../../../../internal");
const conversion_1 = require("../../../../../utils/conversion");
const internal_2 = require("../../../../../utils/internal");
/**
 * Handles all Asset Compliance Requirements related functionality
 */
class Requirements extends internal_1.Namespace {
    /**
     * @hidden
     */
    constructor(parent, context) {
        super(parent, context);
        const { ticker } = parent;
        this.add = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.addAssetRequirement, Object.assign({ ticker }, args)] }, context);
        this.remove = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.removeAssetRequirement, Object.assign({ ticker }, args)] }, context);
        this.set = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.setAssetRequirements, Object.assign({ ticker }, args)] }, context);
        this.reset = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: () => [internal_1.setAssetRequirements, { ticker, requirements: [] }],
            voidArgs: true,
        }, context);
        this.pause = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: () => [internal_1.togglePauseRequirements, { ticker, pause: true }],
            voidArgs: true,
        }, context);
        this.unpause = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: () => [internal_1.togglePauseRequirements, { ticker, pause: false }],
            voidArgs: true,
        }, context);
        this.modify = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.modifyComplianceRequirement, Object.assign({ ticker }, args)] }, context);
    }
    // eslint-disable-next-line require-jsdoc
    get(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const { parent: { ticker }, context: { polymeshApi: { query: { complianceManager }, }, }, context, } = this;
            const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
            const assembleResult = ([assetCompliance, claimIssuers]) => {
                const requirements = assetCompliance.requirements.map(complianceRequirement => (0, conversion_1.complianceRequirementToRequirement)(complianceRequirement, context));
                const defaultTrustedClaimIssuers = claimIssuers.map(issuer => (0, conversion_1.trustedIssuerToTrustedClaimIssuer)(issuer, context));
                return { requirements, defaultTrustedClaimIssuers };
            };
            if (callback) {
                return (0, internal_2.requestMulti)(context, [
                    [complianceManager.assetCompliances, rawTicker],
                    [complianceManager.trustedClaimIssuer, rawTicker],
                ], res => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises -- callback errors should be handled by the caller
                    callback(assembleResult(res));
                });
            }
            const result = yield (0, internal_2.requestMulti)(context, [
                [complianceManager.assetCompliances, rawTicker],
                [complianceManager.trustedClaimIssuer, rawTicker],
            ]);
            return assembleResult(result);
        });
    }
    /**
     * Check whether Asset compliance requirements are paused or not
     */
    arePaused() {
        return __awaiter(this, void 0, void 0, function* () {
            const { parent: { ticker }, context: { polymeshApi: { query: { complianceManager }, }, }, context, } = this;
            const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
            const { paused } = yield complianceManager.assetCompliances(rawTicker);
            return (0, conversion_1.boolToBoolean)(paused);
        });
    }
}
exports.Requirements = Requirements;
//# sourceMappingURL=Requirements.js.map