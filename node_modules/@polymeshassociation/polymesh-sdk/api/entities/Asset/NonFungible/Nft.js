"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Nft = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const internal_1 = require("../../../../internal");
const conversion_1 = require("../../../../utils/conversion");
/**
 * Class used to manage Nft functionality
 */
class Nft extends internal_1.Entity {
    /**
     * @hidden
     */
    constructor(identifiers, context) {
        super(identifiers, context);
        const { ticker, id } = identifiers;
        this.id = id;
        this.collection = new internal_1.NftCollection({ ticker }, context);
    }
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier) {
        const { ticker, id } = identifier;
        return typeof ticker === 'string' && id instanceof bignumber_js_1.default;
    }
    /**
     * Get metadata associated with this token
     */
    getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            const { id, context, collection, context: { polymeshApi: { query }, }, } = this;
            const collectionId = yield collection.getCollectionId();
            const rawCollectionId = (0, conversion_1.bigNumberToU64)(collectionId, context);
            const rawId = (0, conversion_1.bigNumberToU64)(id, context);
            const entries = yield query.nft.metadataValue.entries([rawCollectionId, rawId]);
            return entries.map(([storageKey, rawValue]) => {
                const rawMetadataKey = storageKey.args[1];
                const key = (0, conversion_1.meshMetadataKeyToMetadataKey)(rawMetadataKey, collection.ticker);
                const value = (0, conversion_1.bytesToString)(rawValue);
                return { key, value };
            });
        });
    }
    /**
     * Determine if the NFT exists on chain
     *
     * @note This method returns true, even if the token has been redeemed/burned
     */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context, context: { polymeshApi: { query }, }, collection, id, } = this;
            const collectionId = yield collection.getCollectionId();
            const rawCollectionId = (0, conversion_1.bigNumberToU64)(collectionId, context);
            // note: "nextId" is actually the last used id
            const rawNextId = yield query.nft.nextNFTId(rawCollectionId);
            const nextId = (0, conversion_1.u64ToBigNumber)(rawNextId);
            return id.lte(nextId);
        });
    }
    /**
     * @hidden
     */
    toHuman() {
        const { collection: { ticker }, id, } = this;
        return {
            collection: ticker,
            id: id.toString(),
        };
    }
}
exports.Nft = Nft;
//# sourceMappingURL=Nft.js.map