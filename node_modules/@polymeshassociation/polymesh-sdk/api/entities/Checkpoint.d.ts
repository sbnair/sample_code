import BigNumber from 'bignumber.js';
import { Context, Entity, FungibleAsset, Identity } from "../../internal";
import { IdentityBalance, PaginationOptions, ResultSet } from "../../types";
export interface UniqueIdentifiers {
    id: BigNumber;
    ticker: string;
}
export interface HumanReadable {
    id: string;
    ticker: string;
}
/**
 * Represents a snapshot of the Asset's holders and their respective balances
 *   at a certain point in time
 */
export declare class Checkpoint extends Entity<UniqueIdentifiers, HumanReadable> {
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier: unknown): identifier is UniqueIdentifiers;
    /**
     * Checkpoint identifier number
     */
    id: BigNumber;
    /**
     * Asset whose balances are being recorded in this Checkpoint
     */
    asset: FungibleAsset;
    /**
     * @hidden
     */
    constructor(identifiers: UniqueIdentifiers, context: Context);
    /**
     * Retrieve the Asset's total supply at this checkpoint
     */
    totalSupply(): Promise<BigNumber>;
    /**
     * Retrieve this Checkpoint's creation date
     */
    createdAt(): Promise<Date>;
    /**
     * Retrieve all Asset Holder balances at this Checkpoint
     *
     * @note supports pagination
     * @note current Asset holders who didn't hold any tokens when the Checkpoint was created will be listed with a balance of 0.
     * This arises from a chain storage optimization and pagination. @see {@link balance} for a more detailed explanation of the logic
     */
    allBalances(paginationOpts?: PaginationOptions): Promise<ResultSet<IdentityBalance>>;
    /**
     * Retrieve the balance of a specific Asset Holder Identity at this Checkpoint
     *
     * @param args.identity - defaults to the signing Identity
     * @note A checkpoint only records balances when they change. The implementation is to query for all balance updates for [ticker, did] pair.
     * If no balance updates have happened since the Checkpoint has been created, then the storage will not have an entry for the user. Instead the current balance should be used.
     * The balance is stored only when the Identity makes a transaction after a Checkpoint is created. This helps keep storage usage to a minimum
     */
    balance(args?: {
        identity: string | Identity;
    }): Promise<BigNumber>;
    /**
     * Determine whether this Checkpoint exists on chain
     */
    exists(): Promise<boolean>;
    /**
     * Return the Checkpoint's ticker and identifier
     */
    toHuman(): HumanReadable;
}
//# sourceMappingURL=Checkpoint.d.ts.map