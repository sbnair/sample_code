"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Entity = void 0;
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const internal_2 = require("../../utils/internal");
/**
 * Represents an object or resource in the Polymesh Ecosystem with its own set of properties and functionality
 */
class Entity {
    /**
     * @hidden
     */
    constructor(identifiers, context) {
        this.uuid = this.constructor.generateUuid(identifiers);
        this.context = context;
    }
    /**
     * Generate the Entity's UUID from its identifying properties
     *
     * @param identifiers
     */
    static generateUuid(identifiers) {
        return (0, internal_2.serialize)(this.name, identifiers);
    }
    /**
     * Unserialize a UUID into its Unique Identifiers
     *
     * @param serialized - UUID to unserialize
     */
    static unserialize(serialized) {
        const unserialized = (0, internal_2.unserialize)(serialized);
        if (!this.isUniqueIdentifiers(unserialized)) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: `The string doesn't correspond to the UUID of type ${this.name}`,
            });
        }
        return unserialized;
    }
    /* istanbul ignore next: this function should always be overridden */
    /**
     * Typeguard that checks whether the object passed corresponds to the unique identifiers of the class. Must be overridden
     *
     * @param identifiers - object to type check
     */
    static isUniqueIdentifiers(identifiers) {
        return !!identifiers;
    }
    /**
     * Determine whether this Entity is the same as another one
     */
    isEqual(entity) {
        return this.uuid === entity.uuid;
    }
}
exports.Entity = Entity;
//# sourceMappingURL=Entity.js.map