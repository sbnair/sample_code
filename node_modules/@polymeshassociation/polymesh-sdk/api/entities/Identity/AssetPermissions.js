"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetPermissions = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bluebird_1 = __importDefault(require("bluebird"));
const internal_1 = require("../../../internal");
const queries_1 = require("../../../middleware/queries");
const types_1 = require("../../../types");
const conversion_1 = require("../../../utils/conversion");
const internal_2 = require("../../../utils/internal");
/**
 * @hidden
 *
 * Check whether a tag is "present" in (represented by) a set of values and exceptions, using the following criteria:
 *
 * - if type is include:
 *   the passed tags are in the values array AND are not in the exceptions array (isInValues && !isInExceptions)
 * - if type is exclude:
 *   the passed tags are not in the values array OR are in the exceptions array (!isInValues || isInExceptions)
 */
function isPresent(tag, values, exceptions, flipResult) {
    const isInValues = values.some(value => (0, internal_2.isModuleOrTagMatch)(value, tag));
    const isInExceptions = !!(exceptions === null || exceptions === void 0 ? void 0 : exceptions.includes(tag));
    const result = isInValues && !isInExceptions;
    return flipResult ? result : !result;
}
/**
 * Handles all Asset Permissions (External Agents) related functionality on the Identity side
 */
class AssetPermissions extends internal_1.Namespace {
    /**
     * @hidden
     */
    constructor(parent, context) {
        super(parent, context);
        this.waive = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.waivePermissions, Object.assign(Object.assign({}, args), { identity: parent })] }, context);
        this.setGroup = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.setPermissionGroup, Object.assign(Object.assign({}, args), { identity: parent })] }, context);
    }
    /**
     * Retrieve all the Assets over which this Identity has permissions, with the corresponding Permission Group
     */
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { externalAgents }, }, }, parent: { did }, context, } = this;
            const rawDid = (0, conversion_1.stringToIdentityId)(did, context);
            const assetEntries = yield externalAgents.agentOf.entries(rawDid);
            return bluebird_1.default.map(assetEntries, ([key]) => __awaiter(this, void 0, void 0, function* () {
                const ticker = (0, conversion_1.tickerToString)(key.args[1]);
                const asset = new internal_1.FungibleAsset({ ticker }, context);
                const group = yield this.getGroup({ asset });
                return {
                    asset,
                    group,
                };
            }));
        });
    }
    /**
     * Check whether this Identity has specific transaction Permissions over an Asset
     */
    checkPermissions(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { externalAgents }, }, }, context, parent: { did }, } = this;
            const { asset, transactions } = args;
            if ((transactions === null || transactions === void 0 ? void 0 : transactions.length) === 0) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.ValidationError,
                    message: 'Cannot check Permissions for an empty transaction array',
                });
            }
            const ticker = (0, internal_2.asTicker)(asset);
            const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
            const groupOption = yield externalAgents.groupOfAgent(rawTicker, (0, conversion_1.stringToIdentityId)(did, context));
            if (groupOption.isNone) {
                return {
                    missingPermissions: transactions,
                    result: false,
                    message: 'The Identity is not an Agent for the Asset',
                };
            }
            const group = groupOption.unwrap();
            if (group.isFull) {
                return {
                    result: true,
                };
            }
            let missingPermissions;
            if (group.isCustom) {
                const groupId = group.asCustom;
                const groupPermissionsOption = yield externalAgents.groupPermissions(rawTicker, groupId);
                const permissions = (0, conversion_1.extrinsicPermissionsToTransactionPermissions)(groupPermissionsOption.unwrap());
                if (permissions === null) {
                    return {
                        result: true,
                    };
                }
                if (transactions === null) {
                    return {
                        result: false,
                        missingPermissions: null,
                    };
                }
                const { type, exceptions, values } = permissions;
                const isInclude = type === types_1.PermissionType.Include;
                missingPermissions = transactions.filter(tag => !isPresent(tag, values, exceptions, isInclude));
            }
            if (transactions === null) {
                return {
                    result: false,
                    missingPermissions: null,
                };
            }
            /*
             * Not authorized:
             *   - externalAgents
             */
            if (group.isExceptMeta) {
                missingPermissions = transactions.filter(tag => tag.split('.')[0] === types_1.ModuleName.ExternalAgents);
            }
            /*
             * Authorized:
             *   - asset.issue
             *   - asset.redeem
             *   - asset.controllerTransfer
             *   - sto (except for sto.invest)
             */
            if (group.isPolymeshV1PIA) {
                missingPermissions = transactions.filter(tag => {
                    const isSto = tag.split('.')[0] === types_1.ModuleName.Sto && tag !== types_1.TxTags.sto.Invest;
                    const isAsset = [
                        types_1.TxTags.asset.Issue,
                        types_1.TxTags.asset.Redeem,
                        types_1.TxTags.asset.ControllerTransfer,
                    ].includes(tag);
                    return !isSto && !isAsset;
                });
            }
            /*
             * Authorized:
             *   - corporateAction
             *   - corporateBallot
             *   - capitalDistribution
             */
            if (group.isPolymeshV1CAA) {
                missingPermissions = transactions.filter(tag => ![
                    types_1.ModuleName.CorporateAction,
                    types_1.ModuleName.CorporateBallot,
                    types_1.ModuleName.CapitalDistribution,
                ].includes(tag.split('.')[0]));
            }
            /* eslint-disable @typescript-eslint/no-non-null-assertion */
            if (missingPermissions.length) {
                return {
                    missingPermissions: missingPermissions,
                    result: false,
                };
            }
            /* eslint-enable @typescript-eslint/no-non-null-assertion */
            return {
                result: true,
            };
        });
    }
    /**
     * Retrieve this Identity's Permission Group for a specific Asset
     */
    getGroup({ asset, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { externalAgents }, }, }, context, parent: { did }, } = this;
            const ticker = (0, internal_2.asTicker)(asset);
            const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
            const rawIdentityId = (0, conversion_1.stringToIdentityId)(did, context);
            const rawGroupPermissions = yield externalAgents.groupOfAgent(rawTicker, rawIdentityId);
            if (rawGroupPermissions.isNone) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: 'This Identity is no longer an Agent for this Asset',
                });
            }
            const agentGroup = rawGroupPermissions.unwrap();
            return (0, conversion_1.agentGroupToPermissionGroup)(agentGroup, ticker, context);
        });
    }
    /**
     * Retrieve the identifier data (block number, date and event index) of the event that was emitted when this Identity was enabled/added as
     *   an Agent with permissions over a specific Asset
     *
     * @note uses the middlewareV2
     * @note there is a possibility that the data is not ready by the time it is requested. In that case, `null` is returned
     */
    enabledAt({ asset, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const ticker = (0, internal_2.asTicker)(asset);
            const { data: { tickerExternalAgents: { nodes: [node], }, }, } = yield context.queryMiddleware((0, queries_1.tickerExternalAgentsQuery)({
                assetId: ticker,
            }));
            return (0, internal_2.optionize)(conversion_1.middlewareEventDetailsToEventIdentifier)(node === null || node === void 0 ? void 0 : node.createdBlock, node === null || node === void 0 ? void 0 : node.eventIdx);
        });
    }
    /**
     * Retrieve all Events triggered by Operations this Identity has performed on a specific Asset
     *
     * @param opts.moduleId - filters results by module
     * @param opts.eventId - filters results by event
     * @param opts.size - page size
     * @param opts.start - page offset
     *
     * @note uses the middlewareV2
     * @note supports pagination
     */
    getOperationHistory(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context, parent: { did }, } = this;
            const { asset, moduleId: palletName, eventId, size, start } = opts;
            const ticker = (0, internal_2.asTicker)(asset);
            const { data: { tickerExternalAgentActions: { nodes, totalCount }, }, } = yield context.queryMiddleware((0, queries_1.tickerExternalAgentActionsQuery)({
                assetId: ticker,
                callerId: did,
                palletName,
                eventId,
            }, size, start));
            const data = nodes.map(({ createdBlock, eventIdx }) => 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            (0, conversion_1.middlewareEventDetailsToEventIdentifier)(createdBlock, eventIdx));
            const count = new bignumber_js_1.default(totalCount);
            const next = (0, internal_2.calculateNextKey)(count, data.length, start);
            return {
                data,
                next,
                count,
            };
        });
    }
}
exports.AssetPermissions = AssetPermissions;
//# sourceMappingURL=AssetPermissions.js.map