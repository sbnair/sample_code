"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IdentityAuthorizations = void 0;
const internal_1 = require("../../../internal");
const utils_1 = require("../../../types/utils");
const conversion_1 = require("../../../utils/conversion");
const internal_2 = require("../../../utils/internal");
/**
 * Handles all Identity Authorization related functionality
 */
class IdentityAuthorizations extends internal_1.Authorizations {
    /**
     * Fetch all pending authorization requests issued by this Identity
     *
     * @note supports pagination
     */
    getSent(paginationOpts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { identity }, }, }, context, parent: { did }, } = this;
            const { entries, lastKey: next } = yield (0, internal_2.requestPaginated)(identity.authorizationsGiven, {
                arg: (0, conversion_1.stringToIdentityId)(did, context),
                paginationOpts,
            });
            const authQueryParams = entries.map(([storageKey, signatory]) => (0, utils_1.tuple)(signatory, storageKey.args[1]));
            const authorizations = yield identity.authorizations.multi(authQueryParams);
            const data = this.createAuthorizationRequests(authorizations.map((auth, index) => ({
                auth: auth.unwrap(),
                target: (0, conversion_1.signatoryToSignerValue)(authQueryParams[index][0]),
            })));
            return {
                data,
                next,
            };
        });
    }
    /**
     * Retrieve a single Authorization Request targeting or issued by this Identity by its ID
     *
     * @throws if there is no Authorization Request with the passed ID targeting or issued by this Identity
     */
    getOne(args) {
        const _super = Object.create(null, {
            getOne: { get: () => super.getOne }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const { context, parent: { did }, context: { polymeshApi: { query: { identity }, }, }, } = this;
            const { id } = args;
            const rawId = (0, conversion_1.bigNumberToU64)(id, context);
            /*
             * We're using `defusePromise` here because if the id corresponds to a sent auth,
             * we don't care about the error, and if it doesn't, then we return the promise and
             * the error will be handled by the caller
             */
            const gettingReceivedAuth = (0, internal_2.defusePromise)(_super.getOne.call(this, { id }));
            /**
             * `authorizations` storage only returns results for the authorization target,
             * so `authorizationsGiven` needs to be queried first to find the relevant target if present
             */
            const targetSignatory = yield identity.authorizationsGiven((0, conversion_1.stringToIdentityId)(did, context), rawId);
            if (!targetSignatory.isEmpty) {
                const auth = yield identity.authorizations(targetSignatory, rawId);
                const target = (0, conversion_1.signatoryToSignerValue)(targetSignatory);
                return this.createAuthorizationRequests([{ auth: auth.unwrap(), target }])[0];
            }
            return gettingReceivedAuth;
        });
    }
}
exports.IdentityAuthorizations = IdentityAuthorizations;
//# sourceMappingURL=IdentityAuthorizations.js.map