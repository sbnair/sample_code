import BigNumber from 'bignumber.js';
import { ChildIdentity, Context, Entity, FungibleAsset, Venue } from "../../../internal";
import { AssetHoldersOrderBy } from "../../../middleware/types";
import { CheckRolesResult, DistributionWithDetails, GroupedInstructions, GroupedInvolvedInstructions, HistoricInstruction, PaginationOptions, PermissionedAccount, ProcedureMethod, ResultSet, Role, SubCallback, UnlinkChildParams, UnsubCallback } from "../../../types";
import { AssetPermissions } from './AssetPermissions';
import { IdentityAuthorizations } from './IdentityAuthorizations';
import { Portfolios } from './Portfolios';
/**
 * Properties that uniquely identify an Identity
 */
export interface UniqueIdentifiers {
    did: string;
}
/**
 * Represents an Identity in the Polymesh blockchain
 */
export declare class Identity extends Entity<UniqueIdentifiers, string> {
    /**
     * @hidden
     * Checks if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier: unknown): identifier is UniqueIdentifiers;
    /**
     * Identity ID as stored in the blockchain
     */
    did: string;
    authorizations: IdentityAuthorizations;
    portfolios: Portfolios;
    assetPermissions: AssetPermissions;
    /**
     * Create an Identity entity
     *
     * @hidden
     */
    constructor(identifiers: UniqueIdentifiers, context: Context);
    /**
     * Check whether this Identity possesses the specified Role
     */
    hasRole(role: Role): Promise<boolean>;
    /**
     * Retrieve the balance of a particular Asset
     *
     * @note can be subscribed to
     */
    getAssetBalance(args: {
        ticker: string;
    }): Promise<BigNumber>;
    getAssetBalance(args: {
        ticker: string;
    }, callback: SubCallback<BigNumber>): Promise<UnsubCallback>;
    /**
     * Check whether this Identity has a valid CDD claim
     */
    hasValidCdd(): Promise<boolean>;
    /**
     * Check whether this Identity is Governance Committee member
     */
    isGcMember(): Promise<boolean>;
    /**
     * Check whether this Identity is a CDD provider
     */
    isCddProvider(): Promise<boolean>;
    /**
     * Retrieve the primary Account associated with the Identity
     *
     * @note can be subscribed to
     */
    getPrimaryAccount(): Promise<PermissionedAccount>;
    getPrimaryAccount(callback: SubCallback<PermissionedAccount>): Promise<UnsubCallback>;
    /**
     * Retrieve a list of all Assets which were held at one point by this Identity
     *
     * @note uses the middlewareV2
     * @note supports pagination
     */
    getHeldAssets(opts?: {
        order?: AssetHoldersOrderBy;
        size?: BigNumber;
        start?: BigNumber;
    }): Promise<ResultSet<FungibleAsset>>;
    /**
     * Check whether this Identity possesses all specified roles
     */
    checkRoles(roles: Role[]): Promise<CheckRolesResult>;
    /**
     * Get the list of Assets for which this Identity is a trusted claim issuer
     *
     * @note uses the middlewareV2
     */
    getTrustingAssets(): Promise<FungibleAsset[]>;
    /**
     * Retrieve all Venues created by this Identity
     *
     * @note can be subscribed to
     */
    getVenues(): Promise<Venue[]>;
    /**
     * Retrieve all Instructions where this Identity is a custodian of one or more portfolios in the legs,
     *   grouped by status
     */
    getInstructions(): Promise<GroupedInstructions>;
    /**
     * Get all the instructions grouped by status, where given portfolios are involved
     *
     * @hidden
     */
    private assembleGroupedInstructions;
    /**
     * Retrieve all Instructions where this Identity is a participant (owner/custodian),
     *   grouped by the role of the Identity and Instruction status
     */
    getInvolvedInstructions(): Promise<GroupedInvolvedInstructions>;
    /**
     * Check whether secondary Accounts are frozen
     *
     * @note can be subscribed to
     */
    areSecondaryAccountsFrozen(): Promise<boolean>;
    areSecondaryAccountsFrozen(callback: SubCallback<boolean>): Promise<UnsubCallback>;
    /**
     * Retrieve every Dividend Distribution for which this Identity is eligible and hasn't been paid
     *
     * @note uses the middleware
     * @note this query can be potentially **SLOW** depending on which Assets this Identity has held
     */
    getPendingDistributions(): Promise<DistributionWithDetails[]>;
    /**
     * Get the list of secondary Accounts related to the Identity
     *
     * @note supports pagination
     * @note can be subscribed to
     */
    getSecondaryAccounts(paginationOpts?: PaginationOptions): Promise<ResultSet<PermissionedAccount>>;
    getSecondaryAccounts(callback: SubCallback<PermissionedAccount[]>): Promise<UnsubCallback>;
    getSecondaryAccounts(paginationOpts: PaginationOptions, callback: SubCallback<PermissionedAccount[]>): Promise<UnsubCallback>;
    /**
     * Determine whether this Identity exists on chain
     *
     * @note asset Identities aren't considered to exist for this check
     */
    exists(): Promise<boolean>;
    /**
     * Return the Identity's DID
     */
    toHuman(): string;
    /**
     * Retrieve all Instructions that have been associated with this Identity's DID
     *
     * @note uses the middleware V2
     */
    getHistoricalInstructions(): Promise<HistoricInstruction[]>;
    /**
     * Returns the list of all child identities
     *
     * @note this query can be potentially **SLOW** depending on the number of parent Identities present on the chain
     */
    getChildIdentities(): Promise<ChildIdentity[]>;
    /**
     * Unlinks a child identity
     *
     * @throws if
     *  - the `child` is not a child of this identity
     *  - the transaction signer is not the primary key of the parent identity
     */
    unlinkChild: ProcedureMethod<UnlinkChildParams, void>;
    /**
     * Check whether this Identity is a child Identity
     */
    isChild(): Promise<boolean>;
}
//# sourceMappingURL=index.d.ts.map