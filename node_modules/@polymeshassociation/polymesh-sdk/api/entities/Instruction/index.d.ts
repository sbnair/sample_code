import BigNumber from 'bignumber.js';
import { Context, Entity } from "../../../internal";
import { AffirmOrWithdrawInstructionParams, DefaultPortfolio, ExecuteManualInstructionParams, NumberedPortfolio, OptionalArgsProcedureMethod, PaginationOptions, RejectInstructionParams, ResultSet, SubCallback, UnsubCallback } from "../../../types";
import { InstructionAffirmation, InstructionDetails, InstructionStatus, InstructionStatusResult, Leg } from './types';
export interface UniqueIdentifiers {
    id: BigNumber;
}
/**
 * Represents a settlement Instruction to be executed on a certain Venue
 */
export declare class Instruction extends Entity<UniqueIdentifiers, string> {
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier: unknown): identifier is UniqueIdentifiers;
    /**
     * Unique identifier number of the instruction
     */
    id: BigNumber;
    /**
     * @hidden
     */
    constructor(identifiers: UniqueIdentifiers, context: Context);
    /**
     * Retrieve whether the Instruction has already been executed and pruned from
     *   the chain.
     */
    isExecuted(): Promise<boolean>;
    /**
     * Retrieve whether the Instruction is still pending on chain
     */
    isPending(): Promise<boolean>;
    /**
     * Retrieve current status of the Instruction. This can be subscribed to know if instruction fails
     *
     * @note can be subscribed to
     * @note current status as `Executed` means that the Instruction has been executed/rejected and pruned from
     *   the chain.
     */
    onStatusChange(callback: SubCallback<InstructionStatus>): Promise<UnsubCallback>;
    /**
     * Determine whether this Instruction exists on chain (or existed and was pruned)
     */
    exists(): Promise<boolean>;
    /**
     * Retrieve information specific to this Instruction
     */
    details(): Promise<InstructionDetails>;
    /**
     * Retrieve every authorization generated by this Instruction (status and authorizing Identity)
     *
     * @note supports pagination
     */
    getAffirmations(paginationOpts?: PaginationOptions): Promise<ResultSet<InstructionAffirmation>>;
    /**
     * Retrieve all legs of this Instruction
     *
     * @note supports pagination
     */
    getLegs(paginationOpts?: PaginationOptions): Promise<ResultSet<Leg>>;
    /**
     * Retrieve current status of this Instruction
     *
     * @note uses the middlewareV2
     */
    getStatus(): Promise<InstructionStatusResult>;
    /**
     * Reject this instruction
     *
     * @note reject on `SettleOnAffirmation` will execute the settlement and it will fail immediately.
     * @note reject on `SettleOnBlock` behaves just like unauthorize
     * @note reject on `SettleManual` behaves just like unauthorize
     */
    reject: OptionalArgsProcedureMethod<RejectInstructionParams, Instruction>;
    /**
     * Affirm this instruction (authorize)
     */
    affirm: OptionalArgsProcedureMethod<AffirmOrWithdrawInstructionParams, Instruction>;
    /**
     * Withdraw affirmation from this instruction (unauthorize)
     */
    withdraw: OptionalArgsProcedureMethod<AffirmOrWithdrawInstructionParams, Instruction>;
    /**
     * Executes an Instruction either of type `SettleManual` or a `Failed` instruction
     */
    executeManually: OptionalArgsProcedureMethod<ExecuteManualInstructionParams, Instruction>;
    /**
     * @hidden
     * Retrieve Instruction status event from middleware V2
     */
    private getInstructionEventFromMiddleware;
    /**
     * Return the Instruction's ID
     */
    toHuman(): string;
    /**
     * Retrieve all the involved portfolios in this Instruction where the given identity is a custodian of
     */
    getInvolvedPortfolios(args: {
        did: string;
    }): Promise<(DefaultPortfolio | NumberedPortfolio)[]>;
    /**
     * @hidden
     */
    private internalToExternalStatus;
}
//# sourceMappingURL=index.d.ts.map