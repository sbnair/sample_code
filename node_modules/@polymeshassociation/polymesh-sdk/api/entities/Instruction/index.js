"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Instruction = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bluebird_1 = __importDefault(require("bluebird"));
const executeManualInstruction_1 = require("../../procedures/executeManualInstruction");
const internal_1 = require("../../../internal");
const enums_1 = require("../../../middleware/enums");
const queries_1 = require("../../../middleware/queries");
const types_1 = require("../../../types");
const internal_2 = require("../../../types/internal");
const conversion_1 = require("../../../utils/conversion");
const internal_3 = require("../../../utils/internal");
const types_2 = require("./types");
const executedMessage = 'Instruction has already been executed/rejected and it was purged from chain';
/**
 * Represents a settlement Instruction to be executed on a certain Venue
 */
class Instruction extends internal_1.Entity {
    /**
     * @hidden
     */
    constructor(identifiers, context) {
        super(identifiers, context);
        const { id } = identifiers;
        this.id = id;
        this.reject = (0, internal_3.createProcedureMethod)({
            getProcedureAndArgs: args => [
                internal_1.modifyInstructionAffirmation,
                Object.assign({ id, operation: types_1.InstructionAffirmationOperation.Reject }, args),
            ],
            optionalArgs: true,
        }, context);
        this.affirm = (0, internal_3.createProcedureMethod)({
            getProcedureAndArgs: args => [
                internal_1.modifyInstructionAffirmation,
                Object.assign({ id, operation: types_1.InstructionAffirmationOperation.Affirm }, args),
            ],
            optionalArgs: true,
        }, context);
        this.withdraw = (0, internal_3.createProcedureMethod)({
            getProcedureAndArgs: args => [
                internal_1.modifyInstructionAffirmation,
                Object.assign({ id, operation: types_1.InstructionAffirmationOperation.Withdraw }, args),
            ],
            optionalArgs: true,
        }, context);
        this.executeManually = (0, internal_3.createProcedureMethod)({
            getProcedureAndArgs: args => [executeManualInstruction_1.executeManualInstruction, Object.assign({ id }, args)],
            optionalArgs: true,
        }, context);
    }
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier) {
        const { id } = identifier;
        return id instanceof bignumber_js_1.default;
    }
    /**
     * Retrieve whether the Instruction has already been executed and pruned from
     *   the chain.
     */
    isExecuted() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { settlement }, }, }, id, context, } = this;
            const [status, exists] = yield Promise.all([
                settlement.instructionStatuses((0, conversion_1.bigNumberToU64)(id, context)),
                this.exists(),
            ]);
            const statusResult = (0, conversion_1.meshInstructionStatusToInstructionStatus)(status);
            return ((statusResult === internal_2.InstructionStatus.Unknown ||
                statusResult === internal_2.InstructionStatus.Success ||
                statusResult === internal_2.InstructionStatus.Rejected) &&
                exists);
        });
    }
    /**
     * Retrieve whether the Instruction is still pending on chain
     */
    isPending() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { settlement }, }, }, id, context, } = this;
            const status = yield settlement.instructionStatuses((0, conversion_1.bigNumberToU64)(id, context));
            const statusResult = (0, conversion_1.meshInstructionStatusToInstructionStatus)(status);
            return statusResult === internal_2.InstructionStatus.Pending;
        });
    }
    /**
     * Retrieve current status of the Instruction. This can be subscribed to know if instruction fails
     *
     * @note can be subscribed to
     * @note current status as `Executed` means that the Instruction has been executed/rejected and pruned from
     *   the chain.
     */
    onStatusChange(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { settlement }, }, }, id, context, } = this;
            const assembleResult = (rawStatus) => {
                const internalStatus = (0, conversion_1.meshInstructionStatusToInstructionStatus)(rawStatus);
                const status = this.internalToExternalStatus(internalStatus);
                if (!status) {
                    throw new Error('Unknown instruction status');
                }
                return status;
            };
            return settlement.instructionStatuses((0, conversion_1.bigNumberToU64)(id, context), status => {
                return callback(assembleResult(status));
            });
        });
    }
    /**
     * Determine whether this Instruction exists on chain (or existed and was pruned)
     */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { settlement }, }, }, id, } = this;
            const instructionCounter = yield settlement.instructionCounter();
            return id.lte((0, conversion_1.u64ToBigNumber)(instructionCounter));
        });
    }
    /**
     * Retrieve information specific to this Instruction
     */
    details() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { settlement }, }, }, id, context, } = this;
            const rawId = (0, conversion_1.bigNumberToU64)(id, context);
            const [{ createdAt, tradeDate, valueDate, settlementType: type, venueId }, rawStatus, memo] = yield (0, internal_3.requestMulti)(context, [
                [settlement.instructionDetails, rawId],
                [settlement.instructionStatuses, rawId],
                [settlement.instructionMemos, rawId],
            ]);
            const internalStatus = (0, conversion_1.meshInstructionStatusToInstructionStatus)(rawStatus);
            const status = this.internalToExternalStatus(internalStatus);
            if (!status) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: executedMessage,
                });
            }
            return Object.assign({ status, createdAt: (0, conversion_1.momentToDate)(createdAt.unwrap()), tradeDate: tradeDate.isSome ? (0, conversion_1.momentToDate)(tradeDate.unwrap()) : null, valueDate: valueDate.isSome ? (0, conversion_1.momentToDate)(valueDate.unwrap()) : null, venue: new internal_1.Venue({ id: (0, conversion_1.u64ToBigNumber)(venueId) }, context), memo: memo.isSome ? (0, conversion_1.instructionMemoToString)(memo.unwrap()) : null }, (0, conversion_1.meshSettlementTypeToEndCondition)(type));
        });
    }
    /**
     * Retrieve every authorization generated by this Instruction (status and authorizing Identity)
     *
     * @note supports pagination
     */
    getAffirmations(paginationOpts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { settlement }, }, }, id, context, } = this;
            const isExecuted = yield this.isExecuted();
            if (isExecuted) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: executedMessage,
                });
            }
            const { entries, lastKey: next } = yield (0, internal_3.requestPaginated)(settlement.affirmsReceived, {
                arg: (0, conversion_1.bigNumberToU64)(id, context),
                paginationOpts,
            });
            const data = entries.map(([{ args }, meshAffirmationStatus]) => {
                const [, { did }] = args;
                return {
                    identity: new internal_1.Identity({ did: (0, conversion_1.identityIdToString)(did) }, context),
                    status: (0, conversion_1.meshAffirmationStatusToAffirmationStatus)(meshAffirmationStatus),
                };
            });
            return {
                data,
                next,
            };
        });
    }
    /**
     * Retrieve all legs of this Instruction
     *
     * @note supports pagination
     */
    getLegs(paginationOpts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { settlement }, }, }, id, context, } = this;
            const isExecuted = yield this.isExecuted();
            if (isExecuted) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: executedMessage,
                });
            }
            const { entries: legs, lastKey: next } = yield (0, internal_3.requestPaginated)(settlement.instructionLegs, {
                arg: (0, conversion_1.bigNumberToU64)(id, context),
                paginationOpts,
            });
            const data = legs.map(([, leg]) => {
                if (leg.isSome) {
                    const legValue = leg.unwrap();
                    if (legValue.isFungible) {
                        const { sender, receiver, amount, ticker: rawTicker } = legValue.asFungible;
                        const ticker = (0, conversion_1.tickerToString)(rawTicker);
                        const fromPortfolio = (0, conversion_1.meshPortfolioIdToPortfolio)(sender, context);
                        const toPortfolio = (0, conversion_1.meshPortfolioIdToPortfolio)(receiver, context);
                        return {
                            from: fromPortfolio,
                            to: toPortfolio,
                            amount: (0, conversion_1.balanceToBigNumber)(amount),
                            asset: new internal_1.FungibleAsset({ ticker }, context),
                        };
                    }
                    else if (legValue.isNonFungible) {
                        throw new Error('TODO ERROR: NFT legs are not supported yet');
                    }
                    else {
                        // assume it is offchain
                        throw new Error('TODO ERROR: Offchain legs are not supported yet');
                    }
                }
                else {
                    throw new Error('Instruction has already been executed/rejected and it was purged from chain');
                }
            });
            return {
                data,
                next,
            };
        });
    }
    /**
     * Retrieve current status of this Instruction
     *
     * @note uses the middlewareV2
     */
    getStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            const isPending = yield this.isPending();
            if (isPending) {
                return {
                    status: types_2.InstructionStatus.Pending,
                };
            }
            const [executedEventIdentifier, failedEventIdentifier] = yield Promise.all([
                this.getInstructionEventFromMiddleware(enums_1.InstructionStatusEnum.Executed),
                this.getInstructionEventFromMiddleware(enums_1.InstructionStatusEnum.Failed),
            ]);
            if (executedEventIdentifier) {
                return {
                    status: types_2.InstructionStatus.Success,
                    eventIdentifier: executedEventIdentifier,
                };
            }
            if (failedEventIdentifier) {
                return {
                    status: types_2.InstructionStatus.Failed,
                    eventIdentifier: failedEventIdentifier,
                };
            }
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.DataUnavailable,
                message: "It isn't possible to determine the current status of this Instruction",
            });
        });
    }
    /**
     * @hidden
     * Retrieve Instruction status event from middleware V2
     */
    getInstructionEventFromMiddleware(status) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id, context } = this;
            const { data: { instructions: { nodes: [details], }, }, } = yield context.queryMiddleware((0, queries_1.instructionsQuery)({
                status,
                id: id.toString(),
            }, new bignumber_js_1.default(1), new bignumber_js_1.default(0)));
            return (0, internal_3.optionize)(conversion_1.middlewareEventDetailsToEventIdentifier)(details === null || details === void 0 ? void 0 : details.updatedBlock, details === null || details === void 0 ? void 0 : details.eventIdx);
        });
    }
    /**
     * Return the Instruction's ID
     */
    toHuman() {
        return this.id.toString();
    }
    /**
     * Retrieve all the involved portfolios in this Instruction where the given identity is a custodian of
     */
    getInvolvedPortfolios(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { did } = args;
            const { data: legs } = yield this.getLegs();
            const assemblePortfolios = (involvedPortfolios, from, to) => __awaiter(this, void 0, void 0, function* () {
                const [fromExists, toExists] = yield Promise.all([from.exists(), to.exists()]);
                const checkCustody = (legPortfolio, exists) => __awaiter(this, void 0, void 0, function* () {
                    if (exists) {
                        const isCustodied = yield legPortfolio.isCustodiedBy({ identity: did });
                        if (isCustodied) {
                            involvedPortfolios.push(legPortfolio);
                        }
                    }
                    else if (legPortfolio.owner.did === did) {
                        involvedPortfolios.push(legPortfolio);
                    }
                });
                yield Promise.all([checkCustody(from, fromExists), checkCustody(to, toExists)]);
                return involvedPortfolios;
            });
            const portfolios = yield bluebird_1.default.reduce(legs, (result, { from, to }) => __awaiter(this, void 0, void 0, function* () { return assemblePortfolios(result, from, to); }), []);
            return portfolios;
        });
    }
    /**
     * @hidden
     */
    internalToExternalStatus(status) {
        switch (status) {
            case internal_2.InstructionStatus.Pending:
                return types_2.InstructionStatus.Pending;
            case internal_2.InstructionStatus.Failed:
                return types_2.InstructionStatus.Failed;
            case internal_2.InstructionStatus.Success:
                return types_2.InstructionStatus.Success;
            case internal_2.InstructionStatus.Rejected:
                return types_2.InstructionStatus.Rejected;
        }
        return null;
    }
}
exports.Instruction = Instruction;
//# sourceMappingURL=index.js.map