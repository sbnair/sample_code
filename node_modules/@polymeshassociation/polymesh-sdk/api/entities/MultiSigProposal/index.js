"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiSigProposal = void 0;
const internal_1 = require("../../../internal");
const types_1 = require("../../../types");
const conversion_1 = require("../../../utils/conversion");
const internal_2 = require("../../../utils/internal");
/**
 * A proposal for a MultiSig transaction. This is a wrapper around an extrinsic that will be executed when the amount of approvals reaches the signature threshold set on the MultiSig Account
 */
class MultiSigProposal extends internal_1.Entity {
    /**
     * @hidden
     */
    constructor(identifiers, context) {
        super(identifiers, context);
        const { multiSigAddress, id } = identifiers;
        (0, internal_2.assertAddressValid)(multiSigAddress, context.ss58Format);
        this.multiSig = new internal_1.MultiSig({ address: multiSigAddress }, context);
        this.id = id;
    }
    /**
     * Fetches the details of the Proposal. This includes the amount of approvals and rejections, the expiry, and details of the wrapped extrinsic
     */
    details() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { multiSig }, }, }, multiSig: { address: multiSigAddress }, id, context, } = this;
            const rawMultiSignAddress = (0, conversion_1.stringToAccountId)(multiSigAddress, context);
            const rawId = (0, conversion_1.bigNumberToU64)(id, context);
            const [{ approvals: rawApprovals, rejections: rawRejections, status: rawStatus, expiry: rawExpiry, autoClose: rawAutoClose, }, proposal,] = yield Promise.all([
                multiSig.proposalDetail([rawMultiSignAddress, rawId]),
                multiSig.proposals([rawMultiSignAddress, rawId]),
            ]);
            let args, method, section;
            if (proposal.isNone) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: `Proposal with ID: "${id}" was not found. It may have already been executed`,
                });
            }
            else {
                ({ args, method, section } = proposal.unwrap());
            }
            const approvalAmount = (0, conversion_1.u64ToBigNumber)(rawApprovals);
            const rejectionAmount = (0, conversion_1.u64ToBigNumber)(rawRejections);
            const expiry = (0, internal_2.optionize)(conversion_1.momentToDate)(rawExpiry.unwrapOr(null));
            const status = (0, conversion_1.meshProposalStatusToProposalStatus)(rawStatus, expiry);
            const autoClose = (0, conversion_1.boolToBoolean)(rawAutoClose);
            return {
                approvalAmount,
                rejectionAmount,
                status,
                expiry,
                autoClose,
                args: args.map(a => a.toString()),
                txTag: `${section}.${method}`,
            };
        });
    }
    /**
     * Determines whether this Proposal exists on chain
     */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { multiSig }, }, }, multiSig: { address: multiSigAddress }, id, context, } = this;
            const rawId = (0, conversion_1.bigNumberToU64)(id, context);
            const rawMultiSignAddress = (0, conversion_1.stringToAccountId)(multiSigAddress, context);
            const rawProposal = yield multiSig.proposals([rawMultiSignAddress, rawId]);
            return rawProposal.isSome;
        });
    }
    /**
     * Returns a human readable representation
     */
    toHuman() {
        const { multiSig: { address: multiSigAddress }, id, } = this;
        return {
            multiSigAddress,
            id: id.toString(),
        };
    }
}
exports.MultiSigProposal = MultiSigProposal;
//# sourceMappingURL=index.js.map