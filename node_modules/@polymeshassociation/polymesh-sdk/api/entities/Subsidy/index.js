"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subsidy = void 0;
const internal_1 = require("../../../internal");
const types_1 = require("../../../types");
const internal_2 = require("../../../utils/internal");
/**
 * Represents a Subsidy relationship on chain
 */
class Subsidy extends internal_1.Entity {
    /**
     * @hidden
     */
    constructor(identifiers, context) {
        const { beneficiary, subsidizer } = identifiers;
        super(identifiers, context);
        this.beneficiary = new internal_1.Account({ address: beneficiary }, context);
        this.subsidizer = new internal_1.Account({ address: subsidizer }, context);
        this.quit = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: () => [internal_1.quitSubsidy, { subsidy: this }], voidArgs: true }, context);
        this.setAllowance = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [
                internal_1.modifyAllowance,
                Object.assign(Object.assign({}, args), { subsidy: this, operation: types_1.AllowanceOperation.Set }),
            ],
        }, context);
        this.increaseAllowance = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [
                internal_1.modifyAllowance,
                Object.assign(Object.assign({}, args), { subsidy: this, operation: types_1.AllowanceOperation.Increase }),
            ],
        }, context);
        this.decreaseAllowance = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [
                internal_1.modifyAllowance,
                Object.assign(Object.assign({}, args), { subsidy: this, operation: types_1.AllowanceOperation.Decrease }),
            ],
        }, context);
    }
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier) {
        const { beneficiary, subsidizer } = identifier;
        return typeof beneficiary === 'string' && typeof subsidizer === 'string';
    }
    /**
     * Determine whether this Subsidy relationship exists on chain
     */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            const { beneficiary: { address: beneficiaryAddress }, subsidizer, context, } = this;
            const subsidyWithAllowance = yield context.accountSubsidy(beneficiaryAddress);
            return (subsidyWithAllowance !== null && subsidyWithAllowance.subsidy.subsidizer.isEqual(subsidizer));
        });
    }
    /**
     * Get amount of POLYX subsidized for this Subsidy relationship
     *
     * @throws if the Subsidy does not exist
     */
    getAllowance() {
        return __awaiter(this, void 0, void 0, function* () {
            const { beneficiary: { address: beneficiaryAddress }, subsidizer, context, } = this;
            const subsidyWithAllowance = yield context.accountSubsidy(beneficiaryAddress);
            if (!subsidyWithAllowance || !subsidyWithAllowance.subsidy.subsidizer.isEqual(subsidizer)) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: 'The Subsidy no longer exists',
                });
            }
            return subsidyWithAllowance.allowance;
        });
    }
    /**
     * Return the Subsidy's static data
     */
    toHuman() {
        const { beneficiary, subsidizer } = this;
        return (0, internal_2.toHumanReadable)({
            beneficiary,
            subsidizer,
        });
    }
}
exports.Subsidy = Subsidy;
//# sourceMappingURL=index.js.map