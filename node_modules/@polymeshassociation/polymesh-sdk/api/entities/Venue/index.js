"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Venue = exports.createPortfolioTransformer = exports.addInstructionTransformer = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bluebird_1 = __importDefault(require("bluebird"));
const internal_1 = require("../../../internal");
const queries_1 = require("../../../middleware/queries");
const types_1 = require("../../../types");
const conversion_1 = require("../../../utils/conversion");
const internal_2 = require("../../../utils/internal");
/**
 * @hidden
 */
function addInstructionTransformer([instruction]) {
    return instruction;
}
exports.addInstructionTransformer = addInstructionTransformer;
/**
 * @hidden
 */
function createPortfolioTransformer([portfolio]) {
    return portfolio;
}
exports.createPortfolioTransformer = createPortfolioTransformer;
/**
 * Represents a Venue through which settlements are handled
 */
class Venue extends internal_1.Entity {
    /**
     * @hidden
     */
    constructor(identifiers, context) {
        super(identifiers, context);
        const { id } = identifiers;
        this.id = id;
        this.addInstruction = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [internal_1.addInstruction, { instructions: [args], venueId: this.id }],
            transformer: addInstructionTransformer,
        }, context);
        this.addInstructions = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.addInstruction, Object.assign(Object.assign({}, args), { venueId: this.id })] }, context);
        this.modify = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.modifyVenue, Object.assign(Object.assign({}, args), { venue: this })] }, context);
    }
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier) {
        const { id } = identifier;
        return id instanceof bignumber_js_1.default;
    }
    /**
     * Determine whether this Venue exists on chain
     */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { settlement }, }, }, id, context, } = this;
            const venueInfo = yield settlement.venueInfo((0, conversion_1.bigNumberToU64)(id, context));
            return !venueInfo.isNone;
        });
    }
    /**
     * Retrieve information specific to this Venue
     */
    details() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { settlement }, }, }, id, context, } = this;
            const venueId = (0, conversion_1.bigNumberToU64)(id, context);
            const [venueInfo, details] = yield Promise.all([
                settlement.venueInfo(venueId),
                settlement.details(venueId),
            ]);
            const { creator, venueType: type } = venueInfo.unwrap();
            return {
                owner: new internal_1.Identity({ did: (0, conversion_1.identityIdToString)(creator) }, context),
                description: (0, conversion_1.bytesToString)(details),
                type: (0, conversion_1.meshVenueTypeToVenueType)(type),
            };
        });
    }
    /**
     * Retrieve all pending and failed Instructions in this Venue
     */
    getInstructions() {
        return __awaiter(this, void 0, void 0, function* () {
            const instructions = yield this.fetchInstructions();
            const failed = [];
            const pending = [];
            const details = yield bluebird_1.default.map(instructions, instruction => instruction.details());
            details.forEach(({ status }, index) => {
                if (status === types_1.InstructionStatus.Pending) {
                    pending.push(instructions[index]);
                }
                if (status === types_1.InstructionStatus.Failed) {
                    failed.push(instructions[index]);
                }
            });
            return {
                failed,
                pending,
            };
        });
    }
    /**
     * Fetch instructions from the chain
     */
    fetchInstructions() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { settlement }, }, }, id, context, } = this;
            const instructionEntries = yield settlement.venueInstructions.entries((0, conversion_1.bigNumberToU64)(id, context));
            return instructionEntries.map(([{ args: [, instructionId], },]) => new internal_1.Instruction({ id: (0, conversion_1.u64ToBigNumber)(instructionId) }, context));
        });
    }
    /**
     * Retrieve all Instructions that have been associated with this Venue instance
     *
     * @param opts.size - page size
     * @param opts.start - page offset
     *
     * @note uses the middleware V2
     * @note supports pagination
     */
    getHistoricalInstructions(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context, id } = this;
            const { size, start } = opts;
            const { data: { instructions: { nodes: instructionsResult, totalCount }, }, } = yield context.queryMiddleware((0, queries_1.instructionsQuery)({
                venueId: id.toString(),
            }, size, start));
            const data = instructionsResult.map(middlewareInstruction => (0, conversion_1.middlewareInstructionToHistoricInstruction)(middlewareInstruction, context));
            const count = new bignumber_js_1.default(totalCount);
            const next = (0, internal_2.calculateNextKey)(count, data.length, start);
            return {
                data,
                next,
                count,
            };
        });
    }
    /**
     * Return the Venue's ID
     */
    toHuman() {
        return this.id.toString();
    }
}
exports.Venue = Venue;
//# sourceMappingURL=index.js.map