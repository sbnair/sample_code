"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Authorizations = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const internal_1 = require("../../../../internal");
const queries_1 = require("../../../../middleware/queries");
const types_1 = require("../../../../types");
const conversion_1 = require("../../../../utils/conversion");
const internal_2 = require("../../../../utils/internal");
/**
 * Handles all Authorization related functionality
 */
class Authorizations extends internal_1.Namespace {
    /**
     * Fetch all pending Authorization Requests for which this Signer is the target
     *
     * @param opts.type - fetch only authorizations of this type. Fetches all types if not passed
     * @param opts.includeExpired - whether to include expired authorizations. Defaults to true
     */
    getReceived(opts) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { context, parent, context: { polymeshApi: { rpc }, }, } = this;
            const signerValue = (0, conversion_1.signerToSignerValue)(parent);
            const signatory = (0, conversion_1.signerValueToSignatory)(signerValue, context);
            const rawBoolean = (0, conversion_1.booleanToBool)((_a = opts === null || opts === void 0 ? void 0 : opts.includeExpired) !== null && _a !== void 0 ? _a : true, context);
            let result;
            if (opts === null || opts === void 0 ? void 0 : opts.type) {
                result = yield rpc.identity.getFilteredAuthorizations(signatory, rawBoolean, (0, conversion_1.authorizationTypeToMeshAuthorizationType)(opts.type, context));
            }
            else {
                result = yield rpc.identity.getFilteredAuthorizations(signatory, rawBoolean);
            }
            return this.createAuthorizationRequests(result.map(auth => ({ auth, target: signerValue })));
        });
    }
    /**
     * Retrieve a single Authorization Request targeting this Signer by its ID
     *
     * @throws if there is no Authorization Request with the passed ID targeting this Signer
     */
    getOne(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context, parent, context: { polymeshApi: { query }, }, } = this;
            const { id } = args;
            const signerValue = (0, conversion_1.signerToSignerValue)(parent);
            const signatory = (0, conversion_1.signerValueToSignatory)(signerValue, context);
            const rawId = (0, conversion_1.bigNumberToU64)(id, context);
            const auth = yield query.identity.authorizations(signatory, rawId);
            if (auth.isNone) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: 'The Authorization Request does not exist',
                });
            }
            return this.createAuthorizationRequests([{ auth: auth.unwrap(), target: signerValue }])[0];
        });
    }
    /**
     * @hidden
     *
     * Create an array of AuthorizationRequests from an array of on-chain Authorizations
     */
    createAuthorizationRequests(auths) {
        const { context } = this;
        return auths
            .map(auth => {
            const { auth: { expiry, authId, authorizationData: data, authorizedBy: issuer }, target: rawTarget, } = auth;
            const target = (0, conversion_1.signerValueToSigner)(rawTarget, context);
            return {
                authId: (0, conversion_1.u64ToBigNumber)(authId),
                expiry: expiry.isSome ? (0, conversion_1.momentToDate)(expiry.unwrap()) : null,
                data: (0, conversion_1.authorizationDataToAuthorization)(data, context),
                target,
                issuer: new internal_1.Identity({ did: (0, conversion_1.identityIdToString)(issuer) }, context),
            };
        })
            .filter(({ expiry }) => expiry === null || expiry > new Date())
            .map(args => {
            return new internal_1.AuthorizationRequest(args, context);
        });
    }
    /**
     * Fetch all historical Authorization Requests for which this Signer is the target
     *
     * @param opts.type - fetch only authorizations of this type. Fetches all types if not passed
     * @param opts.status - fetch only authorizations with this status. Fetches all statuses if not passed
     * @param opts.size - page size
     * @param opts.start - page offset
     *
     * @note supports pagination
     * @note uses the middlewareV2
     */
    getHistoricalAuthorizations(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context, parent } = this;
            const signerValue = (0, conversion_1.signerToSignerValue)(parent);
            const { status, type, start, size } = opts;
            const filters = { type, status };
            if (signerValue.type === types_1.SignerType.Identity) {
                filters.toId = signerValue.value;
            }
            else {
                filters.toKey = (0, conversion_1.addressToKey)(signerValue.value, context);
            }
            const { data: { authorizations: { totalCount, nodes: authorizationResult }, }, } = yield context.queryMiddleware((0, queries_1.authorizationsQuery)(filters, size, start));
            const data = authorizationResult.map(middlewareAuthorization => {
                const { id, type: authType, data: authData, fromId, toId, toKey, expiry, } = middlewareAuthorization;
                return new internal_1.AuthorizationRequest({
                    authId: new bignumber_js_1.default(id),
                    expiry: expiry ? new Date(expiry) : null,
                    data: (0, conversion_1.middlewareAuthorizationDataToAuthorization)(context, authType, authData),
                    target: toId
                        ? new internal_1.Identity({ did: toId }, context)
                        : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            new internal_1.Account({ address: (0, conversion_1.keyToAddress)(toKey, context) }, context),
                    issuer: new internal_1.Identity({ did: fromId }, context),
                }, context);
            });
            const count = new bignumber_js_1.default(totalCount);
            const next = (0, internal_2.calculateNextKey)(count, data.length, start);
            return {
                data,
                next,
                count,
            };
        });
    }
}
exports.Authorizations = Authorizations;
//# sourceMappingURL=Authorizations.js.map