"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addInstruction = exports.prepareStorage = exports.getAuthorization = exports.prepareAddInstruction = exports.createAddInstructionResolver = void 0;
const bluebird_1 = __importDefault(require("bluebird"));
const lodash_1 = require("lodash");
const utils_1 = require("./utils");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const constants_1 = require("../../utils/constants");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * @hidden
 */
const createAddInstructionResolver = (context) => (receipt) => {
    const events = (0, internal_2.filterEventRecords)(receipt, 'settlement', 'InstructionCreated');
    const result = events.map(({ data }) => new internal_1.Instruction({ id: (0, conversion_1.u64ToBigNumber)(data[2]) }, context));
    return result;
};
exports.createAddInstructionResolver = createAddInstructionResolver;
/**
 * @hidden
 */
function getEndCondition(instruction, latestBlock, index) {
    let endCondition;
    let errorIndex = null;
    if ('endBlock' in instruction && instruction.endBlock) {
        const { endBlock } = instruction;
        if (endBlock.lte(latestBlock)) {
            errorIndex = index;
        }
        endCondition = { type: types_1.InstructionType.SettleOnBlock, endBlock };
    }
    else if ('endAfterBlock' in instruction && instruction.endAfterBlock) {
        const { endAfterBlock } = instruction;
        if (endAfterBlock.lte(latestBlock)) {
            errorIndex = index;
        }
        endCondition = { type: types_1.InstructionType.SettleManual, endAfterBlock };
    }
    else {
        endCondition = { type: types_1.InstructionType.SettleOnAffirmation };
    }
    return {
        endCondition,
        errorIndex,
    };
}
/**
 * @hidden
 */
function getTxArgsAndErrors(instructions, portfoliosToAffirm, latestBlock, venueId, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const addAndAffirmInstructionParams = [];
        const addInstructionParams = [];
        const legEmptyErrIndexes = [];
        const legLengthErrIndexes = [];
        const legAmountErrIndexes = [];
        const endBlockErrIndexes = [];
        const sameIdentityErrIndexes = [];
        /**
         * array of indexes of Instructions where the value date is before the trade date
         */
        const datesErrIndexes = [];
        yield bluebird_1.default.each(instructions, (instruction, i) => __awaiter(this, void 0, void 0, function* () {
            const { legs, tradeDate, valueDate, memo } = instruction;
            if (!legs.length) {
                legEmptyErrIndexes.push(i);
            }
            if (legs.length > constants_1.MAX_LEGS_LENGTH) {
                legLengthErrIndexes.push(i);
            }
            const zeroAmountLegs = legs.filter(leg => leg.amount.isZero());
            if (zeroAmountLegs.length) {
                legAmountErrIndexes.push(i);
            }
            const sameIdentityLegs = legs.filter(({ from, to }) => {
                const fromId = (0, conversion_1.portfolioLikeToPortfolioId)(from);
                const toId = (0, conversion_1.portfolioLikeToPortfolioId)(to);
                return fromId.did === toId.did;
            });
            if (sameIdentityLegs.length) {
                sameIdentityErrIndexes.push(i);
            }
            const { endCondition, errorIndex } = getEndCondition(instruction, latestBlock, i);
            if (errorIndex !== null) {
                endBlockErrIndexes.push(errorIndex);
            }
            if (tradeDate && valueDate && tradeDate > valueDate) {
                datesErrIndexes.push(i);
            }
            if (!legEmptyErrIndexes.length &&
                !legLengthErrIndexes.length &&
                !legAmountErrIndexes.length &&
                !endBlockErrIndexes.length &&
                !datesErrIndexes.length &&
                !sameIdentityErrIndexes.length) {
                const rawVenueId = (0, conversion_1.bigNumberToU64)(venueId, context);
                const rawSettlementType = (0, conversion_1.endConditionToSettlementType)(endCondition, context);
                const rawTradeDate = (0, internal_2.optionize)(conversion_1.dateToMoment)(tradeDate, context);
                const rawValueDate = (0, internal_2.optionize)(conversion_1.dateToMoment)(valueDate, context);
                const rawLegs = [];
                const rawInstructionMemo = (0, internal_2.optionize)(conversion_1.stringToMemo)(memo, context);
                yield Promise.all(legs.map(({ from, to, amount, asset }) => __awaiter(this, void 0, void 0, function* () {
                    const fromId = (0, conversion_1.portfolioLikeToPortfolioId)(from);
                    const toId = (0, conversion_1.portfolioLikeToPortfolioId)(to);
                    yield Promise.all([
                        (0, utils_1.assertPortfolioExists)(fromId, context),
                        (0, utils_1.assertPortfolioExists)(toId, context),
                    ]);
                    const rawFromPortfolio = (0, conversion_1.portfolioIdToMeshPortfolioId)(fromId, context);
                    const rawToPortfolio = (0, conversion_1.portfolioIdToMeshPortfolioId)(toId, context);
                    const rawLeg = (0, conversion_1.legToSettlementLeg)({
                        Fungible: {
                            sender: rawFromPortfolio,
                            receiver: rawToPortfolio,
                            ticker: (0, conversion_1.stringToTicker)((0, internal_2.asTicker)(asset), context),
                            amount: (0, conversion_1.bigNumberToBalance)(amount, context),
                        },
                    }, context);
                    rawLegs.push(rawLeg);
                })));
                if (portfoliosToAffirm[i].length) {
                    addAndAffirmInstructionParams.push([
                        rawVenueId,
                        rawSettlementType,
                        rawTradeDate,
                        rawValueDate,
                        rawLegs,
                        portfoliosToAffirm[i].map(portfolio => (0, conversion_1.portfolioIdToMeshPortfolioId)((0, conversion_1.portfolioLikeToPortfolioId)(portfolio), context)),
                        rawInstructionMemo,
                    ]);
                }
                else {
                    addInstructionParams.push([
                        rawVenueId,
                        rawSettlementType,
                        rawTradeDate,
                        rawValueDate,
                        rawLegs,
                        rawInstructionMemo,
                    ]);
                }
            }
        }));
        return {
            errIndexes: {
                legEmptyErrIndexes,
                legLengthErrIndexes,
                legAmountErrIndexes,
                endBlockErrIndexes,
                datesErrIndexes,
                sameIdentityErrIndexes,
            },
            addAndAffirmInstructionParams,
            addInstructionParams,
        };
    });
}
/**
 * @hidden
 */
function prepareAddInstruction(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx: { settlement }, }, }, context, storage: { portfoliosToAffirm }, } = this;
        const { instructions, venueId } = args;
        const [latestBlock] = yield Promise.all([
            context.getLatestBlock(),
            (0, utils_1.assertVenueExists)(venueId, context),
        ]);
        if (!instructions.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'The Instructions array cannot be empty',
            });
        }
        const { errIndexes: { legEmptyErrIndexes, legLengthErrIndexes, legAmountErrIndexes, endBlockErrIndexes, datesErrIndexes, sameIdentityErrIndexes, }, addAndAffirmInstructionParams, addInstructionParams, } = yield getTxArgsAndErrors(instructions, portfoliosToAffirm, latestBlock, venueId, context);
        if (legEmptyErrIndexes.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: "The legs array can't be empty",
                data: {
                    failedInstructionIndexes: legEmptyErrIndexes,
                },
            });
        }
        if (legAmountErrIndexes.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Instruction legs cannot have zero amount',
                data: {
                    failedInstructionIndexes: legAmountErrIndexes,
                },
            });
        }
        if (legLengthErrIndexes.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.LimitExceeded,
                message: 'The legs array exceeds the maximum allowed length',
                data: {
                    maxLength: constants_1.MAX_LEGS_LENGTH,
                    failedInstructionIndexes: legLengthErrIndexes,
                },
            });
        }
        if (endBlockErrIndexes.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'End block must be a future block',
                data: {
                    failedInstructionIndexes: endBlockErrIndexes,
                },
            });
        }
        if (datesErrIndexes.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Value date must be after trade date',
                data: {
                    failedInstructionIndexes: datesErrIndexes,
                },
            });
        }
        if (sameIdentityErrIndexes.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Instruction leg cannot transfer Assets between same identity',
                data: {
                    failedInstructionIndexes: sameIdentityErrIndexes,
                },
            });
        }
        const transactions = (0, internal_2.assembleBatchTransactions)([
            {
                transaction: settlement.addInstruction,
                argsArray: addInstructionParams,
            },
            {
                transaction: settlement.addAndAffirmInstruction,
                argsArray: addAndAffirmInstructionParams,
            },
        ]);
        return {
            transactions,
            resolver: (0, exports.createAddInstructionResolver)(context),
        };
    });
}
exports.prepareAddInstruction = prepareAddInstruction;
/**
 * @hidden
 */
function getAuthorization({ venueId }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { storage: { portfoliosToAffirm }, } = this;
        let transactions = [];
        let portfolios = [];
        portfoliosToAffirm.forEach(portfoliosList => {
            transactions = (0, lodash_1.union)(transactions, [
                portfoliosList.length
                    ? types_1.TxTags.settlement.AddAndAffirmInstructionWithMemo
                    : types_1.TxTags.settlement.AddInstructionWithMemo,
            ]);
            portfolios = (0, lodash_1.unionWith)(portfolios, portfoliosList, lodash_1.isEqual);
        });
        return {
            roles: [{ type: types_1.RoleType.VenueOwner, venueId }],
            permissions: {
                assets: [],
                portfolios,
                transactions,
            },
        };
    });
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function prepareStorage({ instructions }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context } = this;
        const identity = yield context.getSigningIdentity();
        const portfoliosToAffirm = yield bluebird_1.default.map(instructions, ({ legs }) => __awaiter(this, void 0, void 0, function* () {
            const portfolios = yield bluebird_1.default.map(legs, ({ from, to }) => __awaiter(this, void 0, void 0, function* () {
                const fromPortfolio = (0, conversion_1.portfolioLikeToPortfolio)(from, context);
                const toPortfolio = (0, conversion_1.portfolioLikeToPortfolio)(to, context);
                const result = [];
                const [fromCustodied, toCustodied] = yield Promise.all([
                    fromPortfolio.isCustodiedBy({ identity }),
                    toPortfolio.isCustodiedBy({ identity }),
                ]);
                if (fromCustodied) {
                    result.push(fromPortfolio);
                }
                if (toCustodied) {
                    result.push(toPortfolio);
                }
                return result;
            }));
            return (0, lodash_1.flatten)(portfolios);
        }));
        return {
            portfoliosToAffirm,
        };
    });
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const addInstruction = () => new internal_1.Procedure(prepareAddInstruction, getAuthorization, prepareStorage);
exports.addInstruction = addInstruction;
//# sourceMappingURL=addInstruction.js.map