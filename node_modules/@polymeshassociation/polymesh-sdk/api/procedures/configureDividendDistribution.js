"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.configureDividendDistribution = exports.prepareStorage = exports.getAuthorization = exports.prepareConfigureDividendDistribution = exports.createDividendDistributionResolver = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utils_1 = require("./utils");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * @hidden
 */
const createDividendDistributionResolver = (context) => (receipt) => __awaiter(void 0, void 0, void 0, function* () {
    const [{ data }] = (0, internal_2.filterEventRecords)(receipt, 'capitalDistribution', 'Created');
    const [, caId, distribution] = data;
    const { ticker, localId } = caId;
    const { corporateAction } = context.polymeshApi.query;
    const [corpAction, details] = yield Promise.all([
        corporateAction.corporateActions(ticker, localId),
        corporateAction.details(caId),
    ]);
    return new internal_1.DividendDistribution(Object.assign(Object.assign({ ticker: (0, conversion_1.tickerToString)(ticker), id: (0, conversion_1.u32ToBigNumber)(localId) }, (0, conversion_1.meshCorporateActionToCorporateActionParams)(corpAction.unwrap(), details, context)), (0, conversion_1.distributionToDividendDistributionParams)(distribution, context)), context);
});
exports.createDividendDistributionResolver = createDividendDistributionResolver;
/**
 * @hidden
 */
function prepareConfigureDividendDistribution(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx, query }, }, context, storage: { portfolio }, } = this;
        const { ticker, originPortfolio = null, currency, perShare, maxAmount, paymentDate, expiryDate = null, checkpoint, targets = null, description, declarationDate = new Date(), defaultTaxWithholding = null, taxWithholdings = null, } = args;
        if (currency === ticker) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Cannot distribute Dividends using the Asset as currency',
            });
        }
        if (paymentDate <= new Date()) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Payment date must be in the future',
            });
        }
        if (expiryDate && expiryDate < paymentDate) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Expiry date must be after payment date',
            });
        }
        if (declarationDate > new Date()) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Declaration date must be in the past',
            });
        }
        const rawMaxDetailsLength = yield query.corporateAction.maxDetailsLength();
        const maxDetailsLength = (0, conversion_1.u32ToBigNumber)(rawMaxDetailsLength);
        if (maxDetailsLength.lt(description.length)) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Description too long',
                data: {
                    maxLength: maxDetailsLength.toNumber(),
                },
            });
        }
        const checkpointValue = yield (0, internal_2.getCheckpointValue)(checkpoint, ticker, context);
        if (!(checkpointValue instanceof internal_1.Checkpoint)) {
            yield (0, utils_1.assertDistributionDatesValid)(checkpointValue, paymentDate, expiryDate);
        }
        if (portfolio instanceof internal_1.NumberedPortfolio) {
            const exists = yield portfolio.exists();
            if (!exists) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: "The origin Portfolio doesn't exist",
                });
            }
        }
        const [{ free }] = yield portfolio.getAssetBalances({ assets: [currency] });
        if (free.lt(maxAmount)) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.InsufficientBalance,
                message: "The origin Portfolio's free balance is not enough to cover the Distribution amount",
                data: {
                    free,
                },
            });
        }
        const rawPortfolioNumber = originPortfolio &&
            (0, internal_2.optionize)(conversion_1.bigNumberToU64)(originPortfolio instanceof bignumber_js_1.default ? originPortfolio : originPortfolio.id, context);
        const rawCurrency = (0, conversion_1.stringToTicker)(currency, context);
        const rawPerShare = (0, conversion_1.bigNumberToBalance)(perShare, context);
        const rawAmount = (0, conversion_1.bigNumberToBalance)(maxAmount, context);
        const rawPaymentAt = (0, conversion_1.dateToMoment)(paymentDate, context);
        const rawExpiresAt = (0, internal_2.optionize)(conversion_1.dateToMoment)(expiryDate, context);
        return {
            transaction: tx.corporateAction.initiateCorporateActionAndDistribute,
            resolver: (0, exports.createDividendDistributionResolver)(context),
            args: [
                (0, conversion_1.corporateActionParamsToMeshCorporateActionArgs)({
                    ticker,
                    kind: types_1.CorporateActionKind.UnpredictableBenefit,
                    declarationDate,
                    checkpoint: checkpointValue,
                    description,
                    targets,
                    defaultTaxWithholding,
                    taxWithholdings,
                }, context),
                rawPortfolioNumber,
                rawCurrency,
                rawPerShare,
                rawAmount,
                rawPaymentAt,
                rawExpiresAt,
            ],
        };
    });
}
exports.prepareConfigureDividendDistribution = prepareConfigureDividendDistribution;
/**
 * @hidden
 */
function getAuthorization({ ticker }) {
    const { storage: { portfolio }, context, } = this;
    return {
        roles: [{ type: types_1.RoleType.PortfolioCustodian, portfolioId: (0, conversion_1.portfolioToPortfolioId)(portfolio) }],
        permissions: {
            transactions: [types_1.TxTags.capitalDistribution.Distribute],
            assets: [new internal_1.FungibleAsset({ ticker }, context)],
            portfolios: [portfolio],
        },
    };
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function prepareStorage({ originPortfolio }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context } = this;
        const { did } = yield context.getSigningIdentity();
        let portfolio = originPortfolio || new internal_1.DefaultPortfolio({ did }, context);
        if (portfolio instanceof bignumber_js_1.default) {
            portfolio = new internal_1.NumberedPortfolio({ id: portfolio, did }, context);
        }
        return {
            portfolio,
        };
    });
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const configureDividendDistribution = () => new internal_1.Procedure(prepareConfigureDividendDistribution, getAuthorization, prepareStorage);
exports.configureDividendDistribution = configureDividendDistribution;
//# sourceMappingURL=configureDividendDistribution.js.map