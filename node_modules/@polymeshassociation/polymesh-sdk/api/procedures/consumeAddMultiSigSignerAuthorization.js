"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.consumeAddMultiSigSignerAuthorization = exports.getAuthorization = exports.prepareConsumeAddMultiSigSignerAuthorization = void 0;
const utils_1 = require("./utils");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const conversion_1 = require("../../utils/conversion");
/**
 * @hidden
 */
function prepareConsumeAddMultiSigSignerAuthorization(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx: { identity, multiSig }, }, }, context, } = this;
        const { authRequest, accept } = args;
        const { target, authId, issuer } = authRequest;
        const rawAuthId = (0, conversion_1.bigNumberToU64)(authId, context);
        if (!accept) {
            const { address } = context.getSigningAccount();
            const paidByThirdParty = address === (0, conversion_1.signerToString)(target);
            const addTransactionArgs = {};
            if (paidByThirdParty) {
                addTransactionArgs.paidForBy = issuer;
            }
            return Object.assign(Object.assign({ transaction: identity.removeAuthorization }, addTransactionArgs), { args: [
                    (0, conversion_1.signerValueToSignatory)((0, conversion_1.signerToSignerValue)(target), context),
                    rawAuthId,
                    (0, conversion_1.booleanToBool)(paidByThirdParty, context),
                ], resolver: undefined });
        }
        yield (0, utils_1.assertAuthorizationRequestValid)(authRequest, context);
        const transaction = target instanceof internal_1.Account
            ? multiSig.acceptMultisigSignerAsKey
            : multiSig.acceptMultisigSignerAsIdentity;
        return { transaction, paidForBy: issuer, args: [rawAuthId], resolver: undefined };
    });
}
exports.prepareConsumeAddMultiSigSignerAuthorization = prepareConsumeAddMultiSigSignerAuthorization;
/**
 * @hidden
 */
function getAuthorization({ authRequest, accept }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { target, issuer } = authRequest;
        const { context } = this;
        let hasRoles;
        const signingAccount = context.getSigningAccount();
        const identity = yield signingAccount.getIdentity();
        let calledByTarget;
        let permissions;
        if (target instanceof internal_1.Account) {
            calledByTarget = target.isEqual(signingAccount);
            hasRoles = calledByTarget;
            // An account accepting multisig cannot be part of an Identity, so we cannot check for permissions
        }
        else {
            calledByTarget = !!(identity === null || identity === void 0 ? void 0 : identity.isEqual(target));
            hasRoles = calledByTarget;
            permissions = { transactions: [types_1.TxTags.multiSig.AcceptMultisigSignerAsIdentity] };
        }
        if (accept) {
            return {
                roles: hasRoles ||
                    '"AddMultiSigSigner" Authorization Requests can only be accepted by the target Signer',
                permissions,
            };
        }
        const transactions = [types_1.TxTags.identity.RemoveAuthorization];
        /*
         * if the target is removing the auth request and they don't have an Identity,
         *   no permissions are required
         */
        if (calledByTarget && !identity) {
            return {
                roles: true,
            };
        }
        // both the issuer and the target can remove the authorization request
        hasRoles = hasRoles || !!(identity === null || identity === void 0 ? void 0 : identity.isEqual(issuer));
        return {
            roles: hasRoles ||
                '"AddMultiSigSigner" Authorization Request can only be removed by the issuing Identity or the target Signer',
            permissions: { transactions },
        };
    });
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
const consumeAddMultiSigSignerAuthorization = () => new internal_1.Procedure(prepareConsumeAddMultiSigSignerAuthorization, getAuthorization);
exports.consumeAddMultiSigSignerAuthorization = consumeAddMultiSigSignerAuthorization;
//# sourceMappingURL=consumeAddMultiSigSignerAuthorization.js.map