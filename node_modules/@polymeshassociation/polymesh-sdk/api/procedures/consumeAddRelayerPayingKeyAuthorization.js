"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.consumeAddRelayerPayingKeyAuthorization = exports.prepareStorage = exports.getAuthorization = exports.prepareConsumeAddRelayerPayingKeyAuthorization = void 0;
const utils_1 = require("./utils");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const conversion_1 = require("../../utils/conversion");
/**
 * @hidden
 *
 * Consumes AddRelayerPayingKey Authorizations
 */
function prepareConsumeAddRelayerPayingKeyAuthorization(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx: { relayer, identity }, }, }, storage: { calledByTarget }, context, } = this;
        const { authRequest, accept } = args;
        const { target, authId, issuer, data: { type }, } = authRequest;
        if (type !== types_1.AuthorizationType.AddRelayerPayingKey) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.UnexpectedError,
                message: `Unrecognized auth type: "${type}" for consumeAddRelayerPayingKeyAuthorization method`,
            });
        }
        const rawAuthId = (0, conversion_1.bigNumberToU64)(authId, context);
        if (!accept) {
            const baseArgs = {};
            if (calledByTarget) {
                baseArgs.paidForBy = issuer;
            }
            return Object.assign(Object.assign({ transaction: identity.removeAuthorization }, baseArgs), { args: [
                    (0, conversion_1.signerValueToSignatory)((0, conversion_1.signerToSignerValue)(target), context),
                    rawAuthId,
                    (0, conversion_1.booleanToBool)(calledByTarget, context),
                ], resolver: undefined });
        }
        yield (0, utils_1.assertAuthorizationRequestValid)(authRequest, context);
        return {
            transaction: relayer.acceptPayingKey,
            paidForBy: issuer,
            args: [rawAuthId],
            resolver: undefined,
        };
    });
}
exports.prepareConsumeAddRelayerPayingKeyAuthorization = prepareConsumeAddRelayerPayingKeyAuthorization;
/**
 * @hidden
 *
 * - If the auth is being accepted, we check that the caller is the target
 * - If the auth is being rejected, we check that the caller is either the target or the issuer
 */
function getAuthorization({ authRequest, accept }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { issuer } = authRequest;
        const { storage: { signingAccount, calledByTarget }, } = this;
        let hasRoles = calledByTarget;
        if (accept) {
            return {
                roles: hasRoles ||
                    `"${types_1.AuthorizationType.AddRelayerPayingKey}" Authorization Requests must be accepted by the target Account`,
            };
        }
        const identity = yield signingAccount.getIdentity();
        hasRoles = hasRoles || !!(identity === null || identity === void 0 ? void 0 : identity.isEqual(issuer));
        return {
            roles: hasRoles ||
                `"${types_1.AuthorizationType.AddRelayerPayingKey}" Authorization Requests can only be removed by the issuer Identity or the target Account`,
            permissions: {
                transactions: [types_1.TxTags.identity.RemoveAuthorization],
            },
        };
    });
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function prepareStorage({ authRequest: { target } }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context } = this;
        // AddRelayerPayingKey Authorizations always target an Account
        const targetAccount = target;
        const signingAccount = context.getSigningAccount();
        const calledByTarget = targetAccount.isEqual(signingAccount);
        return {
            signingAccount,
            calledByTarget,
        };
    });
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const consumeAddRelayerPayingKeyAuthorization = () => new internal_1.Procedure(prepareConsumeAddRelayerPayingKeyAuthorization, getAuthorization, prepareStorage);
exports.consumeAddRelayerPayingKeyAuthorization = consumeAddRelayerPayingKeyAuthorization;
//# sourceMappingURL=consumeAddRelayerPayingKeyAuthorization.js.map