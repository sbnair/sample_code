"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAsset = exports.prepareStorage = exports.getAuthorization = exports.prepareCreateAsset = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const lodash_1 = require("lodash");
const utils_1 = require("./utils");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * @throws if the Ticker is not available
 */
function assertTickerAvailable(ticker, status, reservationRequired) {
    if (status === types_1.TickerReservationStatus.AssetCreated) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.UnmetPrerequisite,
            message: `An Asset with ticker "${ticker}" already exists`,
        });
    }
    if (status === types_1.TickerReservationStatus.Free && reservationRequired) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.UnmetPrerequisite,
            message: `You must first reserve ticker "${ticker}" in order to create an Asset with it`,
        });
    }
    if (!(0, internal_2.isAlphanumeric)(ticker)) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: 'New Tickers can only contain alphanumeric values',
        });
    }
}
/**
 * @hidden
 */
function prepareCreateAsset(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx }, }, context, storage: { customTypeData, status, signingIdentity }, } = this;
        const { ticker, name, initialSupply, portfolioId, isDivisible, assetType, securityIdentifiers = [], fundingRound, documents, reservationRequired, initialStatistics, } = args;
        assertTickerAvailable(ticker, status, reservationRequired);
        const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
        const rawName = (0, conversion_1.nameToAssetName)(name, context);
        const rawIsDivisible = (0, conversion_1.booleanToBool)(isDivisible, context);
        const rawIdentifiers = securityIdentifiers.map(identifier => (0, conversion_1.securityIdentifierToAssetIdentifier)(identifier, context));
        const rawFundingRound = (0, internal_2.optionize)(conversion_1.fundingRoundToAssetFundingRound)(fundingRound, context);
        const newAsset = new internal_1.FungibleAsset({ ticker }, context);
        const transactions = [];
        let fee;
        if (status === types_1.TickerReservationStatus.Free) {
            fee = yield (0, utils_1.addManualFees)(new bignumber_js_1.default(0), [types_1.TxTags.asset.RegisterTicker, types_1.TxTags.asset.CreateAsset], context);
        }
        /*
         * - if the passed Asset type isn't one of the fixed ones (custom), we check if there is already
         *   an on-chain custom Asset type with that name:
         *   - if not, we create it together with the Asset
         *   - otherwise, we create the asset with the id of the existing custom asset type
         * - if the passed Asset type is a fixed one, we create the asset using that Asset type
         */
        if (customTypeData) {
            const { rawValue, id } = customTypeData;
            /*
             * We add the fee for registering a custom asset type in case we're calculating
             * the Asset creation fees manually
             */
            fee = yield (0, utils_1.addManualFees)(fee, [types_1.TxTags.asset.RegisterCustomAssetType], context);
            if (id.isEmpty) {
                transactions.push((0, internal_2.checkTxType)({
                    transaction: tx.asset.createAssetWithCustomType,
                    fee,
                    args: [rawName, rawTicker, rawIsDivisible, rawValue, rawIdentifiers, rawFundingRound],
                }));
            }
            else {
                const rawType = (0, conversion_1.internalAssetTypeToAssetType)({ Custom: id }, context);
                transactions.push((0, internal_2.checkTxType)({
                    transaction: tx.asset.createAsset,
                    fee,
                    args: [rawName, rawTicker, rawIsDivisible, rawType, rawIdentifiers, rawFundingRound],
                }));
            }
        }
        else {
            const rawType = (0, conversion_1.internalAssetTypeToAssetType)(assetType, context);
            transactions.push((0, internal_2.checkTxType)({
                transaction: tx.asset.createAsset,
                fee,
                args: [rawName, rawTicker, rawIsDivisible, rawType, rawIdentifiers, rawFundingRound],
            }));
        }
        if (initialStatistics === null || initialStatistics === void 0 ? void 0 : initialStatistics.length) {
            const tickerKey = (0, conversion_1.stringToTickerKey)(ticker, context);
            const rawStats = initialStatistics.map(i => (0, conversion_1.inputStatTypeToMeshStatType)(i, context));
            const bTreeStats = (0, conversion_1.statisticStatTypesToBtreeStatType)(rawStats, context);
            transactions.push((0, internal_2.checkTxType)({
                transaction: tx.statistics.setActiveAssetStats,
                args: [tickerKey, bTreeStats],
            }));
        }
        if (initialSupply === null || initialSupply === void 0 ? void 0 : initialSupply.gt(0)) {
            const rawInitialSupply = (0, conversion_1.bigNumberToBalance)(initialSupply, context, isDivisible);
            const portfolio = portfolioId
                ? yield signingIdentity.portfolios.getPortfolio({ portfolioId })
                : yield signingIdentity.portfolios.getPortfolio();
            const rawPortfolio = (0, conversion_1.portfolioToPortfolioKind)(portfolio, context);
            transactions.push((0, internal_2.checkTxType)({
                transaction: tx.asset.issue,
                args: [rawTicker, rawInitialSupply, rawPortfolio],
            }));
        }
        if (documents === null || documents === void 0 ? void 0 : documents.length) {
            const rawDocuments = documents.map(doc => (0, conversion_1.assetDocumentToDocument)(doc, context));
            const feeMultiplier = new bignumber_js_1.default(rawDocuments.length);
            transactions.push((0, internal_2.checkTxType)({
                transaction: tx.asset.addDocuments,
                feeMultiplier,
                args: [rawDocuments, rawTicker],
            }));
        }
        return {
            transactions,
            resolver: newAsset,
        };
    });
}
exports.prepareCreateAsset = prepareCreateAsset;
/**
 * @hidden
 */
function getAuthorization({ ticker, documents, initialStatistics }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { storage: { customTypeData, status }, } = this;
        const transactions = [types_1.TxTags.asset.CreateAsset];
        if (documents === null || documents === void 0 ? void 0 : documents.length) {
            transactions.push(types_1.TxTags.asset.AddDocuments);
        }
        if (customTypeData === null || customTypeData === void 0 ? void 0 : customTypeData.id.isEmpty) {
            transactions.push(types_1.TxTags.asset.RegisterCustomAssetType);
        }
        if (initialStatistics === null || initialStatistics === void 0 ? void 0 : initialStatistics.length) {
            transactions.push(types_1.TxTags.statistics.SetActiveAssetStats);
        }
        const auth = {
            permissions: {
                transactions,
                assets: [],
                portfolios: [],
            },
        };
        if (status !== types_1.TickerReservationStatus.Free) {
            return Object.assign(Object.assign({}, auth), { roles: [{ type: types_1.RoleType.TickerOwner, ticker }] });
        }
        return auth;
    });
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function prepareStorage({ ticker, assetType }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context } = this;
        const reservation = new internal_1.TickerReservation({ ticker }, context);
        const [{ status }, signingIdentity] = yield Promise.all([
            reservation.details(),
            context.getSigningIdentity(),
        ]);
        const isCustomType = !(0, lodash_1.values)(types_1.KnownAssetType).includes(assetType);
        if (isCustomType) {
            const rawValue = (0, conversion_1.stringToBytes)(assetType, context);
            const rawId = yield context.polymeshApi.query.asset.customTypesInverse(rawValue);
            const id = rawId.unwrapOrDefault();
            return {
                customTypeData: {
                    id,
                    rawValue,
                },
                status,
                signingIdentity,
            };
        }
        return {
            customTypeData: null,
            status,
            signingIdentity,
        };
    });
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const createAsset = () => new internal_1.Procedure(prepareCreateAsset, getAuthorization, prepareStorage);
exports.createAsset = createAsset;
//# sourceMappingURL=createAsset.js.map