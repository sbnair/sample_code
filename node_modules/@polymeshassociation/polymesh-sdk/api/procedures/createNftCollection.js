"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNftCollection = exports.prepareStorage = exports.getAuthorization = exports.prepareCreateNftCollection = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const lodash_1 = require("lodash");
const utils_1 = require("./utils");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * @hidden
 */
function assertTickerOk(ticker) {
    if (!(0, internal_2.isAlphanumeric)(ticker)) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: 'New Tickers can only contain alphanumeric values',
        });
    }
}
/**
 * @hidden
 */
function isLocalMetadata(value) {
    return value.type === types_1.MetadataType.Local;
}
/**
 * @hidden
 */
function isGlobalMetadata(value) {
    return value.type === types_1.MetadataType.Global;
}
/**
 * @hidden
 */
function prepareCreateNftCollection(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx }, }, context, storage: { customTypeData, status }, } = this;
        const { ticker, nftType, name, securityIdentifiers = [], collectionKeys, documents } = args;
        const internalNftType = customTypeData
            ? { Custom: customTypeData.rawId }
            : nftType;
        const transactions = [];
        assertTickerOk(ticker);
        const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
        const rawName = (0, conversion_1.nameToAssetName)(name !== null && name !== void 0 ? name : ticker, context);
        const rawType = (0, conversion_1.internalNftTypeToNftType)(internalNftType, context);
        const rawDivisibility = (0, conversion_1.booleanToBool)(false, context);
        const rawIdentifiers = securityIdentifiers.map(identifier => (0, conversion_1.securityIdentifierToAssetIdentifier)(identifier, context));
        const rawFundingRound = null;
        let nextLocalId = new bignumber_js_1.default(1);
        let fee;
        if (status === types_1.TickerReservationStatus.Free) {
            const rawAssetType = (0, conversion_1.internalAssetTypeToAssetType)({ NonFungible: internalNftType }, context);
            fee = yield (0, utils_1.addManualFees)(new bignumber_js_1.default(0), [types_1.TxTags.asset.RegisterTicker, types_1.TxTags.asset.CreateAsset, types_1.TxTags.nft.CreateNftCollection], context);
            transactions.push((0, internal_2.checkTxType)({
                transaction: tx.asset.createAsset,
                args: [rawName, rawTicker, rawDivisibility, rawAssetType, rawIdentifiers, rawFundingRound],
            }));
        }
        else if (status === types_1.TickerReservationStatus.Reserved) {
            const rawAssetType = (0, conversion_1.internalAssetTypeToAssetType)({ NonFungible: internalNftType }, context);
            fee = yield (0, utils_1.addManualFees)(new bignumber_js_1.default(0), [types_1.TxTags.asset.CreateAsset, types_1.TxTags.nft.CreateNftCollection], context);
            transactions.push((0, internal_2.checkTxType)({
                transaction: tx.asset.createAsset,
                args: [rawName, rawTicker, rawDivisibility, rawAssetType, rawIdentifiers, rawFundingRound],
            }));
        }
        else if (status === types_1.TickerReservationStatus.AssetCreated) {
            /**
             * assets can be created with type Nft, but not have a created collection,
             * we handle this case to prevent a ticker getting stuck if it was initialized via non SDK methods
             */
            const asset = new internal_1.FungibleAsset({ ticker }, context);
            let nonFungible;
            [fee, { nonFungible }, nextLocalId] = yield Promise.all([
                (0, utils_1.addManualFees)(new bignumber_js_1.default(0), [types_1.TxTags.nft.CreateNftCollection], context),
                asset.details(),
                asset.metadata.getNextLocalId(),
            ]);
            if (!nonFungible) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.UnmetPrerequisite,
                    message: 'Only assets with type NFT can be turned into NFT collections',
                });
            }
        }
        const globalMetadataKeys = collectionKeys.filter(isGlobalMetadata);
        const localMetadataKeys = collectionKeys.filter(isLocalMetadata);
        localMetadataKeys.forEach(localKey => {
            const { name: metaName, spec } = localKey;
            const rawMetadataName = (0, conversion_1.stringToBytes)(metaName, context);
            const rawSpec = (0, conversion_1.metadataSpecToMeshMetadataSpec)(spec, context);
            transactions.push((0, internal_2.checkTxType)({
                transaction: tx.asset.registerAssetMetadataLocalType,
                args: [rawTicker, rawMetadataName, rawSpec],
            }));
        });
        const keyValues = [
            ...globalMetadataKeys,
            ...localMetadataKeys.map((key, index) => {
                return {
                    type: types_1.MetadataType.Local,
                    id: nextLocalId.plus(index),
                };
            }),
        ];
        const rawCollectionKeys = (0, conversion_1.collectionKeysToMetadataKeys)(keyValues, context);
        if (documents === null || documents === void 0 ? void 0 : documents.length) {
            const rawDocuments = documents.map(doc => (0, conversion_1.assetDocumentToDocument)(doc, context));
            const feeMultiplier = new bignumber_js_1.default(rawDocuments.length);
            transactions.push((0, internal_2.checkTxType)({
                transaction: tx.asset.addDocuments,
                feeMultiplier,
                args: [rawDocuments, rawTicker],
            }));
        }
        transactions.push((0, internal_2.checkTxType)({
            transaction: tx.nft.createNftCollection,
            fee,
            args: [rawTicker, rawType, rawCollectionKeys],
        }));
        return {
            transactions,
            resolver: new internal_1.NftCollection({ ticker }, context),
        };
    });
}
exports.prepareCreateNftCollection = prepareCreateNftCollection;
/**
 * @hidden
 */
function getAuthorization({ ticker, documents }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { storage: { status, needsLocalMetadata }, context, } = this;
        const transactions = [types_1.TxTags.nft.CreateNftCollection];
        if (status !== types_1.TickerReservationStatus.AssetCreated) {
            transactions.push(types_1.TxTags.asset.CreateAsset);
        }
        if (needsLocalMetadata) {
            transactions.push(types_1.TxTags.asset.RegisterAssetMetadataLocalType);
        }
        if (documents === null || documents === void 0 ? void 0 : documents.length) {
            transactions.push(types_1.TxTags.asset.AddDocuments);
        }
        const permissions = {
            transactions,
            assets: [],
            portfolios: [],
        };
        if (status === types_1.TickerReservationStatus.Reserved) {
            return {
                permissions,
                roles: [{ type: types_1.RoleType.TickerOwner, ticker }],
            };
        }
        else if (status === types_1.TickerReservationStatus.AssetCreated) {
            return {
                permissions: Object.assign(Object.assign({}, permissions), { assets: [new internal_1.FungibleAsset({ ticker }, context)] }),
            };
        }
        return { permissions };
    });
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function prepareStorage({ ticker, nftType, collectionKeys }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context } = this;
        const needsLocalMetadata = collectionKeys.some(isLocalMetadata);
        const reservation = new internal_1.TickerReservation({ ticker }, context);
        const nft = new internal_1.NftCollection({ ticker }, context);
        const [{ status }, signingIdentity, collectionExists] = yield Promise.all([
            reservation.details(),
            context.getSigningIdentity(),
            nft.exists(),
        ]);
        if (collectionExists) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.UnmetPrerequisite,
                message: 'An NFT collection already exists with the ticker',
                data: { ticker },
            });
        }
        let customTypeData;
        if (nftType instanceof bignumber_js_1.default) {
            const rawId = (0, conversion_1.bigNumberToU32)(nftType, context);
            const rawValue = yield context.polymeshApi.query.asset.customTypes(rawId);
            if (rawValue.isEmpty) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: 'createNftCollection was given a custom type ID that does not have an corresponding value',
                    data: { nftType },
                });
            }
            customTypeData = {
                rawId,
                rawValue,
            };
        }
        else if (!(0, lodash_1.values)(types_1.KnownNftType).includes(nftType)) {
            const rawValue = (0, conversion_1.stringToBytes)(nftType, context);
            const rawId = yield context.polymeshApi.query.asset.customTypesInverse(rawValue);
            if (rawId.isNone) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: 'createNftCollection procedure was given a custom type string that does not have a corresponding ID. Register the type and try again',
                    data: { nftType },
                });
            }
            customTypeData = {
                rawId: rawId.unwrap(),
                rawValue,
            };
        }
        else {
            customTypeData = null;
        }
        return {
            customTypeData,
            status,
            signingIdentity,
            needsLocalMetadata,
        };
    });
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const createNftCollection = () => new internal_1.Procedure(prepareCreateNftCollection, getAuthorization, prepareStorage);
exports.createNftCollection = createNftCollection;
//# sourceMappingURL=createNftCollection.js.map