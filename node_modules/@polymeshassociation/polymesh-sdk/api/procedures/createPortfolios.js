"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPortfolios = exports.prepareCreatePortfolios = exports.createPortfoliosResolver = void 0;
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * @hidden
 */
const createPortfoliosResolver = (context) => (receipt) => {
    const records = (0, internal_2.filterEventRecords)(receipt, 'portfolio', 'PortfolioCreated');
    return records.map(({ data }) => {
        const did = (0, conversion_1.identityIdToString)(data[0]);
        const id = (0, conversion_1.u64ToBigNumber)(data[1]);
        return new internal_1.NumberedPortfolio({ did, id }, context);
    });
};
exports.createPortfoliosResolver = createPortfoliosResolver;
/**
 * @hidden
 */
function prepareCreatePortfolios(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx }, }, context, } = this;
        const { names: portfolioNames } = args;
        const { did } = yield context.getSigningIdentity();
        const rawIdentityId = (0, conversion_1.stringToIdentityId)(did, context);
        const rawNames = portfolioNames.map(name => (0, conversion_1.stringToBytes)(name, context));
        const portfolioIds = yield (0, internal_2.getPortfolioIdsByName)(rawIdentityId, rawNames, context);
        const existingNames = [];
        portfolioIds.forEach((id, index) => {
            if (id) {
                existingNames.push(portfolioNames[index]);
            }
        });
        if (existingNames.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.UnmetPrerequisite,
                message: 'There already exist Portfolios with some of the given names',
                data: {
                    existingNames,
                },
            });
        }
        const transaction = tx.portfolio.createPortfolio;
        return {
            transactions: rawNames.map(name => ({
                transaction,
                args: [name],
            })),
            resolver: (0, exports.createPortfoliosResolver)(context),
        };
    });
}
exports.prepareCreatePortfolios = prepareCreatePortfolios;
/**
 * @hidden
 */
const createPortfolios = () => new internal_1.Procedure(prepareCreatePortfolios, {
    permissions: {
        transactions: [types_1.TxTags.portfolio.CreatePortfolio],
        assets: [],
        portfolios: [],
    },
});
exports.createPortfolios = createPortfolios;
//# sourceMappingURL=createPortfolios.js.map