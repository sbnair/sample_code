"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTransactionBatch = exports.prepareStorage = exports.getAuthorization = exports.prepareCreateTransactionBatch = void 0;
const lodash_1 = require("lodash");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const internal_2 = require("../../types/internal");
const utils_1 = require("../../utils");
const conversion_1 = require("../../utils/conversion");
const internal_3 = require("../../utils/internal");
/**
 * @hidden
 */
function prepareCreateTransactionBatch() {
    return __awaiter(this, void 0, void 0, function* () {
        const { processedTransactions: transactions, resolvers } = this.storage;
        return {
            transactions,
            resolver: receipt => Promise.all(resolvers.map(resolver => resolver(receipt))),
        };
    });
}
exports.prepareCreateTransactionBatch = prepareCreateTransactionBatch;
/**
 * @hidden
 */
function getAuthorization() {
    const { storage: { tags }, } = this;
    return {
        permissions: {
            transactions: [...tags, types_1.TxTags.utility.BatchAll],
        },
    };
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function prepareStorage(args) {
    const { transactions: inputTransactions } = args;
    const resolvers = [];
    const transactions = [];
    const tags = [];
    /*
     * We extract each transaction spec and build an array of all transactions (with args and fees), resolvers and transformers,
     *   to create a new batch spec that contains everything. We use the resolvers and transformers to
     *   create one big resolver that returns an array of the transformed results of each transaction
     *
     * We also get the tags of all transactions to check for permissions. This is necessary even though permissions were checked when
     *   building the individual transactions, since some transactions can be run individually without having an Identity, but these special rules are ignored
     *   when running them as part of a batch
     */
    inputTransactions.forEach(transaction => {
        let spec;
        const startIndex = transactions.length;
        if ((0, utils_1.isPolymeshTransaction)(transaction)) {
            spec = internal_1.PolymeshTransaction.toTransactionSpec(transaction);
            const { transaction: tx, args: txArgs, fee, feeMultiplier } = spec;
            transactions.push({
                transaction: tx,
                args: txArgs,
                fee,
                feeMultiplier,
            });
            tags.push((0, conversion_1.transactionToTxTag)(tx));
        }
        else {
            spec = internal_1.PolymeshTransactionBatch.toTransactionSpec(transaction);
            const { transactions: batchTransactions } = spec;
            batchTransactions.forEach(({ transaction: tx, args: txArgs, fee, feeMultiplier }) => {
                transactions.push({
                    transaction: tx,
                    args: txArgs,
                    fee,
                    feeMultiplier,
                });
                tags.push((0, conversion_1.transactionToTxTag)(tx));
            });
        }
        const { transformer = lodash_1.identity, resolver } = spec;
        const endIndex = transactions.length;
        /*
         * We pass the subset of events to the resolver that only correspond to the
         * transactions added in this iteration, and pass the result through the transformer, if any
         */
        resolvers.push((receipt) => __awaiter(this, void 0, void 0, function* () {
            let value;
            if ((0, internal_2.isResolverFunction)(resolver)) {
                value = resolver((0, internal_3.sliceBatchReceipt)(receipt, startIndex, endIndex));
            }
            else {
                value = resolver;
            }
            return transformer(value);
        }));
    });
    return {
        processedTransactions: transactions,
        resolvers,
        tags,
    };
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const createTransactionBatch = () => new internal_1.Procedure(prepareCreateTransactionBatch, getAuthorization, prepareStorage);
exports.createTransactionBatch = createTransactionBatch;
//# sourceMappingURL=createTransactionBatch.js.map