"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeManualInstruction = exports.prepareStorage = exports.getAuthorization = exports.prepareExecuteManualInstruction = void 0;
const bluebird_1 = __importDefault(require("bluebird"));
const utils_1 = require("./utils");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const conversion_1 = require("../../utils/conversion");
/**
 * @hidden
 */
function prepareExecuteManualInstruction(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx: { settlement: settlementTx }, query: { settlement }, rpc, }, }, context, storage: { portfolios, instructionDetails, signerDid }, } = this;
        const { id, skipAffirmationCheck } = args;
        const instruction = new internal_1.Instruction({ id }, context);
        yield (0, utils_1.assertInstructionValidForManualExecution)(instructionDetails, context);
        if (!portfolios.length) {
            const { owner: { did: venueOwner }, } = yield instructionDetails.venue.details();
            if (venueOwner !== signerDid) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.UnmetPrerequisite,
                    message: 'The signing identity is not involved in this Instruction',
                });
            }
        }
        const rawInstructionId = (0, conversion_1.bigNumberToU64)(id, context);
        const rawPortfolioIds = portfolios.map(portfolio => (0, conversion_1.portfolioIdToMeshPortfolioId)((0, conversion_1.portfolioLikeToPortfolioId)(portfolio), context));
        if (!skipAffirmationCheck) {
            const pendingAffirmationsCount = yield settlement.instructionAffirmsPending(rawInstructionId);
            if (!(0, conversion_1.u64ToBigNumber)(pendingAffirmationsCount).isZero()) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.UnmetPrerequisite,
                    message: 'Instruction needs to be affirmed by all parties before it can be executed',
                    data: {
                        pendingAffirmationsCount,
                    },
                });
            }
        }
        const { fungibleTokens, nonFungibleTokens, offChainAssets, consumedWeight } = yield rpc.settlement.getExecuteInstructionInfo(rawInstructionId);
        return {
            transaction: settlementTx.executeManualInstruction,
            resolver: instruction,
            args: [
                rawInstructionId,
                rawPortfolioIds.length ? rawPortfolioIds[0] : null,
                fungibleTokens,
                nonFungibleTokens,
                offChainAssets,
                consumedWeight,
            ],
        };
    });
}
exports.prepareExecuteManualInstruction = prepareExecuteManualInstruction;
/**
 * @hidden
 */
function getAuthorization() {
    return __awaiter(this, void 0, void 0, function* () {
        const { storage: { portfolios }, } = this;
        return {
            permissions: {
                portfolios,
                transactions: [types_1.TxTags.settlement.ExecuteManualInstruction],
                assets: [],
            },
        };
    });
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function prepareStorage({ id }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context } = this;
        const instruction = new internal_1.Instruction({ id }, context);
        const [{ data: legs }, { did }, details] = yield Promise.all([
            instruction.getLegs(),
            context.getSigningIdentity(),
            instruction.details(),
        ]);
        const portfolios = yield bluebird_1.default.reduce(legs, (custodiedPortfolios, { from, to }) => __awaiter(this, void 0, void 0, function* () {
            const [fromIsCustodied, toIsCustodied] = yield Promise.all([
                from.isCustodiedBy({ identity: did }),
                to.isCustodiedBy({ identity: did }),
            ]);
            const result = [...custodiedPortfolios];
            if (fromIsCustodied) {
                result.push(from);
            }
            if (toIsCustodied) {
                result.push(to);
            }
            return result;
        }), []);
        return {
            portfolios,
            instructionDetails: details,
            signerDid: did,
        };
    });
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const executeManualInstruction = () => new internal_1.Procedure(prepareExecuteManualInstruction, getAuthorization, prepareStorage);
exports.executeManualInstruction = executeManualInstruction;
//# sourceMappingURL=executeManualInstruction.js.map