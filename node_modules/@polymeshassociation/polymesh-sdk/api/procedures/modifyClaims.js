"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.modifyClaims = exports.getAuthorization = exports.prepareModifyClaims = void 0;
const lodash_1 = require("lodash");
const internal_1 = require("../../internal");
const queries_1 = require("../../middleware/queries");
const types_1 = require("../../types");
const utils_1 = require("../../types/utils");
const constants_1 = require("../../utils/constants");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
const typeguards_1 = require("../../utils/typeguards");
const areSameClaims = (claim, { scope, type }) => {
    let isSameScope = true;
    if ((0, typeguards_1.isScopedClaim)(claim)) {
        isSameScope = scope ? (0, lodash_1.isEqual)((0, conversion_1.middlewareScopeToScope)(scope), claim.scope) : false;
    }
    // filter out deprecated claim types
    if (type === types_1.ClaimTypeEnum.NoData ||
        type === types_1.ClaimTypeEnum.NoType ||
        type === types_1.ClaimTypeEnum.InvestorUniqueness ||
        type === types_1.ClaimTypeEnum.InvestorUniquenessV2) {
        return false;
    }
    return isSameScope && types_1.ClaimType[type] === claim.type;
};
const findClaimsByOtherIssuers = (claims, claimsByDid) => claims.reduce((prev, { target, claim }) => {
    var _a;
    const targetClaims = (_a = claimsByDid[(0, conversion_1.signerToString)(target)]) !== null && _a !== void 0 ? _a : [];
    const claimExists = !!targetClaims.find(targetClaim => areSameClaims(claim, targetClaim));
    if (!claimExists) {
        return [...prev, claim];
    }
    return [...prev];
}, []);
/**
 * @hidden
 *
 * Return all new CDD claims for Identities that have an existing CDD claim with a different ID
 */
const findInvalidCddClaims = (claims, context) => __awaiter(void 0, void 0, void 0, function* () {
    const invalidCddClaims = [];
    const newCddClaims = claims.filter(({ claim: { type } }) => type === types_1.ClaimType.CustomerDueDiligence);
    if (newCddClaims.length) {
        const issuedCddClaims = yield context.issuedClaims({
            targets: newCddClaims.map(({ target }) => target),
            claimTypes: [types_1.ClaimType.CustomerDueDiligence],
            includeExpired: false,
        });
        newCddClaims.forEach(({ target, claim }) => {
            const targetIdentity = (0, internal_2.asIdentity)(target, context);
            const issuedClaimsForTarget = issuedCddClaims.data.filter(({ target: issuedTarget }) => targetIdentity.isEqual(issuedTarget));
            if (issuedClaimsForTarget.length) {
                // we know both claims are CDD claims
                const { id: currentCddId } = issuedClaimsForTarget[0].claim;
                const { id: newCddId } = claim;
                if (newCddId !== currentCddId && ![currentCddId, newCddId].includes(constants_1.DEFAULT_CDD_ID)) {
                    invalidCddClaims.push({
                        target: targetIdentity,
                        currentCddId,
                        newCddId,
                    });
                }
            }
        });
    }
    return invalidCddClaims;
});
/**
 * @hidden
 */
function prepareModifyClaims(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { claims, operation } = args;
        const { context: { polymeshApi: { tx: { identity }, }, }, context, } = this;
        const modifyClaimArgs = [];
        let allTargets = [];
        claims.forEach(({ target, expiry, claim }) => {
            const rawExpiry = expiry ? (0, conversion_1.dateToMoment)(expiry, context) : null;
            allTargets.push((0, conversion_1.signerToString)(target));
            modifyClaimArgs.push((0, utils_1.tuple)((0, conversion_1.stringToIdentityId)((0, conversion_1.signerToString)(target), context), (0, conversion_1.claimToMeshClaim)(claim, context), rawExpiry));
        });
        allTargets = (0, lodash_1.uniq)(allTargets);
        const [nonExistentDids, middlewareAvailable] = yield Promise.all([
            context.getInvalidDids(allTargets),
            context.isMiddlewareAvailable(),
        ]);
        if (nonExistentDids.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.DataUnavailable,
                message: 'Some of the supplied Identity IDs do not exist',
                data: {
                    nonExistentDids,
                },
            });
        }
        const shouldValidateWithMiddleware = operation !== types_1.ClaimOperation.Add && middlewareAvailable;
        // skip validation if the middleware is unavailable
        if (shouldValidateWithMiddleware) {
            const { did: currentDid } = yield context.getSigningIdentity();
            const { data: { claims: { nodes: claimsData }, }, } = yield context.queryMiddleware((0, queries_1.claimsQuery)({
                dids: allTargets,
                trustedClaimIssuers: [currentDid],
                includeExpired: true,
            }));
            const claimsByDid = (0, lodash_1.groupBy)(claimsData, 'targetId');
            const claimsByOtherIssuers = findClaimsByOtherIssuers(claims, claimsByDid);
            if (claimsByOtherIssuers.length) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.UnmetPrerequisite,
                    message: `Attempt to ${operation.toLowerCase()} claims that weren't issued by the signing Identity`,
                    data: {
                        claimsByOtherIssuers,
                    },
                });
            }
        }
        if (operation === types_1.ClaimOperation.Revoke) {
            const argsArray = modifyClaimArgs.map(([identityId, claim]) => [identityId, claim]);
            const transactions = (0, internal_2.assembleBatchTransactions)([
                {
                    transaction: identity.revokeClaim,
                    argsArray,
                },
            ]);
            return { transactions, resolver: undefined };
        }
        if (operation === types_1.ClaimOperation.Add) {
            const invalidCddClaims = yield findInvalidCddClaims(claims, context);
            if (invalidCddClaims.length) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.UnmetPrerequisite,
                    message: 'A target Identity cannot have CDD claims with different IDs',
                    data: {
                        invalidCddClaims,
                    },
                });
            }
        }
        const txs = (0, internal_2.assembleBatchTransactions)([
            {
                transaction: identity.addClaim,
                argsArray: modifyClaimArgs,
            },
        ]);
        return { transactions: txs, resolver: undefined };
    });
}
exports.prepareModifyClaims = prepareModifyClaims;
/**
 * @hidden
 */
function getAuthorization({ claims, operation, }) {
    const permissions = {
        transactions: [
            operation === types_1.ClaimOperation.Revoke ? types_1.TxTags.identity.RevokeClaim : types_1.TxTags.identity.AddClaim,
        ],
        assets: [],
        portfolios: [],
    };
    if (claims.some(({ claim: { type } }) => type === types_1.ClaimType.CustomerDueDiligence)) {
        return {
            roles: [{ type: types_1.RoleType.CddProvider }],
            permissions,
        };
    }
    return {
        permissions,
    };
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
const modifyClaims = () => new internal_1.Procedure(prepareModifyClaims, getAuthorization);
exports.modifyClaims = modifyClaims;
//# sourceMappingURL=modifyClaims.js.map