"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.modifyInstructionAffirmation = exports.prepareStorage = exports.getAuthorization = exports.prepareModifyInstructionAffirmation = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bluebird_1 = __importDefault(require("bluebird"));
const utils_1 = require("./utils");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const utils_2 = require("../../types/utils");
const conversion_1 = require("../../utils/conversion");
/**
 * @hidden
 */
function prepareModifyInstructionAffirmation(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx: { settlement: settlementTx }, query: { settlement }, }, }, context, storage: { portfolios, portfolioParams, senderLegAmount, totalLegAmount }, } = this;
        const { operation, id } = args;
        const instruction = new internal_1.Instruction({ id }, context);
        yield (0, utils_1.assertInstructionValid)(instruction, context);
        if (portfolioParams.length && portfolioParams.length !== portfolios.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.UnmetPrerequisite,
                message: 'Some of the portfolios are not a involved in this instruction',
            });
        }
        if (!portfolios.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.UnmetPrerequisite,
                message: 'The signing Identity is not involved in this Instruction',
            });
        }
        const rawInstructionId = (0, conversion_1.bigNumberToU64)(id, context);
        const rawPortfolioIds = portfolios.map(portfolio => (0, conversion_1.portfolioIdToMeshPortfolioId)((0, conversion_1.portfolioLikeToPortfolioId)(portfolio), context));
        const excludeCriteria = [];
        let errorMessage;
        let transaction = null;
        switch (operation) {
            case types_1.InstructionAffirmationOperation.Affirm: {
                excludeCriteria.push(types_1.AffirmationStatus.Affirmed);
                errorMessage = 'The Instruction is already affirmed';
                transaction = settlementTx.affirmInstruction;
                break;
            }
            case types_1.InstructionAffirmationOperation.Withdraw: {
                excludeCriteria.push(types_1.AffirmationStatus.Pending);
                errorMessage = 'The instruction is not affirmed';
                transaction = settlementTx.withdrawAffirmation;
                break;
            }
        }
        const multiArgs = rawPortfolioIds.map(portfolioId => (0, utils_2.tuple)(portfolioId, rawInstructionId));
        const rawAffirmationStatuses = yield settlement.userAffirmations.multi(multiArgs);
        const affirmationStatuses = rawAffirmationStatuses.map(conversion_1.meshAffirmationStatusToAffirmationStatus);
        const validPortfolioIds = rawPortfolioIds.filter((_, index) => !excludeCriteria.includes(affirmationStatuses[index]));
        if (!validPortfolioIds.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.NoDataChange,
                // As InstructionAffirmationOperation.Reject has no excludeCriteria, if this error is thrown
                // it means that the operation had to be either affirm or withdraw, and so the errorMessage was set
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                message: errorMessage,
            });
        }
        // rejection works a bit different
        if (transaction) {
            return {
                transaction,
                resolver: instruction,
                feeMultiplier: senderLegAmount,
                args: [rawInstructionId, validPortfolioIds],
            };
        }
        return {
            transaction: settlementTx.rejectInstruction,
            resolver: instruction,
            feeMultiplier: totalLegAmount,
            args: [rawInstructionId, validPortfolioIds[0]],
        };
    });
}
exports.prepareModifyInstructionAffirmation = prepareModifyInstructionAffirmation;
/**
 * @hidden
 */
function getAuthorization({ operation }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { storage: { portfolios }, } = this;
        let transactions;
        switch (operation) {
            case types_1.InstructionAffirmationOperation.Affirm: {
                transactions = [types_1.TxTags.settlement.AffirmInstruction];
                break;
            }
            case types_1.InstructionAffirmationOperation.Withdraw: {
                transactions = [types_1.TxTags.settlement.WithdrawAffirmation];
                break;
            }
            case types_1.InstructionAffirmationOperation.Reject: {
                transactions = [types_1.TxTags.settlement.RejectInstruction];
                break;
            }
        }
        return {
            permissions: {
                portfolios,
                transactions,
                assets: [],
            },
        };
    });
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function extractPortfolioParams(params) {
    const { operation } = params;
    let portfolioParams = [];
    if (operation === types_1.InstructionAffirmationOperation.Reject) {
        const { portfolio } = params;
        if (portfolio) {
            portfolioParams.push(portfolio);
        }
    }
    else {
        const { portfolios } = params;
        if (portfolios) {
            portfolioParams = [...portfolioParams, ...portfolios];
        }
    }
    return portfolioParams;
}
/**
 * @hidden
 */
const isParam = (legPortfolio, portfolioIdParams) => {
    const { did: legPortfolioDid, number: legPortfolioNumber } = (0, conversion_1.portfolioLikeToPortfolioId)(legPortfolio);
    return (!portfolioIdParams.length ||
        portfolioIdParams.some(({ did, number }) => did === legPortfolioDid &&
            new bignumber_js_1.default(legPortfolioNumber || 0).eq(new bignumber_js_1.default(number || 0))));
};
/**
 * @hidden
 */
const assemblePortfolios = (result, from, to, signingDid, portfolioIdParams) => __awaiter(void 0, void 0, void 0, function* () {
    const [fromExists, toExists] = yield Promise.all([from.exists(), to.exists()]);
    const [custodiedPortfolios, amount] = result;
    let res = [...custodiedPortfolios];
    let legAmount = amount;
    const checkCustody = (legPortfolio, exists, sender) => __awaiter(void 0, void 0, void 0, function* () {
        if (exists) {
            const isCustodied = yield legPortfolio.isCustodiedBy({ identity: signingDid });
            if (isCustodied) {
                res = [...res, legPortfolio];
                if (sender) {
                    legAmount = legAmount.plus(1);
                }
            }
        }
        else if (legPortfolio.owner.did === signingDid) {
            res = [...res, legPortfolio];
        }
    });
    const promises = [];
    if (isParam(from, portfolioIdParams)) {
        promises.push(checkCustody(from, fromExists, true));
    }
    if (isParam(to, portfolioIdParams)) {
        promises.push(checkCustody(to, toExists, false));
    }
    yield Promise.all(promises);
    return (0, utils_2.tuple)(res, legAmount);
});
/**
 * @hidden
 */
function prepareStorage(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context } = this;
        const { id } = params;
        const portfolioParams = extractPortfolioParams(params);
        const portfolioIdParams = portfolioParams.map(conversion_1.portfolioLikeToPortfolioId);
        const instruction = new internal_1.Instruction({ id }, context);
        const [{ data: legs }, { did: signingDid }] = yield Promise.all([
            instruction.getLegs(),
            context.getSigningIdentity(),
        ]);
        const [portfolios, senderLegAmount] = yield bluebird_1.default.reduce(legs, (result, { from, to }) => __awaiter(this, void 0, void 0, function* () { return assemblePortfolios(result, from, to, signingDid, portfolioIdParams); }), [[], new bignumber_js_1.default(0)]);
        return {
            portfolios,
            portfolioParams,
            senderLegAmount,
            totalLegAmount: new bignumber_js_1.default(legs.length),
        };
    });
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const modifyInstructionAffirmation = () => new internal_1.Procedure(prepareModifyInstructionAffirmation, getAuthorization, prepareStorage);
exports.modifyInstructionAffirmation = modifyInstructionAffirmation;
//# sourceMappingURL=modifyInstructionAffirmation.js.map