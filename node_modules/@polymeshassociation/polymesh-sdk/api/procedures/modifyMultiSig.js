"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.modifyMultiSig = exports.prepareStorage = exports.getAuthorization = exports.prepareModifyMultiSig = void 0;
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * @hidden
 */
function calculateSignerDelta(current, target) {
    const currentSet = new Set(current.map(conversion_1.signerToString));
    const targetSet = new Set(target.map(conversion_1.signerToString));
    const newSigners = new Set([...target].filter(s => !currentSet.has((0, conversion_1.signerToString)(s))));
    const removedSigners = new Set([...current].filter(s => !targetSet.has((0, conversion_1.signerToString)(s))));
    return { signersToAdd: Array.from(newSigners), signersToRemove: Array.from(removedSigners) };
}
/**
 * @hidden
 */
function prepareModifyMultiSig(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx }, }, storage: { signersToAdd, signersToRemove, requiredSignatures }, context, } = this;
        const { signers, multiSig } = args;
        const [signingIdentity, creator] = yield Promise.all([
            context.getSigningIdentity(),
            multiSig.getCreator(),
        ]);
        if (!signersToAdd.length && !signersToRemove.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.NoDataChange,
                message: 'The given signers are equal to the current signers. At least one signer should be added or removed',
            });
        }
        if (!creator.isEqual(signingIdentity)) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'A MultiSig can only be modified by its creator',
            });
        }
        const rawAddress = (0, conversion_1.stringToAccountId)(multiSig.address, context);
        if (requiredSignatures.gt(signers.length)) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'The number of required signatures should not exceed the number of signers',
            });
        }
        const transactions = [];
        if (signersToAdd.length > 0) {
            const rawAddedSigners = signersToAdd.map(signer => (0, conversion_1.signerToSignatory)(signer, context));
            transactions.push((0, internal_2.checkTxType)({
                transaction: tx.multiSig.addMultisigSignersViaCreator,
                args: [rawAddress, rawAddedSigners],
            }));
        }
        if (signersToRemove.length > 0) {
            const rawRemovedSigners = signersToRemove.map(signer => (0, conversion_1.signerToSignatory)(signer, context));
            transactions.push((0, internal_2.checkTxType)({
                transaction: tx.multiSig.removeMultisigSignersViaCreator,
                args: [rawAddress, rawRemovedSigners],
            }));
        }
        return {
            transactions,
            resolver: undefined,
        };
    });
}
exports.prepareModifyMultiSig = prepareModifyMultiSig;
/**
 * @hidden
 */
function getAuthorization() {
    const { storage: { signersToAdd, signersToRemove }, } = this;
    const transactions = [];
    if (signersToAdd.length > 0) {
        transactions.push(types_1.TxTags.multiSig.AddMultisigSignersViaCreator);
    }
    if (signersToRemove.length > 0) {
        transactions.push(types_1.TxTags.multiSig.RemoveMultisigSignersViaCreator);
    }
    return {
        permissions: {
            transactions,
        },
    };
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function prepareStorage({ signers, multiSig }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { signers: currentSigners, requiredSignatures } = yield multiSig.details();
        return Object.assign(Object.assign({}, calculateSignerDelta(currentSigners, signers)), { requiredSignatures });
    });
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const modifyMultiSig = () => new internal_1.Procedure(prepareModifyMultiSig, getAuthorization, prepareStorage);
exports.modifyMultiSig = modifyMultiSig;
//# sourceMappingURL=modifyMultiSig.js.map