"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.moveFunds = exports.getAuthorization = exports.prepareMoveFunds = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const lodash_1 = require("lodash");
const utils_1 = require("./utils");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const utils_2 = require("../../utils");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * @hidden
 * separates user input into fungible and nft movements
 */
function segregateItems(items, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const fungibleMovements = [];
        const nftMovements = [];
        const tickers = [];
        for (const item of items) {
            const { asset } = item;
            tickers.push((0, internal_2.asTicker)(asset));
            if (typeof asset === 'string') {
                const ticker = asset;
                const fungible = new internal_1.FungibleAsset({ ticker }, context);
                const collection = new internal_1.NftCollection({ ticker }, context);
                const [isAsset, isCollection] = yield Promise.all([fungible.exists(), collection.exists()]);
                if (isCollection) {
                    nftMovements.push(item);
                }
                else if (isAsset) {
                    fungibleMovements.push(item);
                }
                else {
                    throw new internal_1.PolymeshError({
                        code: types_1.ErrorCode.DataUnavailable,
                        message: `No asset with "${ticker}" exists`,
                    });
                }
            }
            else if ((0, utils_2.isFungibleAsset)(asset)) {
                fungibleMovements.push(item);
            }
            else if ((0, utils_2.isNftCollection)(asset)) {
                nftMovements.push(item);
            }
        }
        const hasDuplicates = (0, lodash_1.uniq)(tickers).length !== tickers.length;
        if (hasDuplicates) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Portfolio movements cannot contain any Asset more than once',
            });
        }
        return {
            fungibleMovements,
            nftMovements,
        };
    });
}
/**
 * @hidden
 */
function prepareMoveFunds(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx: { portfolio }, }, }, context, } = this;
        const { from: fromPortfolio, to, items } = args;
        const { fungibleMovements, nftMovements } = yield segregateItems(items, context);
        const { owner: { did: fromDid }, } = fromPortfolio;
        let toPortfolio;
        if (!to) {
            toPortfolio = new internal_1.DefaultPortfolio({ did: fromDid }, context);
        }
        else if (to instanceof bignumber_js_1.default) {
            toPortfolio = new internal_1.NumberedPortfolio({ did: fromDid, id: to }, context);
        }
        else {
            toPortfolio = to;
        }
        const { owner: { did: toDid }, } = toPortfolio;
        const fromPortfolioId = (0, conversion_1.portfolioLikeToPortfolioId)(fromPortfolio);
        const toPortfolioId = (0, conversion_1.portfolioLikeToPortfolioId)(toPortfolio);
        yield Promise.all([
            (0, utils_1.assertPortfolioExists)(fromPortfolioId, context),
            (0, utils_1.assertPortfolioExists)(toPortfolioId, context),
        ]);
        if (fromDid !== toDid) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Both portfolios should have the same owner',
            });
        }
        if (fromPortfolioId.number === toPortfolioId.number) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Origin and destination should be different Portfolios',
            });
        }
        const [fungibleBalances, heldCollections] = yield Promise.all([
            fromPortfolio.getAssetBalances({
                assets: fungibleMovements.map(({ asset }) => (0, internal_2.asTicker)(asset)),
            }),
            fromPortfolio.getCollections({ collections: nftMovements.map(({ asset }) => (0, internal_2.asTicker)(asset)) }),
        ]);
        const balanceExceeded = [];
        fungibleBalances.forEach(({ asset: { ticker }, free }) => {
            const transferItem = fungibleMovements.find(({ asset: itemAsset }) => (0, internal_2.asTicker)(itemAsset) === ticker);
            if (transferItem.amount.gt(free)) {
                balanceExceeded.push(Object.assign(Object.assign({}, transferItem), { free }));
            }
        });
        if (balanceExceeded.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.InsufficientBalance,
                message: "Some of the amounts being transferred exceed the Portfolio's balance",
                data: {
                    balanceExceeded,
                },
            });
        }
        const unavailableNfts = {};
        nftMovements.forEach(movement => {
            const ticker = (0, internal_2.asTicker)(movement.asset);
            const heldNfts = heldCollections.find(({ collection }) => collection.ticker === ticker);
            movement.nfts.forEach(nftId => {
                const id = (0, internal_2.asNftId)(nftId);
                const hasNft = heldNfts === null || heldNfts === void 0 ? void 0 : heldNfts.free.find(held => held.id.eq(id));
                if (!hasNft) {
                    const entry = unavailableNfts[ticker] || [];
                    entry.push(id);
                    unavailableNfts[ticker] = entry;
                }
            });
        });
        if (Object.keys(unavailableNfts).length > 0) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.InsufficientBalance,
                message: 'Some of the NFTs are not available in the sending portfolio',
                data: { unavailableNfts },
            });
        }
        const rawFrom = (0, conversion_1.portfolioIdToMeshPortfolioId)(fromPortfolioId, context);
        const rawTo = (0, conversion_1.portfolioIdToMeshPortfolioId)(toPortfolioId, context);
        const rawFungibleMovements = fungibleMovements.map(item => (0, conversion_1.fungibleMovementToPortfolioFund)(item, context));
        const rawNftMovements = nftMovements.map(item => (0, conversion_1.nftMovementToPortfolioFund)(item, context));
        return {
            transaction: portfolio.movePortfolioFunds,
            args: [rawFrom, rawTo, [...rawFungibleMovements, ...rawNftMovements]],
            resolver: undefined,
        };
    });
}
exports.prepareMoveFunds = prepareMoveFunds;
/**
 * @hidden
 */
function getAuthorization({ from, to }) {
    const { context } = this;
    const { owner: { did }, } = from;
    let portfolioId = { did };
    if (from instanceof internal_1.NumberedPortfolio) {
        portfolioId = Object.assign(Object.assign({}, portfolioId), { number: from.id });
    }
    let toPortfolio;
    if (!to) {
        toPortfolio = new internal_1.DefaultPortfolio({ did }, context);
    }
    else if (to instanceof bignumber_js_1.default) {
        toPortfolio = new internal_1.NumberedPortfolio({ did, id: to }, context);
    }
    else {
        toPortfolio = to;
    }
    return {
        permissions: {
            transactions: [types_1.TxTags.portfolio.MovePortfolioFunds],
            assets: [],
            portfolios: [from, toPortfolio],
        },
        roles: [{ type: types_1.RoleType.PortfolioCustodian, portfolioId }],
    };
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
const moveFunds = () => new internal_1.Procedure(prepareMoveFunds, getAuthorization);
exports.moveFunds = moveFunds;
//# sourceMappingURL=moveFunds.js.map