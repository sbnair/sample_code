"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setTransferRestrictions = exports.prepareStorage = exports.getAuthorization = exports.prepareSetTransferRestrictions = exports.addExemptionIfNotPresent = exports.newExemptionRecord = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const lodash_1 = require("lodash");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
const newExemptionRecord = () => ({
    Accredited: [],
    Affiliate: [],
    Jurisdiction: [],
    None: [],
});
exports.newExemptionRecord = newExemptionRecord;
/**
 * @hidden
 * @param toInsertId - Identity to insert into the exemption records
 * @param exemptionRecords - records that will be mutated if the Identity should be added
 * @param claimType - type of Claim the Identity is exempt from
 * @param filterSet - set of Identities that should not be added into exemption records if given
 */
const addExemptionIfNotPresent = (toInsertId, exemptionRecords, claimType, filterSet = []) => {
    const found = filterSet.some(currentId => currentId.did === toInsertId.did);
    if (!found) {
        exemptionRecords[claimType].push(toInsertId);
    }
};
exports.addExemptionIfNotPresent = addExemptionIfNotPresent;
/**
 * @hidden
 *
 * Calculates the smallest change needed to get to the requested state from the current state.
 * While clearing and building the restrictions would be simpler, it would be inefficient use of gas fees
 */
function transformInput(inputRestrictions, currentRestrictions, currentExemptions, type, context) {
    const toSetExemptions = (0, exports.newExemptionRecord)();
    const toRemoveExemptions = (0, exports.newExemptionRecord)();
    let needDifferentConditions = inputRestrictions.length !== currentRestrictions.length;
    const conditions = [];
    const inputExemptions = (0, exports.newExemptionRecord)();
    // for each restriction check if we need to make a condition and track all exemptions
    inputRestrictions.forEach(restriction => {
        var _a;
        let value;
        let claimType;
        if ('count' in restriction) {
            value = restriction.count;
        }
        else if ('percentage' in restriction) {
            value = restriction.percentage;
        }
        else {
            value = restriction;
            claimType = restriction.claim.type;
        }
        const condition = { type, value };
        const compareConditions = (transferCondition) => (0, internal_2.compareTransferRestrictionToInput)(transferCondition, condition);
        if (!needDifferentConditions) {
            needDifferentConditions = ![...currentRestrictions].find(compareConditions);
        }
        const rawCondition = (0, conversion_1.transferRestrictionToPolymeshTransferCondition)(condition, context);
        conditions.push(rawCondition);
        (_a = restriction.exemptedIdentities) === null || _a === void 0 ? void 0 : _a.forEach(exemption => {
            const key = claimType || 'None';
            const id = (0, internal_2.asIdentity)(exemption, context);
            (0, exports.addExemptionIfNotPresent)(id, inputExemptions, key);
        });
    });
    // calculate exemptions to add — for each input exemption check if it already exists
    (0, lodash_1.forEach)(inputExemptions, (toAddIds, cType) => {
        const key = cType;
        const currentIds = currentExemptions[key];
        toAddIds.forEach(id => {
            (0, exports.addExemptionIfNotPresent)(id, toSetExemptions, key, currentIds);
        });
    });
    // calculate exemptions to remove — for each current exemption check if it was in the input
    (0, lodash_1.forEach)(currentExemptions, (currentIds, cType) => {
        const key = cType;
        const given = inputExemptions[key];
        currentIds.forEach(id => {
            (0, exports.addExemptionIfNotPresent)(id, toRemoveExemptions, key, given);
        });
    });
    const sizeOf = (obj) => (0, lodash_1.flatten)((0, lodash_1.entries)(obj).map(([, identities]) => identities)).length;
    const needDifferentExemptions = sizeOf(toSetExemptions) > 0 || sizeOf(toRemoveExemptions) > 0;
    if (!needDifferentConditions && !needDifferentExemptions) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.NoDataChange,
            message: 'The restrictions and exemptions are already in place',
        });
    }
    return { conditions, toSetExemptions, toRemoveExemptions };
}
/**
 * @hidden
 */
function prepareSetTransferRestrictions(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx: { statistics }, consts, }, }, storage: { currentRestrictions, occupiedSlots, currentExemptions }, context, } = this;
        const { restrictions: { length: newRestrictionAmount }, restrictions, type, ticker, } = args;
        const tickerKey = (0, conversion_1.stringToTickerKey)(ticker, context);
        const { conditions, toSetExemptions, toRemoveExemptions } = transformInput(restrictions, currentRestrictions, currentExemptions, type, context);
        const maxTransferConditions = (0, conversion_1.u32ToBigNumber)(consts.statistics.maxTransferConditionsPerAsset);
        const finalCount = occupiedSlots.plus(newRestrictionAmount);
        if (finalCount.gte(maxTransferConditions)) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.LimitExceeded,
                message: 'Cannot set more Transfer Restrictions than there are slots available',
                data: {
                    availableSlots: maxTransferConditions.minus(occupiedSlots),
                },
            });
        }
        const transactions = [];
        const op = (0, conversion_1.transferRestrictionTypeToStatOpType)(type, context);
        transactions.push((0, internal_2.checkTxType)({
            transaction: statistics.setAssetTransferCompliance,
            args: [tickerKey, (0, conversion_1.complianceConditionsToBtreeSet)(conditions, context)],
        }));
        const pushExemptions = (exemptions, exempt) => {
            (0, lodash_1.forEach)(exemptions, (exempted, claimType) => {
                if (exempted.length === 0) {
                    return;
                }
                const rawClaimType = claimType === 'None' ? undefined : claimType;
                const exemptKey = (0, conversion_1.toExemptKey)(tickerKey, op, rawClaimType);
                const exemptedBtreeSet = (0, conversion_1.identitiesToBtreeSet)(exempted, context);
                const rawExempt = (0, conversion_1.booleanToBool)(exempt, context);
                transactions.push((0, internal_2.checkTxType)({
                    transaction: statistics.setEntitiesExempt,
                    feeMultiplier: new bignumber_js_1.default(exemptedBtreeSet.size),
                    args: [rawExempt, exemptKey, exemptedBtreeSet],
                }));
            });
        };
        pushExemptions(toSetExemptions, true);
        pushExemptions(toRemoveExemptions, false);
        return { transactions, resolver: finalCount };
    });
}
exports.prepareSetTransferRestrictions = prepareSetTransferRestrictions;
/**
 * @hidden
 */
function getAuthorization({ ticker, restrictions }) {
    const transactions = [types_1.TxTags.statistics.SetAssetTransferCompliance];
    const needExemptionsPermission = restrictions.some(r => { var _a; return (_a = r.exemptedIdentities) === null || _a === void 0 ? void 0 : _a.length; });
    if (needExemptionsPermission) {
        transactions.push(types_1.TxTags.statistics.SetEntitiesExempt);
    }
    return {
        permissions: {
            assets: [new internal_1.FungibleAsset({ ticker }, this.context)],
            transactions,
            portfolios: [],
        },
    };
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function prepareStorage(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context, context: { polymeshApi: { query: { statistics }, }, }, } = this;
        const { ticker, type } = args;
        const tickerKey = (0, conversion_1.stringToTickerKey)(ticker, context);
        const currentStats = yield statistics.activeAssetStats(tickerKey);
        args.restrictions.forEach(restriction => {
            let claimIssuer;
            if (type === types_1.TransferRestrictionType.ClaimCount ||
                type === types_1.TransferRestrictionType.ClaimPercentage) {
                const { claim: { type: claimType }, issuer, } = restriction;
                claimIssuer = { claimType, issuer };
            }
            const neededStat = (0, internal_2.neededStatTypeForRestrictionInput)({ type, claimIssuer }, context);
            (0, internal_2.assertStatIsSet)(currentStats, neededStat);
        });
        const { transferRestrictions: { count, percentage, claimCount, claimPercentage }, } = new internal_1.FungibleAsset({ ticker }, context);
        const [{ restrictions: currentCountRestrictions }, { restrictions: currentPercentageRestrictions }, { restrictions: currentClaimCountRestrictions }, { restrictions: currentClaimPercentageRestrictions },] = yield Promise.all([count.get(), percentage.get(), claimCount.get(), claimPercentage.get()]);
        const currentRestrictions = [];
        let occupiedSlots = currentCountRestrictions.length +
            currentPercentageRestrictions.length +
            currentClaimCountRestrictions.length +
            currentClaimPercentageRestrictions.length;
        if (type === types_1.TransferRestrictionType.Count) {
            occupiedSlots -= currentCountRestrictions.length;
        }
        else if (type === types_1.TransferRestrictionType.Percentage) {
            occupiedSlots -= currentPercentageRestrictions.length;
        }
        else if (type === types_1.TransferRestrictionType.ClaimCount) {
            occupiedSlots -= currentClaimCountRestrictions.length;
        }
        else {
            occupiedSlots -= currentClaimPercentageRestrictions.length;
        }
        if (type === types_1.TransferRestrictionType.Count) {
            currentCountRestrictions.forEach(({ count: value }) => {
                const restriction = { type: types_1.TransferRestrictionType.Count, value };
                currentRestrictions.push(restriction);
            });
        }
        else if (type === types_1.TransferRestrictionType.Percentage) {
            currentPercentageRestrictions.forEach(({ percentage: value }) => {
                const restriction = { type: types_1.TransferRestrictionType.Percentage, value };
                currentRestrictions.push(restriction);
            });
        }
        else if (type === types_1.TransferRestrictionType.ClaimCount) {
            currentClaimCountRestrictions.forEach(({ claim, min, max, issuer }) => {
                const restriction = { type, value: { claim, min, max, issuer } };
                currentRestrictions.push(restriction);
            });
        }
        else {
            currentClaimPercentageRestrictions.forEach(({ claim, min, max, issuer }) => {
                const restriction = { type, value: { claim, min, max, issuer } };
                currentRestrictions.push(restriction);
            });
        }
        const op = (0, conversion_1.transferRestrictionTypeToStatOpType)(type, context);
        const claimTypes = type === types_1.TransferRestrictionType.Count || type === types_1.TransferRestrictionType.Percentage
            ? [undefined]
            : [types_1.ClaimType.Accredited, types_1.ClaimType.Affiliate, types_1.ClaimType.Jurisdiction];
        const exemptionFetchers = [];
        claimTypes.forEach(claimType => {
            exemptionFetchers.push(statistics.transferConditionExemptEntities.entries({
                asset: tickerKey,
                op,
                claimType,
            }));
        });
        const rawCurrentExemptions = (0, lodash_1.flatten)(yield Promise.all(exemptionFetchers));
        const currentExemptions = (0, exports.newExemptionRecord)();
        rawCurrentExemptions.forEach(([{ args: [{ claimType: rawClaimType }, rawDid], },]) => {
            const did = (0, conversion_1.identityIdToString)(rawDid);
            let claimType = 'None';
            if (rawClaimType.isSome) {
                claimType = (0, conversion_1.meshClaimTypeToClaimType)(rawClaimType.unwrap());
            }
            const identity = new internal_1.Identity({ did }, context);
            (0, exports.addExemptionIfNotPresent)(identity, currentExemptions, claimType);
        });
        const transformRestriction = (restriction) => {
            return (0, conversion_1.transferRestrictionToPolymeshTransferCondition)(restriction, context);
        };
        return {
            occupiedSlots: new bignumber_js_1.default(occupiedSlots),
            currentRestrictions: currentRestrictions.map(transformRestriction),
            currentExemptions,
        };
    });
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const setTransferRestrictions = () => new internal_1.Procedure(prepareSetTransferRestrictions, getAuthorization, prepareStorage);
exports.setTransferRestrictions = setTransferRestrictions;
//# sourceMappingURL=setTransferRestrictions.js.map