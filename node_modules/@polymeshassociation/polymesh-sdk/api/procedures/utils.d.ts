import { ISubmittableResult } from '@polkadot/types/types';
import BigNumber from 'bignumber.js';
import { Account, AuthorizationRequest, BaseAsset, Checkpoint, CheckpointSchedule, Context, CustomPermissionGroup, FungibleAsset, Identity, Instruction, KnownPermissionGroup } from "../../internal";
import { AddRelayerPayingKeyAuthorizationData, Authorization, Condition, GenericAuthorizationData, InputCondition, InputTaxWithholding, InstructionDetails, PermissionedAccount, PortfolioId, Signer, TransactionPermissions, TxTag } from "../../types";
/**
 * @hidden
 */
export declare function assertInstructionValid(instruction: Instruction, context: Context): Promise<void>;
/**
 * @hidden
 */
export declare function assertInstructionValidForManualExecution(details: InstructionDetails, context: Context): Promise<void>;
/**
 * @hidden
 */
export declare function assertPortfolioExists(portfolioId: PortfolioId, context: Context): Promise<void>;
/**
 * @hidden
 */
export declare function assertVenueExists(venueId: BigNumber, context: Context): Promise<void>;
/**
 * @hidden
 */
export declare function assertSecondaryAccounts(accounts: Account[], secondaryAccounts: PermissionedAccount[]): void;
/**
 * @hidden
 */
export declare function assertDistributionOpen(paymentDate: Date, expiryDate: Date | null): void;
/**
 * @hidden
 */
export declare function assertCaTaxWithholdingsValid(taxWithholdings: InputTaxWithholding[], context: Context): void;
/**
 * @hidden
 */
export declare function assertCaCheckpointValid(checkpoint: Checkpoint | CheckpointSchedule | Date): Promise<void>;
/**
 * @hidden
 */
export declare function assertDistributionDatesValid(checkpoint: CheckpointSchedule | Date, paymentDate: Date, expiryDate: Date | null): Promise<void>;
/**
 * @hidden
 */
export declare function isFullGroupType(group: KnownPermissionGroup | CustomPermissionGroup): boolean;
/**
 * @hidden
 *
 * @note based on the complexity calculation done by the chain
 * @note conditions have already been "injected" with the default trusted claim issuers when they reach this point
 */
export declare function assertRequirementsNotTooComplex(conditions: (Condition | InputCondition)[], defaultClaimIssuerLength: BigNumber, context: Context): void;
/**
 * @hidden
 *
 * Asserts valid primary key rotation authorization
 */
export declare function assertPrimaryKeyRotationAuthorizationValid(authRequest: AuthorizationRequest): Promise<void>;
/**
 * @hidden
 *
 * Asserts valid attest primary key authorization
 */
export declare function assertAttestPrimaryKeyAuthorizationValid(authRequest: AuthorizationRequest): Promise<void>;
/**
 * @hidden
 *
 * Asserts transfer ticker authorization is valid
 */
export declare function assertTransferTickerAuthorizationValid(data: GenericAuthorizationData, context: Context): Promise<void>;
/**
 * @hidden
 *
 * Asserts valid transfer asset ownership authorization
 */
export declare function assertTransferAssetOwnershipAuthorizationValid(data: GenericAuthorizationData, context: Context): Promise<void>;
/**
 * @hidden
 *
 * Asserts valid add multisig signer authorization
 */
export declare function assertMultiSigSignerAuthorizationValid(data: GenericAuthorizationData, target: Signer, context: Context): Promise<void>;
/**
 * @hidden
 *
 * Asserts valid add relayer paying key authorization
 */
export declare function assertAddRelayerPayingKeyAuthorizationValid(data: AddRelayerPayingKeyAuthorizationData): Promise<void>;
/**
 * @hidden
 *
 * Helper class to ensure a code path is unreachable. For example this can be used for ensuring switch statements are exhaustive
 */
export declare class UnreachableCaseError extends Error {
    /** This should never be called */
    constructor(val: never);
}
/**
 * @hidden
 */
export declare function assertAuthorizationRequestValid(authRequest: AuthorizationRequest, context: Context): Promise<void>;
/**
 * @hidden
 *
 * Retrieve the Permission Group that has the same permissions as the ones passed as input, or undefined if
 *   there is no matching group
 */
export declare function getGroupFromPermissions(asset: BaseAsset, permissions: TransactionPermissions | null): Promise<(CustomPermissionGroup | KnownPermissionGroup) | undefined>;
/**
 * @hidden
 */
export declare function assertGroupDoesNotExist(asset: FungibleAsset, permissions: TransactionPermissions | null): Promise<void>;
/**
 * @hidden
 */
export declare const createAuthorizationResolver: (auth: Authorization, issuer: Identity, target: Identity | Account, expiry: Date | null, context: Context) => (receipt: ISubmittableResult) => AuthorizationRequest;
/**
 * @hidden
 */
export declare const createCreateGroupResolver: (context: Context) => (receipt: ISubmittableResult) => CustomPermissionGroup;
/**
 * Add protocol fees for specific tags to the current accumulated total
 *
 * @returns undefined if fees aren't being calculated manually
 */
export declare function addManualFees(currentFee: BigNumber | undefined, tags: TxTag[], context: Context): Promise<BigNumber | undefined>;
//# sourceMappingURL=utils.d.ts.map