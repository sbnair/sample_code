import { ApolloClient, ApolloQueryResult, NormalizedCacheObject, OperationVariables, QueryOptions } from '@apollo/client/core';
import { ApiPromise } from '@polkadot/api';
import { Codec, DetectCodec, Signer as PolkadotSigner } from '@polkadot/types/types';
import { SigningManager } from '@polymeshassociation/signing-manager-types';
import BigNumber from 'bignumber.js';
import { HistoricPolyxTransaction } from "../api/entities/Account/types";
import { Account, ChildIdentity, FungibleAsset, Identity } from "../internal";
import { Query } from "../middleware/types";
import { AccountBalance, ClaimData, ClaimType, DistributionWithDetails, MiddlewareMetadata, PolkadotConfig, ProtocolFees, ResultSet, SubCallback, SubsidyWithAllowance, TransactionArgument, TxTag, UnsubCallback } from "../types";
/**
 * @hidden
 *
 * Context in which the SDK is being used
 *
 * - Holds the polkadot API instance
 * - Holds the middleware API instance (if any)
 * - Holds the middleware V2 API instance (if any)
 * - Holds the Signing Manager (if any)
 */
export declare class Context {
    private isDisconnected;
    polymeshApi: ApiPromise;
    ss58Format: BigNumber;
    private _middlewareApi;
    private _polymeshApi;
    private _signingManager?;
    private signingAddress?;
    private nonce?;
    private _isArchiveNodeResult?;
    /**
     * @hidden
     */
    private constructor();
    /**
     * @hidden
     *
     * Create the Context instance
     */
    static create(params: {
        polymeshApi: ApiPromise;
        middlewareApiV2: ApolloClient<NormalizedCacheObject> | null;
        signingManager?: SigningManager;
        polkadot?: PolkadotConfig;
    }): Promise<Context>;
    /**
     * @hidden
     *
     * checks if current node is archive by querying the balance at genesis block
     *
     * @note caches first successful result to avoid repeated network calls
     */
    isCurrentNodeArchive(): Promise<boolean>;
    /**
     * @hidden
     *
     * @note the signing Account will be set to the Signing Manager's first Account. If the Signing Manager has
     *   no Accounts yet, the signing Account will be left empty
     */
    setSigningManager(signingManager: SigningManager | null): Promise<void>;
    /**
     * @hidden
     */
    private get signingManager();
    /**
     * @hidden
     *
     * Retrieve a list of Accounts that can sign transactions
     */
    getSigningAccounts(): Promise<Account[]>;
    /**
     * @hidden
     *
     * Set the signing Account from among the existing ones in the Signing Manager
     *
     * @throws if the passed address isn't valid, or isn't present in the Signing Manager
     */
    setSigningAddress(signingAddress: string): Promise<void>;
    /**
     * @hidden
     *
     * Retrieve the Account POLYX balance
     *
     * @note can be subscribed to
     */
    accountBalance(account?: string | Account): Promise<AccountBalance>;
    accountBalance(account: string | Account | undefined, callback: SubCallback<AccountBalance>): Promise<UnsubCallback>;
    /**
     * @hidden
     *
     * Retrieve the Account subsidizer relationship. If there is no such relationship, return null
     *
     * @note can be subscribed to
     */
    accountSubsidy(account?: string | Account): Promise<SubsidyWithAllowance | null>;
    accountSubsidy(account: string | Account | undefined, callback: SubCallback<SubsidyWithAllowance | null>): Promise<UnsubCallback>;
    /**
     * @hidden
     *
     * Retrieve the signing Account
     *
     * @throws if there is no signing Account associated to the SDK instance
     */
    getSigningAccount(): Account;
    /**
     * @hidden
     *
     * Retrieve the signing Identity
     *
     * @throws if there is no Identity associated to the signing Account (or there is no signing Account associated to the SDK instance)
     */
    getSigningIdentity(): Promise<Identity>;
    /**
     * @hidden
     *
     * Retrieve the polkadot.js promise client
     */
    getPolymeshApi(): ApiPromise;
    /**
     * @hidden
     *
     * Retrieve the signing address
     *
     * @throws if there is no signing Account associated to the SDK instance
     */
    getSigningAddress(): string;
    /**
     * @hidden
     *
     * Retrieve the external signer from the Signing Manager
     */
    getExternalSigner(): PolkadotSigner;
    /**
     * @hidden
     *
     * Check whether a set of Identities exist
     */
    getInvalidDids(identities: (string | Identity)[]): Promise<string[]>;
    /**
     * @hidden
     *
     * Returns an Identity when given a DID string
     *
     * @throws if the Identity does not exist
     */
    getIdentity(identity: Identity | string): Promise<Identity>;
    /**
     * @hidden
     *
     * Returns an Child Identity when given a DID string
     *
     * @throws if the Child Identity does not exist
     */
    getChildIdentity(child: ChildIdentity | string): Promise<ChildIdentity>;
    /**
     * @hidden
     *
     * Retrieve the protocol fees associated with running specific transactions
     *
     * @param tags - list of transaction tags (e.g. [TxTags.asset.CreateAsset, TxTags.asset.RegisterTicker] or ["asset.createAsset", "asset.registerTicker"])
     * @param blockHash - optional hash of the block to get the protocol fees at that block
     */
    getProtocolFees({ tags, blockHash, }: {
        tags: TxTag[];
        blockHash?: string;
    }): Promise<ProtocolFees[]>;
    /**
     * @hidden
     *
     * Return whether the passed transaction can be subsidized
     */
    supportsSubsidy({ tag }: {
        tag: TxTag;
    }): boolean;
    /**
     * Retrieve the types of arguments that a certain transaction requires to be run
     *
     * @param args.tag - tag associated with the transaction that will be executed if the proposal passes
     */
    getTransactionArguments({ tag }: {
        tag: TxTag;
    }): TransactionArgument[];
    /**
     * @hidden
     */
    getDividendDistributionsForAssets(args: {
        assets: FungibleAsset[];
    }): Promise<DistributionWithDetails[]>;
    /**
     * @hidden
     *
     * @note no claimTypes value means ALL claim types
     */
    getIdentityClaimsFromChain(args: {
        targets: (string | Identity)[];
        claimTypes?: ClaimType[];
        trustedClaimIssuers?: (string | Identity)[];
        includeExpired: boolean;
    }): Promise<ClaimData[]>;
    /**
     * @hidden
     */
    getIdentityClaimsFromMiddleware(args: {
        targets?: (string | Identity)[];
        trustedClaimIssuers?: (string | Identity)[];
        claimTypes?: ClaimType[];
        includeExpired?: boolean;
        size?: BigNumber;
        start?: BigNumber;
    }): Promise<ResultSet<ClaimData>>;
    /**
     * @hidden
     *
     * Retrieve a list of claims. Can be filtered using parameters
     *
     * @param opts.targets - Identities (or Identity IDs) for which to fetch claims (targets). Defaults to all targets
     * @param opts.trustedClaimIssuers - Identity IDs of claim issuers. Defaults to all claim issuers
     * @param opts.claimTypes - types of the claims to fetch. Defaults to any type
     * @param opts.includeExpired - whether to include expired claims. Defaults to true
     * @param opts.size - page size
     * @param opts.start - page offset
     *
     * @note uses the middleware V2 (optional)
     */
    issuedClaims(opts?: {
        targets?: (string | Identity)[];
        trustedClaimIssuers?: (string | Identity)[];
        claimTypes?: ClaimType[];
        includeExpired?: boolean;
        size?: BigNumber;
        start?: BigNumber;
    }): Promise<ResultSet<ClaimData>>;
    /**
     * Retrieve the middleware client
     *
     * @throws if the middleware V2 is not enabled
     */
    get middlewareApi(): ApolloClient<NormalizedCacheObject>;
    /**
     * @hidden
     *
     * Make a query to the middleware V2 server using the apollo client
     */
    queryMiddleware<Result extends Partial<Query>>(query: QueryOptions<OperationVariables, Result>): Promise<ApolloQueryResult<Result>>;
    /**
     * @hidden
     *
     * Return whether the middleware V2 was enabled at startup
     */
    isMiddlewareEnabled(): boolean;
    /**
     * @hidden
     *
     * Return whether the middleware V2 is enabled and online
     */
    isMiddlewareAvailable(): Promise<boolean>;
    /**
     * @hidden
     *
     * Retrieve the number of the latest finalized block
     */
    getLatestBlock(): Promise<BigNumber>;
    /**
     * @hidden
     *
     * Retrieve the network version
     */
    getNetworkVersion(): Promise<string>;
    /**
     * @hidden
     *
     * Disconnect the Polkadot API, middleware, and render this instance unusable
     *
     * @note after disconnecting, trying to access any property in this object will result
     *   in an error
     */
    disconnect(): Promise<void>;
    /**
     * @hidden
     *
     * Returns a (shallow) clone of this instance. Useful for providing a separate
     *   Context to Procedures with different signing Accounts
     */
    clone(): Context;
    /**
     *  @hidden
     *
     * Creates an instance of a type as registered in the polymeshApi instance
     */
    createType<T extends Codec = Codec, K extends string = string>(type: K, params: unknown): DetectCodec<T, K>;
    /**
     * @hidden
     *
     * Set the nonce value
     */
    setNonce(nonce?: BigNumber): void;
    /**
     * @hidden
     *
     * Retrieve the nonce value
     */
    getNonce(): BigNumber;
    /**
     * Retrieve middleware metadata.
     * Returns null if middleware V2 is disabled
     *
     * @note uses the middleware V2
     */
    getMiddlewareMetadata(): Promise<MiddlewareMetadata | null>;
    /**
     * @hidden
     *
     * Retrieve POLYX transactions for a given identity or list of accounts
     *
     * @note uses the middleware V2
     */
    getPolyxTransactions(args: {
        identity?: string | Identity;
        accounts?: (string | Account)[];
        size?: BigNumber;
        start?: BigNumber;
    }): Promise<ResultSet<HistoricPolyxTransaction>>;
}
//# sourceMappingURL=Context.d.ts.map