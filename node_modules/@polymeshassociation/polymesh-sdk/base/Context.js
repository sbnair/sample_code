"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = void 0;
const types_1 = require("@polkadot/types");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bluebird_1 = __importDefault(require("bluebird"));
const lodash_1 = require("lodash");
const internal_1 = require("../internal");
const enums_1 = require("../middleware/enums");
const queries_1 = require("../middleware/queries");
const types_2 = require("../types");
const constants_1 = require("../utils/constants");
const conversion_1 = require("../utils/conversion");
const internal_2 = require("../utils/internal");
const utils_1 = require("./utils");
/**
 * @hidden
 *
 * Context in which the SDK is being used
 *
 * - Holds the polkadot API instance
 * - Holds the middleware API instance (if any)
 * - Holds the middleware V2 API instance (if any)
 * - Holds the Signing Manager (if any)
 */
class Context {
    /**
     * @hidden
     */
    constructor(params) {
        this.isDisconnected = false;
        const { polymeshApi, middlewareApiV2, ss58Format } = params;
        this._middlewareApi = middlewareApiV2;
        this._polymeshApi = polymeshApi;
        this.polymeshApi = polymeshApi;
        this.ss58Format = ss58Format;
    }
    /**
     * @hidden
     *
     * Create the Context instance
     */
    static create(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { polymeshApi, middlewareApiV2, signingManager } = params;
            const ss58Format = (0, conversion_1.u16ToBigNumber)(polymeshApi.consts.system.ss58Prefix);
            const context = new Context({
                polymeshApi,
                middlewareApiV2,
                signingManager,
                ss58Format,
            });
            if (signingManager) {
                yield context.setSigningManager(signingManager);
            }
            return new Proxy(context, {
                get: (target, prop) => {
                    if (target.isDisconnected) {
                        throw new internal_1.PolymeshError({
                            code: types_2.ErrorCode.FatalError,
                            message: 'Client disconnected. Please create a new instance via "Polymesh.connect()"',
                        });
                    }
                    return target[prop];
                },
            });
        });
    }
    /**
     * @hidden
     *
     * checks if current node is archive by querying the balance at genesis block
     *
     * @note caches first successful result to avoid repeated network calls
     */
    isCurrentNodeArchive() {
        return __awaiter(this, void 0, void 0, function* () {
            const { polymeshApi: { query: { system }, }, polymeshApi, } = this;
            if (typeof this._isArchiveNodeResult !== 'undefined') {
                return this._isArchiveNodeResult;
            }
            try {
                const blockHash = yield system.blockHash((0, conversion_1.bigNumberToU32)(new bignumber_js_1.default(0), this));
                const apiAt = yield polymeshApi.at(blockHash);
                const balance = yield apiAt.query.balances.totalIssuance();
                this._isArchiveNodeResult = (0, conversion_1.balanceToBigNumber)(balance).gt(new bignumber_js_1.default(0));
                return this._isArchiveNodeResult;
            }
            catch (e) {
                return false;
            }
        });
    }
    /**
     * @hidden
     *
     * @note the signing Account will be set to the Signing Manager's first Account. If the Signing Manager has
     *   no Accounts yet, the signing Account will be left empty
     */
    setSigningManager(signingManager) {
        return __awaiter(this, void 0, void 0, function* () {
            if (signingManager === null) {
                this._signingManager = undefined;
                this.signingAddress = undefined;
                // TODO remove cast when polkadot/api >= v10.7.2
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this._polymeshApi.setSigner(undefined);
                return;
            }
            this._signingManager = signingManager;
            this._polymeshApi.setSigner(signingManager.getExternalSigner());
            signingManager.setSs58Format(this.ss58Format.toNumber());
            // this could be undefined
            const [firstAccount] = yield signingManager.getAccounts();
            if (!firstAccount) {
                this.signingAddress = undefined;
            }
            else {
                return this.setSigningAddress(firstAccount);
            }
        });
    }
    /**
     * @hidden
     */
    get signingManager() {
        const { _signingManager: manager } = this;
        if (!manager) {
            throw new internal_1.PolymeshError({
                code: types_2.ErrorCode.General,
                message: 'There is no Signing Manager attached to the SDK',
            });
        }
        return manager;
    }
    /**
     * @hidden
     *
     * Retrieve a list of Accounts that can sign transactions
     */
    getSigningAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const { signingManager } = this;
            const accounts = yield signingManager.getAccounts();
            return accounts.map(address => new internal_1.Account({ address }, this));
        });
    }
    /**
     * @hidden
     *
     * Set the signing Account from among the existing ones in the Signing Manager
     *
     * @throws if the passed address isn't valid, or isn't present in the Signing Manager
     */
    setSigningAddress(signingAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const { signingManager } = this;
            const newAddress = signingAddress;
            (0, internal_2.assertAddressValid)(newAddress, this.ss58Format);
            const accounts = yield signingManager.getAccounts();
            const newSigningAddress = accounts.find(account => {
                return account === newAddress;
            });
            if (!newSigningAddress) {
                throw new internal_1.PolymeshError({
                    code: types_2.ErrorCode.General,
                    message: 'The Account is not part of the Signing Manager attached to the SDK',
                });
            }
            this.signingAddress = newSigningAddress;
        });
    }
    // eslint-disable-next-line require-jsdoc
    accountBalance(account, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const { polymeshApi: { query: { system }, }, } = this;
            let address;
            if (account) {
                address = (0, conversion_1.signerToString)(account);
            }
            else {
                ({ address } = this.getSigningAccount());
            }
            const rawAddress = (0, conversion_1.stringToAccountId)(address, this);
            const assembleResult = ({ data: { free: rawFree, miscFrozen, feeFrozen, reserved: rawReserved }, }) => {
                /*
                 * The chain's "free" balance is the balance that isn't locked. Here we calculate it so
                 * the free balance is what the Account is able to spend
                 */
                const reserved = (0, conversion_1.balanceToBigNumber)(rawReserved);
                const total = (0, conversion_1.balanceToBigNumber)(rawFree).plus(reserved);
                const locked = bignumber_js_1.default.max((0, conversion_1.balanceToBigNumber)(miscFrozen), (0, conversion_1.balanceToBigNumber)(feeFrozen));
                return {
                    total,
                    locked,
                    free: total.minus(locked).minus(reserved),
                };
            };
            if (callback) {
                return system.account(rawAddress, info => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises -- callback errors should be handled by the caller
                    callback(assembleResult(info));
                });
            }
            const accountInfo = yield system.account(rawAddress);
            return assembleResult(accountInfo);
        });
    }
    // eslint-disable-next-line require-jsdoc
    accountSubsidy(account, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const { polymeshApi: { query: { relayer }, }, } = this;
            let address;
            if (account) {
                address = (0, conversion_1.signerToString)(account);
            }
            else {
                ({ address } = this.getSigningAccount());
            }
            const rawAddress = (0, conversion_1.stringToAccountId)(address, this);
            const assembleResult = (meshSubsidy) => {
                if (meshSubsidy.isNone) {
                    return null;
                }
                const { payingKey, remaining } = meshSubsidy.unwrap();
                const allowance = (0, conversion_1.balanceToBigNumber)(remaining);
                const subsidy = new internal_1.Subsidy({ beneficiary: address, subsidizer: (0, conversion_1.accountIdToString)(payingKey) }, this);
                return {
                    subsidy,
                    allowance,
                };
            };
            if (callback) {
                return relayer.subsidies(rawAddress, subsidy => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises -- callback errors should be handled by the caller
                    callback(assembleResult(subsidy));
                });
            }
            const subsidies = yield relayer.subsidies(rawAddress);
            return assembleResult(subsidies);
        });
    }
    /**
     * @hidden
     *
     * Retrieve the signing Account
     *
     * @throws if there is no signing Account associated to the SDK instance
     */
    getSigningAccount() {
        const address = this.getSigningAddress();
        return new internal_1.Account({ address }, this);
    }
    /**
     * @hidden
     *
     * Retrieve the signing Identity
     *
     * @throws if there is no Identity associated to the signing Account (or there is no signing Account associated to the SDK instance)
     */
    getSigningIdentity() {
        return __awaiter(this, void 0, void 0, function* () {
            const account = this.getSigningAccount();
            const identity = yield account.getIdentity();
            if (identity === null) {
                throw new internal_1.PolymeshError({
                    code: types_2.ErrorCode.DataUnavailable,
                    message: 'The signing Account does not have an associated Identity',
                });
            }
            return identity;
        });
    }
    /**
     * @hidden
     *
     * Retrieve the polkadot.js promise client
     */
    getPolymeshApi() {
        return this._polymeshApi;
    }
    /**
     * @hidden
     *
     * Retrieve the signing address
     *
     * @throws if there is no signing Account associated to the SDK instance
     */
    getSigningAddress() {
        const { signingAddress } = this;
        if (!signingAddress) {
            throw new internal_1.PolymeshError({
                code: types_2.ErrorCode.General,
                message: 'There is no signing Account associated with the SDK instance',
            });
        }
        return signingAddress;
    }
    /**
     * @hidden
     *
     * Retrieve the external signer from the Signing Manager
     */
    getExternalSigner() {
        const { signingManager } = this;
        return signingManager.getExternalSigner();
    }
    /**
     * @hidden
     *
     * Check whether a set of Identities exist
     */
    getInvalidDids(identities) {
        return __awaiter(this, void 0, void 0, function* () {
            const { polymeshApi: { query: { identity }, }, } = this;
            const dids = identities.map(conversion_1.signerToString);
            const rawIdentities = dids.map(did => (0, conversion_1.stringToIdentityId)(did, this));
            const records = yield identity.didRecords.multi(rawIdentities);
            const invalidDids = [];
            records.forEach((record, index) => {
                if (record.isNone) {
                    invalidDids.push(dids[index]);
                }
            });
            return invalidDids;
        });
    }
    /**
     * @hidden
     *
     * Returns an Identity when given a DID string
     *
     * @throws if the Identity does not exist
     */
    getIdentity(identity) {
        return __awaiter(this, void 0, void 0, function* () {
            if (identity instanceof internal_1.Identity) {
                return identity;
            }
            const id = new internal_1.Identity({ did: identity }, this);
            const exists = yield id.exists();
            if (!exists) {
                throw new internal_1.PolymeshError({
                    code: types_2.ErrorCode.DataUnavailable,
                    message: 'The passed DID does not correspond to an on-chain user Identity. It may correspond to an Asset Identity',
                });
            }
            return id;
        });
    }
    /**
     * @hidden
     *
     * Returns an Child Identity when given a DID string
     *
     * @throws if the Child Identity does not exist
     */
    getChildIdentity(child) {
        return __awaiter(this, void 0, void 0, function* () {
            if (child instanceof internal_1.ChildIdentity) {
                return child;
            }
            const childIdentity = new internal_1.ChildIdentity({ did: child }, this);
            const exists = yield childIdentity.exists();
            if (!exists) {
                throw new internal_1.PolymeshError({
                    code: types_2.ErrorCode.DataUnavailable,
                    message: 'The passed DID does not correspond to an on-chain child Identity',
                });
            }
            return childIdentity;
        });
    }
    /**
     * @hidden
     *
     * Retrieve the protocol fees associated with running specific transactions
     *
     * @param tags - list of transaction tags (e.g. [TxTags.asset.CreateAsset, TxTags.asset.RegisterTicker] or ["asset.createAsset", "asset.registerTicker"])
     * @param blockHash - optional hash of the block to get the protocol fees at that block
     */
    getProtocolFees({ tags, blockHash, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { polymeshApi: { query: { protocolFee: { baseFees, coefficient }, }, }, } = this;
            const tagsMap = new Map();
            tags.forEach(tag => {
                try {
                    tagsMap.set(tag, (0, conversion_1.txTagToProtocolOp)(tag, this));
                }
                catch (err) {
                    tagsMap.set(tag, undefined);
                }
            });
            let baseFeesQuery;
            if (blockHash) {
                ({
                    query: {
                        protocolFee: { baseFees: baseFeesQuery },
                    },
                } = yield (0, internal_2.getApiAtBlock)(this, (0, conversion_1.stringToHash)(blockHash, this)));
            }
            else {
                baseFeesQuery = baseFees;
            }
            const [baseFeesEntries, coefficientValue] = yield Promise.all([
                baseFeesQuery.entries(),
                coefficient(),
            ]);
            const assembleResult = (rawProtocolOp) => {
                const baseFeeEntry = baseFeesEntries.find(([{ args: [protocolOp], },]) => protocolOp.eq(rawProtocolOp));
                let fee = new bignumber_js_1.default(0);
                if (baseFeeEntry) {
                    const [, balance] = baseFeeEntry;
                    fee = (0, conversion_1.balanceToBigNumber)(balance).multipliedBy((0, conversion_1.posRatioToBigNumber)(coefficientValue));
                }
                return fee;
            };
            const protocolFees = [];
            tagsMap.forEach((rawProtocolOp, txTag) => {
                protocolFees.push({
                    tag: txTag,
                    fees: assembleResult(rawProtocolOp),
                });
            });
            return protocolFees;
        });
    }
    /**
     * @hidden
     *
     * Return whether the passed transaction can be subsidized
     */
    supportsSubsidy({ tag }) {
        const moduleName = tag.split('.')[0];
        return [
            types_2.ModuleName.Asset,
            types_2.ModuleName.ComplianceManager,
            types_2.ModuleName.CorporateAction,
            types_2.ModuleName.ExternalAgents,
            types_2.ModuleName.Portfolio,
            types_2.ModuleName.Settlement,
            types_2.ModuleName.Statistics,
            types_2.ModuleName.Sto,
            types_2.ModuleName.Relayer,
        ].includes(moduleName);
    }
    /**
     * Retrieve the types of arguments that a certain transaction requires to be run
     *
     * @param args.tag - tag associated with the transaction that will be executed if the proposal passes
     */
    getTransactionArguments({ tag }) {
        const { 
        /*
         * we use the non-proxy polkadot instance since we shouldn't need to
         * have a signer Account for this method
         */
        _polymeshApi: { tx }, } = this;
        const [section, method] = tag.split('.');
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return tx[section][method].meta.args.map(({ name, type }) => {
            const typeDef = (0, types_1.getTypeDef)(type.toString());
            const argName = (0, conversion_1.textToString)(name);
            return (0, utils_1.processType)(typeDef, argName);
        });
    }
    /**
     * @hidden
     */
    getDividendDistributionsForAssets(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { polymeshApi: { query: { corporateAction: corporateActionQuery, capitalDistribution }, }, } = this;
            const { assets } = args;
            const distributionsMultiParams = [];
            const corporateActionParams = [];
            const corporateActionIds = [];
            const tickers = [];
            const assetChunks = (0, lodash_1.chunk)(assets, constants_1.MAX_CONCURRENT_REQUESTS);
            yield bluebird_1.default.each(assetChunks, (assetChunk) => __awaiter(this, void 0, void 0, function* () {
                const corporateActions = yield Promise.all(assetChunk.map(({ ticker }) => corporateActionQuery.corporateActions.entries((0, conversion_1.stringToTicker)(ticker, this))));
                const eligibleCas = (0, lodash_1.flatten)(corporateActions).filter(([, action]) => {
                    const kind = action.unwrap().kind;
                    return kind.isUnpredictableBenefit || kind.isPredictableBenefit;
                });
                const corporateActionData = yield bluebird_1.default.map(eligibleCas, ([{ args: [rawTicker, rawId], }, corporateAction,]) => __awaiter(this, void 0, void 0, function* () {
                    const localId = (0, conversion_1.u32ToBigNumber)(rawId);
                    const ticker = (0, conversion_1.tickerToString)(rawTicker);
                    const caId = (0, conversion_1.corporateActionIdentifierToCaId)({ ticker, localId }, this);
                    const details = yield corporateActionQuery.details(caId);
                    const action = corporateAction.unwrap();
                    return {
                        ticker,
                        localId,
                        caId,
                        corporateAction: (0, conversion_1.meshCorporateActionToCorporateActionParams)(action, details, this),
                    };
                }));
                corporateActionData.forEach(({ ticker, localId, caId, corporateAction }) => {
                    tickers.push(ticker);
                    corporateActionIds.push(localId);
                    distributionsMultiParams.push(caId);
                    corporateActionParams.push(corporateAction);
                });
            }));
            /*
             * Divide the requests to account for practical limits
             */
            const paramChunks = (0, lodash_1.chunk)(distributionsMultiParams, constants_1.MAX_PAGE_SIZE.toNumber());
            const requestChunks = (0, lodash_1.chunk)(paramChunks, constants_1.MAX_CONCURRENT_REQUESTS);
            const distributions = yield bluebird_1.default.mapSeries(requestChunks, requestChunk => Promise.all(requestChunk.map(paramChunk => capitalDistribution.distributions.multi(paramChunk))));
            const result = [];
            (0, lodash_1.flattenDeep)(distributions).forEach((distribution, index) => {
                if (distribution.isNone) {
                    return;
                }
                const dist = distribution.unwrap();
                const { reclaimed, remaining } = dist;
                result.push({
                    distribution: new internal_1.DividendDistribution(Object.assign(Object.assign({ ticker: tickers[index], id: corporateActionIds[index] }, corporateActionParams[index]), (0, conversion_1.distributionToDividendDistributionParams)(dist, this)), this),
                    details: {
                        remainingFunds: (0, conversion_1.balanceToBigNumber)(remaining),
                        fundsReclaimed: (0, conversion_1.boolToBoolean)(reclaimed),
                    },
                });
            });
            return result;
        });
    }
    /**
     * @hidden
     *
     * @note no claimTypes value means ALL claim types
     */
    getIdentityClaimsFromChain(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { polymeshApi: { query: { identity }, }, } = this;
            const { targets, claimTypes = Object.values(types_2.ClaimType), trustedClaimIssuers, includeExpired, } = args;
            const claim1stKeys = (0, lodash_1.flatMap)(targets, target => claimTypes.map(claimType => {
                return {
                    target: (0, conversion_1.signerToString)(target),
                    // eslint-disable-next-line @typescript-eslint/naming-convention
                    claim_type: (0, conversion_1.claimTypeToMeshClaimType)(claimType, this),
                };
            }));
            const claimIssuerDids = trustedClaimIssuers === null || trustedClaimIssuers === void 0 ? void 0 : trustedClaimIssuers.map(trustedClaimIssuer => (0, conversion_1.signerToString)(trustedClaimIssuer));
            const claimData = yield bluebird_1.default.map(claim1stKeys, (claim1stKey) => __awaiter(this, void 0, void 0, function* () {
                const entries = yield identity.claims.entries(claim1stKey);
                const data = [];
                entries.forEach(([key, optClaim]) => {
                    const { target } = key.args[0];
                    const { claimIssuer, issuanceDate, lastUpdateDate, expiry: rawExpiry, claim, } = optClaim.unwrap();
                    const expiry = !rawExpiry.isEmpty ? (0, conversion_1.momentToDate)(rawExpiry.unwrap()) : null;
                    if ((!includeExpired && (expiry === null || expiry > new Date())) || includeExpired) {
                        data.push({
                            target: new internal_1.Identity({ did: (0, conversion_1.identityIdToString)(target) }, this),
                            issuer: new internal_1.Identity({ did: (0, conversion_1.identityIdToString)(claimIssuer) }, this),
                            issuedAt: (0, conversion_1.momentToDate)(issuanceDate),
                            lastUpdatedAt: (0, conversion_1.momentToDate)(lastUpdateDate),
                            expiry,
                            claim: (0, conversion_1.meshClaimToClaim)(claim),
                        });
                    }
                });
                return data;
            }));
            return (0, lodash_1.flatten)(claimData).filter(({ issuer }) => claimIssuerDids ? claimIssuerDids.includes(issuer.did) : true);
        });
    }
    /**
     * @hidden
     */
    getIdentityClaimsFromMiddleware(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { targets, claimTypes, trustedClaimIssuers, includeExpired, size = new bignumber_js_1.default(constants_1.DEFAULT_GQL_PAGE_SIZE), start = new bignumber_js_1.default(0), } = args;
            const { data: { claims: { nodes: claimsList, totalCount }, }, } = yield this.queryMiddleware((0, queries_1.claimsQuery)({
                dids: targets === null || targets === void 0 ? void 0 : targets.map(target => (0, conversion_1.signerToString)(target)),
                trustedClaimIssuers: trustedClaimIssuers === null || trustedClaimIssuers === void 0 ? void 0 : trustedClaimIssuers.map(trustedClaimIssuer => (0, conversion_1.signerToString)(trustedClaimIssuer)),
                claimTypes: claimTypes === null || claimTypes === void 0 ? void 0 : claimTypes.map(ct => enums_1.ClaimTypeEnum[ct]),
                includeExpired,
            }, size, start));
            const count = new bignumber_js_1.default(totalCount);
            const data = claimsList.map(claim => (0, conversion_1.middlewareClaimToClaimData)(claim, this));
            const next = (0, internal_2.calculateNextKey)(count, data.length, start);
            return {
                data,
                next,
                count,
            };
        });
    }
    /**
     * @hidden
     *
     * Retrieve a list of claims. Can be filtered using parameters
     *
     * @param opts.targets - Identities (or Identity IDs) for which to fetch claims (targets). Defaults to all targets
     * @param opts.trustedClaimIssuers - Identity IDs of claim issuers. Defaults to all claim issuers
     * @param opts.claimTypes - types of the claims to fetch. Defaults to any type
     * @param opts.includeExpired - whether to include expired claims. Defaults to true
     * @param opts.size - page size
     * @param opts.start - page offset
     *
     * @note uses the middleware V2 (optional)
     */
    issuedClaims(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { targets, trustedClaimIssuers, claimTypes, includeExpired = true, size, start } = opts;
            const isMiddlewareAvailable = yield this.isMiddlewareAvailable();
            if (isMiddlewareAvailable) {
                return this.getIdentityClaimsFromMiddleware({
                    targets,
                    trustedClaimIssuers,
                    claimTypes,
                    includeExpired,
                    size,
                    start,
                });
            }
            if (!targets) {
                throw new internal_1.PolymeshError({
                    code: types_2.ErrorCode.MiddlewareError,
                    message: 'Cannot perform this action without an active middleware V2 connection',
                });
            }
            const identityClaimsFromChain = yield this.getIdentityClaimsFromChain({
                targets,
                claimTypes,
                trustedClaimIssuers,
                includeExpired,
            });
            return {
                data: identityClaimsFromChain,
                next: null,
                count: undefined,
            };
        });
    }
    /**
     * Retrieve the middleware client
     *
     * @throws if the middleware V2 is not enabled
     */
    get middlewareApi() {
        const { _middlewareApi: api } = this;
        if (!api) {
            throw new internal_1.PolymeshError({
                code: types_2.ErrorCode.MiddlewareError,
                message: 'Cannot perform this action without an active middleware v2 connection',
            });
        }
        return api;
    }
    /**
     * @hidden
     *
     * Make a query to the middleware V2 server using the apollo client
     */
    queryMiddleware(query) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                result = yield this.middlewareApi.query(query);
            }
            catch (err) {
                const resultMessage = (_b = (_a = err.networkError) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b.message;
                const { message: errorMessage } = err;
                const message = resultMessage !== null && resultMessage !== void 0 ? resultMessage : errorMessage;
                throw new internal_1.PolymeshError({
                    code: types_2.ErrorCode.MiddlewareError,
                    message: `Error in middleware V2 query: ${message}`,
                });
            }
            return result;
        });
    }
    /**
     * @hidden
     *
     * Return whether the middleware V2 was enabled at startup
     */
    isMiddlewareEnabled() {
        return !!this._middlewareApi;
    }
    /**
     * @hidden
     *
     * Return whether the middleware V2 is enabled and online
     */
    isMiddlewareAvailable() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.middlewareApi.query((0, queries_1.heartbeatQuery)());
            }
            catch (err) {
                return false;
            }
            return true;
        });
    }
    /**
     * @hidden
     *
     * Retrieve the number of the latest finalized block
     */
    getLatestBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            const { chain } = this.polymeshApi.rpc;
            /*
             * This is faster than calling `getFinalizedHead` and then `getHeader`.
             * We're promisifying a callback subscription to the latest finalized block
             * and unsubscribing as soon as we get the first result
             */
            const gettingHeader = new Promise((resolve, reject) => {
                const gettingUnsub = chain.subscribeFinalizedHeads(header => {
                    gettingUnsub
                        .then(unsub => {
                        unsub();
                        resolve(header);
                    })
                        .catch(err => reject(err));
                });
            });
            const { number } = yield gettingHeader;
            return (0, conversion_1.u32ToBigNumber)(number.unwrap());
        });
    }
    /**
     * @hidden
     *
     * Retrieve the network version
     */
    getNetworkVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const version = yield this.polymeshApi.rpc.system.version();
            return (0, conversion_1.textToString)(version);
        });
    }
    /**
     * @hidden
     *
     * Disconnect the Polkadot API, middleware, and render this instance unusable
     *
     * @note after disconnecting, trying to access any property in this object will result
     *   in an error
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            const { polymeshApi } = this;
            let middlewareApi;
            if (this.isMiddlewareEnabled()) {
                ({ middlewareApi } = this);
            }
            this.isDisconnected = true;
            if (middlewareApi) {
                middlewareApi.stop();
            }
            yield (0, internal_2.delay)(500); // allow pending requests to complete
            return polymeshApi.disconnect();
        });
    }
    /**
     * @hidden
     *
     * Returns a (shallow) clone of this instance. Useful for providing a separate
     *   Context to Procedures with different signing Accounts
     */
    clone() {
        return (0, lodash_1.clone)(this);
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    /**
     *  @hidden
     *
     * Creates an instance of a type as registered in the polymeshApi instance
     */
    createType(type, params) {
        try {
            return this.polymeshApi.createType(type, params);
        }
        catch (error) {
            throw new internal_1.PolymeshError({
                code: types_2.ErrorCode.UnexpectedError,
                message: `Could not create internal Polymesh type: "${type}". Please report this error to the Polymesh team`,
                data: { type, params, error },
            });
        }
    }
    /**
     * @hidden
     *
     * Set the nonce value
     */
    setNonce(nonce) {
        this.nonce = nonce;
    }
    /**
     * @hidden
     *
     * Retrieve the nonce value
     */
    getNonce() {
        // nonce: -1 takes pending transactions into consideration.
        // More information can be found at: https://polkadot.js.org/docs/api/cookbook/tx/#how-do-i-take-the-pending-tx-pool-into-account-in-my-nonce
        return new bignumber_js_1.default(this.nonce || -1);
    }
    /**
     * Retrieve middleware metadata.
     * Returns null if middleware V2 is disabled
     *
     * @note uses the middleware V2
     */
    getMiddlewareMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isMiddlewareEnabled()) {
                return null;
            }
            const { data: { _metadata: { chain, specName, genesisHash, targetHeight, lastProcessedHeight, lastProcessedTimestamp, indexerHealthy, }, }, } = yield this.queryMiddleware((0, queries_1.metadataQuery)());
            /* eslint-disable @typescript-eslint/no-non-null-assertion */
            return {
                chain: chain,
                specName: specName,
                genesisHash: genesisHash,
                targetHeight: new bignumber_js_1.default(targetHeight),
                lastProcessedHeight: new bignumber_js_1.default(lastProcessedHeight),
                lastProcessedTimestamp: new Date(parseInt(lastProcessedTimestamp)),
                indexerHealthy: Boolean(indexerHealthy),
            };
            /* eslint-enable @typescript-eslint/no-non-null-assertion */
        });
    }
    /**
     * @hidden
     *
     * Retrieve POLYX transactions for a given identity or list of accounts
     *
     * @note uses the middleware V2
     */
    getPolyxTransactions(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { identity, accounts, size = new bignumber_js_1.default(constants_1.DEFAULT_GQL_PAGE_SIZE), start = new bignumber_js_1.default(0), } = args;
            const { data: { polyxTransactions: { nodes: transactions, totalCount }, }, } = yield this.queryMiddleware((0, queries_1.polyxTransactionsQuery)({
                identityId: identity ? (0, internal_2.asDid)(identity) : undefined,
                addresses: accounts === null || accounts === void 0 ? void 0 : accounts.map(account => (0, conversion_1.signerToString)(account)),
            }, size, start));
            const count = new bignumber_js_1.default(totalCount);
            const data = transactions.map(transaction => {
                const { identityId, address, toId, toAddress, amount, type, memo, createdBlock, callId, eventId, moduleId, extrinsic, eventIdx, } = transaction;
                /* eslint-disable @typescript-eslint/no-non-null-assertion */
                return Object.assign(Object.assign({ fromIdentity: identityId ? new internal_1.Identity({ did: identityId }, this) : undefined, fromAccount: address ? new internal_1.Account({ address }, this) : undefined, toIdentity: toId ? new internal_1.Identity({ did: toId }, this) : undefined, toAccount: toAddress ? new internal_1.Account({ address: toAddress }, this) : undefined, amount: new bignumber_js_1.default(amount).shiftedBy(-6), type,
                    memo }, (0, conversion_1.middlewareEventDetailsToEventIdentifier)(createdBlock, eventIdx)), { callId, eventId: eventId, moduleId: moduleId, extrinsicIdx: extrinsic ? new bignumber_js_1.default(extrinsic.extrinsicIdx) : undefined });
                /* eslint-enable @typescript-eslint/no-non-null-assertion */
            });
            const next = (0, internal_2.calculateNextKey)(count, data.length, start);
            return {
                data,
                next,
                count,
            };
        });
    }
}
exports.Context = Context;
//# sourceMappingURL=Context.js.map