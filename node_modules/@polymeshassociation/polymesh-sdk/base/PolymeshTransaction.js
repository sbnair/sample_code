"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolymeshTransaction = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const internal_1 = require("../internal");
const types_1 = require("../types");
const conversion_1 = require("../utils/conversion");
/**
 * Wrapper class for a Polymesh Transaction
 */
class PolymeshTransaction extends internal_1.PolymeshTransactionBase {
    /**
     * @hidden
     */
    constructor(transactionSpec, context) {
        const { args = [], feeMultiplier, transaction, fee, paidForBy } = transactionSpec, rest = __rest(transactionSpec, ["args", "feeMultiplier", "transaction", "fee", "paidForBy"]);
        super(rest, context);
        this.args = args;
        this.transaction = transaction;
        this.tag = (0, conversion_1.transactionToTxTag)(transaction);
        this.feeMultiplier = feeMultiplier;
        this.protocolFee = fee;
        this.paidForBy = paidForBy;
    }
    /**
     * @hidden
     */
    static toTransactionSpec(inputTransaction) {
        const spec = internal_1.PolymeshTransactionBase.toTransactionSpec(inputTransaction);
        const { transaction, args, protocolFee: fee, feeMultiplier } = inputTransaction;
        return Object.assign(Object.assign({}, spec), { transaction,
            args,
            fee,
            feeMultiplier });
    }
    // eslint-disable-next-line require-jsdoc
    composeTx() {
        const { transaction, args } = this;
        return transaction(...args);
    }
    // eslint-disable-next-line require-jsdoc
    getProtocolFees() {
        return __awaiter(this, void 0, void 0, function* () {
            const { protocolFee, feeMultiplier = new bignumber_js_1.default(1) } = this;
            let fees = protocolFee;
            if (!fees) {
                const { tag } = this;
                [{ fees }] = yield this.context.getProtocolFees({ tags: [tag] });
            }
            return fees.multipliedBy(feeMultiplier);
        });
    }
    // eslint-disable-next-line require-jsdoc
    ignoresSubsidy() {
        /*
         * this is the only extrinsic so far that always has to be
         *   paid by the caller
         */
        return this.tag === types_1.TxTags.relayer.RemovePayingKey;
    }
    // eslint-disable-next-line require-jsdoc
    supportsSubsidy() {
        const { tag, context } = this;
        return context.supportsSubsidy({ tag });
    }
}
exports.PolymeshTransaction = PolymeshTransaction;
//# sourceMappingURL=PolymeshTransaction.js.map