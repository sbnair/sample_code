"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolymeshTransactionBase = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bluebird_1 = __importDefault(require("bluebird"));
const events_1 = require("events");
const lodash_1 = require("lodash");
const internal_1 = require("../internal");
const queries_1 = require("../middleware/queries");
const types_1 = require("../types");
const internal_2 = require("../types/internal");
const conversion_1 = require("../utils/conversion");
const internal_3 = require("../utils/internal");
/**
 * @hidden
 */
var Event;
(function (Event) {
    Event["StatusChange"] = "StatusChange";
    Event["ProcessedByMiddleware"] = "ProcessedByMiddleware";
})(Event || (Event = {}));
/**
 * Wrapper class for a Polymesh Transaction
 */
class PolymeshTransactionBase {
    /**
     * @hidden
     */
    constructor(transactionSpec, context) {
        /**
         * current status of the transaction
         */
        this.status = types_1.TransactionStatus.Idle;
        /**
         * @hidden
         *
         * internal event emitter to handle status changes
         */
        this.emitter = new events_1.EventEmitter();
        /**
         * @hidden
         * whether the queue has run or not (prevents re-running)
         */
        this.hasRun = false;
        const { resolver, transformer, signingAddress, signer, paidForBy, mortality } = transactionSpec;
        this.signingAddress = signingAddress;
        this.mortality = mortality;
        this.signer = signer;
        this.context = context;
        this.paidForBy = paidForBy;
        this.transformer = transformer;
        this.resolver = resolver;
    }
    /**
     * @hidden
     */
    static toTransactionSpec(transaction) {
        const { resolver, transformer, paidForBy } = transaction;
        return {
            resolver,
            transformer,
            paidForBy,
        };
    }
    /**
     * Run the transaction, update its status and return a result if applicable.
     *   Certain transactions create Entities on the blockchain, and those Entities are returned
     *   for convenience. For example, when running a transaction that creates an Asset, the Asset itself
     *   is returned
     */
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.hasRun) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.General,
                    message: 'Cannot re-run a Transaction',
                });
            }
            try {
                yield this.assertFeesCovered();
                const receipt = yield this.internalRun();
                this.receipt = receipt;
                const { resolver, transformer = (val) => __awaiter(this, void 0, void 0, function* () { return val; }), } = this;
                let value;
                if ((0, internal_2.isResolverFunction)(resolver)) {
                    value = yield resolver(receipt);
                }
                else {
                    value = resolver;
                }
                this._result = yield transformer(value);
                this.updateStatus(types_1.TransactionStatus.Succeeded);
                return this._result;
            }
            catch (err) {
                const error = err;
                this.error = err;
                switch (error.code) {
                    case types_1.ErrorCode.TransactionAborted: {
                        this.updateStatus(types_1.TransactionStatus.Aborted);
                        break;
                    }
                    case types_1.ErrorCode.TransactionRejectedByUser: {
                        this.updateStatus(types_1.TransactionStatus.Rejected);
                        break;
                    }
                    case types_1.ErrorCode.TransactionReverted:
                    case types_1.ErrorCode.FatalError:
                    default: {
                        this.updateStatus(types_1.TransactionStatus.Failed);
                        break;
                    }
                }
                throw error;
            }
            finally {
                this.hasRun = true;
                /*
                 * We do not await this promise because it is supposed to run in the background, and
                 * any errors encountered are emitted. If the user isn't listening, they shouldn't
                 * care about middleware (or other) errors anyway
                 */
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.emitWhenMiddlewareIsSynced();
            }
        });
    }
    /**
     * @hidden
     *
     * Execute the underlying transaction, updating the status where applicable and
     *   throwing any pertinent errors
     */
    internalRun() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { signingAddress, signer, mortality, context } = this;
            // era is how many blocks the transaction remains valid for, `undefined` for default
            const era = mortality.immortal ? 0 : (_a = mortality.lifetime) === null || _a === void 0 ? void 0 : _a.toNumber();
            const nonce = context.getNonce().toNumber();
            this.updateStatus(types_1.TransactionStatus.Unapproved);
            return new Promise((resolve, reject) => {
                const txWithArgs = this.composeTx();
                let settingBlockData = Promise.resolve();
                const gettingUnsub = txWithArgs.signAndSend(signingAddress, { nonce, signer, era }, receipt => {
                    const { status } = receipt;
                    let isLastCallback = false;
                    let unsubscribing = Promise.resolve();
                    let extrinsicFailedEvent;
                    // isCompleted implies status is one of: isFinalized, isInBlock or isError
                    if (receipt.isCompleted) {
                        if (receipt.isInBlock) {
                            const inBlockHash = status.asInBlock;
                            /*
                             * this must be done to ensure that the block hash and number are set before the success event
                             *   is emitted, and at the same time. We do not resolve or reject the containing promise until this
                             *   one resolves
                             */
                            settingBlockData = (0, internal_3.defusePromise)(this.context.polymeshApi.rpc.chain.getBlock(inBlockHash).then(({ block }) => {
                                this.blockHash = (0, conversion_1.hashToString)(inBlockHash);
                                this.blockNumber = (0, conversion_1.u32ToBigNumber)(block.header.number.unwrap());
                                // we know that the index has to be set by the time the transaction is included in a block
                                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                this.txIndex = new bignumber_js_1.default(receipt.txIndex);
                            }));
                            // if the extrinsic failed due to an on-chain error, we should handle it in a special way
                            [extrinsicFailedEvent] = (0, internal_3.filterEventRecords)(receipt, 'system', 'ExtrinsicFailed', true);
                            // extrinsic failed so we can unsubscribe
                            isLastCallback = !!extrinsicFailedEvent;
                        }
                        else {
                            // isFinalized || isError so we know we can unsubscribe
                            isLastCallback = true;
                        }
                        if (isLastCallback) {
                            unsubscribing = gettingUnsub.then(unsub => {
                                unsub();
                            });
                        }
                        /*
                         * Promise chain that handles all sub-promises in this pass through the signAndSend callback.
                         * Primarily for consistent error handling
                         */
                        let finishing = Promise.resolve();
                        if (extrinsicFailedEvent) {
                            const { data } = extrinsicFailedEvent;
                            finishing = Promise.all([settingBlockData, unsubscribing]).then(() => {
                                this.handleExtrinsicFailure(resolve, reject, data[0]);
                            });
                        }
                        else if (receipt.isFinalized) {
                            finishing = Promise.all([settingBlockData, unsubscribing]).then(() => {
                                this.handleExtrinsicSuccess(resolve, reject, receipt);
                            });
                        }
                        else if (receipt.isError) {
                            reject(new internal_1.PolymeshError({ code: types_1.ErrorCode.TransactionAborted }));
                        }
                        finishing.catch((err) => reject(err));
                    }
                });
                gettingUnsub
                    .then(() => {
                    // tx approved by signer
                    this.txHash = txWithArgs.hash.toString();
                    this.updateStatus(types_1.TransactionStatus.Running);
                })
                    .catch((err) => {
                    let error;
                    /* istanbul ignore else */
                    if (err.message.indexOf('Cancelled') > -1) {
                        // tx rejected by signer
                        error = { code: types_1.ErrorCode.TransactionRejectedByUser };
                    }
                    else {
                        // unexpected error
                        error = { code: types_1.ErrorCode.UnexpectedError, message: err.message };
                    }
                    reject(new internal_1.PolymeshError(error));
                });
            });
        });
    }
    /**
     * Subscribe to status changes
     *
     * @param listener - callback function that will be called whenever the status changes
     *
     * @returns unsubscribe function
     */
    onStatusChange(listener) {
        const { emitter } = this;
        emitter.on(Event.StatusChange, listener);
        return () => {
            emitter.removeListener(Event.StatusChange, listener);
        };
    }
    /**
     * Retrieve a breakdown of the fees required to run this transaction, as well as the Account responsible for paying them
     *
     * @note these values might be inaccurate if the transaction is run at a later time. This can be due to a governance vote or other
     *   chain related factors (like modifications to a specific subsidizer relationship or a chain upgrade)
     */
    getTotalFees() {
        return __awaiter(this, void 0, void 0, function* () {
            const { signingAddress } = this;
            const composedTx = this.composeTx();
            const paymentInfoPromise = composedTx.paymentInfo(signingAddress);
            const protocol = yield this.getProtocolFees();
            const [payingAccount, { partialFee }] = yield Promise.all([
                this.getPayingAccount(),
                paymentInfoPromise,
            ]);
            const { free: balance } = yield payingAccount.account.getBalance();
            const gas = (0, conversion_1.balanceToBigNumber)(partialFee);
            return {
                fees: {
                    protocol,
                    gas,
                    total: protocol.plus(gas),
                },
                payingAccountData: Object.assign(Object.assign({}, payingAccount), { balance }),
            };
        });
    }
    /**
     * Subscribe to the results of this transaction being processed by the indexing service (and as such, available to the middleware)
     *
     * @param listener - callback function that will be called whenever the middleware is updated with the latest data.
     *   If there is an error (timeout or middleware offline) it will be passed to this callback
     *
     * @note this event will be fired even if the queue fails
     * @returns unsubscribe function
     * @throws if the middleware wasn't enabled when instantiating the SDK client
     */
    onProcessedByMiddleware(listener) {
        const { context, emitter } = this;
        if (!context.isMiddlewareEnabled()) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.General,
                message: 'Cannot subscribe without an enabled middleware connection',
            });
        }
        emitter.on(Event.ProcessedByMiddleware, listener);
        return () => {
            emitter.removeListener(Event.ProcessedByMiddleware, listener);
        };
    }
    /**
     * Get the latest processed block from the database
     *
     * @note uses the middleware
     */
    getLatestBlockFromMiddleware() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const { data: { blocks: { nodes: [{ blockId: processedBlock }], }, }, } = yield context.queryMiddleware((0, queries_1.latestBlockQuery)());
            return new bignumber_js_1.default(processedBlock);
        });
    }
    /**
     * Poll the middleware every 2 seconds to see if it has already processed the
     *   block that reflects the changes brought on by this transaction being run. If so,
     *   emit the corresponding event. After 5 retries (or if the middleware can't be reached),
     *   the event is emitted with an error
     *
     * @note uses the middleware
     */
    emitWhenMiddlewareIsSynced() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context, emitter } = this;
            try {
                if (!context.isMiddlewareEnabled()) {
                    return;
                }
                const blockNumber = yield context.getLatestBlock();
                let done = false;
                yield bluebird_1.default.each((0, lodash_1.range)(6), (i) => __awaiter(this, void 0, void 0, function* () {
                    if (done) {
                        return;
                    }
                    try {
                        const processedBlock = yield this.getLatestBlockFromMiddleware();
                        if (blockNumber.lte(processedBlock)) {
                            done = true;
                            emitter.emit(Event.ProcessedByMiddleware);
                            return;
                        }
                    }
                    catch (err) {
                        /*
                         * query errors are swallowed because we wish to query again if we haven't reached the
                         * maximum amount of retries
                         */
                    }
                    if (i === 5) {
                        emitter.emit(Event.ProcessedByMiddleware, new internal_1.PolymeshError({
                            code: types_1.ErrorCode.MiddlewareError,
                            message: `Middleware has not synced after ${i} attempts`,
                        }));
                    }
                    return (0, internal_3.delay)(2000);
                }));
            }
            catch (err) {
                /* istanbul ignore next: extreme edge case */
                emitter.emit(Event.ProcessedByMiddleware, new internal_1.PolymeshError({
                    code: types_1.ErrorCode.UnexpectedError,
                    message: err.message || 'Unexpected error',
                }));
            }
        });
    }
    /**
     * @hidden
     */
    updateStatus(status) {
        const { emitter } = this;
        this.status = status;
        /* eslint-disable default-case */
        switch (status) {
            case types_1.TransactionStatus.Unapproved:
            case types_1.TransactionStatus.Running:
            case types_1.TransactionStatus.Succeeded: {
                emitter.emit(Event.StatusChange, this);
                return;
            }
            case types_1.TransactionStatus.Rejected:
            case types_1.TransactionStatus.Aborted:
            case types_1.TransactionStatus.Failed: {
                emitter.emit(Event.StatusChange, this, this.error);
            }
        }
        /* eslint-enable default-case */
    }
    /* istanbul ignore next: there is no way of reaching this path currently */
    /**
     * @hidden
     *
     * Return whether the transaction ignores any existing subsidizer relationships
     *   and is always paid by the caller
     */
    ignoresSubsidy() {
        /*
         * since we don't know anything about the transaction, a safe default is
         *   to assume it doesn't ignore subsidies
         */
        return false;
    }
    /**
     * @hidden
     */
    handleExtrinsicFailure(_resolve, reject, error, data) {
        // get revert message from event
        let message;
        if (error.isModule) {
            // known error
            const mod = error.asModule;
            const { section, name, docs } = mod.registry.findMetaError(mod);
            message = `${section}.${name}: ${docs.join(' ')}`;
        }
        else if (error.isBadOrigin) {
            message = 'Bad origin';
        }
        else if (error.isCannotLookup) {
            message = 'Could not lookup information required to validate the transaction';
        }
        else {
            message = 'Unknown error';
        }
        reject(new internal_1.PolymeshError({ code: types_1.ErrorCode.TransactionReverted, message, data }));
    }
    /**
     * @hidden
     */
    handleExtrinsicSuccess(resolve, _reject, receipt) {
        resolve(receipt);
    }
    /**
     * @hidden
     *
     * Check if balances and allowances (both third party and signing Account)
     *   are sufficient to cover this transaction's fees
     */
    assertFeesCovered() {
        return __awaiter(this, void 0, void 0, function* () {
            const { fees: { total }, payingAccountData, } = yield this.getTotalFees();
            const { type, balance } = payingAccountData;
            if (type === types_1.PayingAccountType.Subsidy) {
                const { allowance } = payingAccountData;
                if (!this.supportsSubsidy()) {
                    throw new internal_1.PolymeshError({
                        code: types_1.ErrorCode.UnmetPrerequisite,
                        message: 'This transaction cannot be run by a subsidized Account',
                    });
                }
                if (allowance.lt(total)) {
                    throw new internal_1.PolymeshError({
                        code: types_1.ErrorCode.UnmetPrerequisite,
                        message: "Insufficient subsidy allowance to pay this transaction's fees",
                        data: {
                            allowance,
                            fees: total,
                        },
                    });
                }
            }
            const accountDescriptions = {
                [types_1.PayingAccountType.Caller]: 'caller',
                [types_1.PayingAccountType.Other]: 'paying third party',
                [types_1.PayingAccountType.Subsidy]: 'subsidizer',
            };
            if (balance.lt(total)) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.InsufficientBalance,
                    message: `The ${accountDescriptions[type]} Account does not have enough POLYX balance to pay this transaction's fees`,
                    data: {
                        balance,
                        fees: total,
                    },
                });
            }
        });
    }
    /**
     * returns the transaction result - this is the same value as the Promise run returns
     * @note it is generally preferable to `await` the `Promise` returned by { @link base/PolymeshTransactionBase!PolymeshTransactionBase.run | transaction.run() } instead of reading this property
     *
     * @throws if the { @link base/PolymeshTransactionBase!PolymeshTransactionBase.isSuccess | transaction.isSuccess } property is false â€” be sure to check that before accessing!
     */
    get result() {
        if (this.isSuccess) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this._result;
        }
        else {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.General,
                message: 'The result of the transaction was checked before it has been completed. property `result` should only be read if transaction `isSuccess` property is true',
            });
        }
    }
    /**
     * returns true if transaction has completed successfully
     */
    get isSuccess() {
        return this.status === types_1.TransactionStatus.Succeeded;
    }
    /**
     * @hidden
     *
     * Retrieve the Account that would pay fees for the transaction if it was run at this moment, as well as the total amount that can be
     *   charged to it (allowance) in case of a subsidy
     *
     * @note the paying Account might change if, before running the transaction, the caller Account enters (or leaves)
     *   a subsidizer relationship. A governance vote or chain upgrade could also cause the value to change between the time
     *   this method is called and the time the transaction is run
     */
    getPayingAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            const { paidForBy, context } = this;
            if (paidForBy) {
                const { account: primaryAccount } = yield paidForBy.getPrimaryAccount();
                return {
                    type: types_1.PayingAccountType.Other,
                    account: primaryAccount,
                };
            }
            const subsidyWithAllowance = yield context.accountSubsidy();
            if (!subsidyWithAllowance || this.ignoresSubsidy()) {
                const caller = context.getSigningAccount();
                return {
                    account: caller,
                    type: types_1.PayingAccountType.Caller,
                };
            }
            const { subsidy: { subsidizer: account }, allowance, } = subsidyWithAllowance;
            return {
                type: types_1.PayingAccountType.Subsidy,
                account,
                allowance,
            };
        });
    }
}
exports.PolymeshTransactionBase = PolymeshTransactionBase;
//# sourceMappingURL=PolymeshTransactionBase.js.map