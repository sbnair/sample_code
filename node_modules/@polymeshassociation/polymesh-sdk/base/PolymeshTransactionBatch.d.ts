import { SubmittableExtrinsic } from '@polkadot/api/types';
import { ISubmittableResult } from '@polkadot/types/types';
import BigNumber from 'bignumber.js';
import { Context, PolymeshTransaction, PolymeshTransactionBase } from "../internal";
import { MapTxData } from "../types";
import { BatchTransactionSpec, TransactionConstructionData } from "../types/internal";
/**
 * Wrapper class for a batch of Polymesh Transactions
 */
export declare class PolymeshTransactionBatch<ReturnValue, TransformedReturnValue = ReturnValue, Args extends unknown[][] = unknown[][]> extends PolymeshTransactionBase<ReturnValue, TransformedReturnValue> {
    /**
     * @hidden
     */
    static toTransactionSpec<R, A extends unknown[][], T>(inputTransaction: PolymeshTransactionBatch<R, T, A>): BatchTransactionSpec<R, A, T>;
    /**
     * @hidden
     *
     * underlying transactions to be batched, together with their arguments and other relevant data
     */
    private transactionData;
    /**
     * @hidden
     */
    constructor(transactionSpec: BatchTransactionSpec<ReturnValue, Args, TransformedReturnValue> & TransactionConstructionData, context: Context);
    /**
     * transactions in the batch with their respective arguments
     */
    get transactions(): MapTxData<Args>;
    /**
     * @hidden
     */
    protected composeTx(): SubmittableExtrinsic<'promise', ISubmittableResult>;
    /**
     * @hidden
     */
    getProtocolFees(): Promise<BigNumber>;
    /**
     * @note batches can't be subsidized. If the caller is subsidized, they should use `splitTransactions` and
     *   run each transaction separately
     */
    supportsSubsidy(): boolean;
    /**
     * Splits this batch into its individual transactions to be run separately. This is useful if the caller is being subsidized,
     *   since batches cannot be run by subsidized Accounts
     *
     * @note the transactions returned by this method must be run in the same order they appear in the array to guarantee the same behavior. If run out of order,
     *   an error will be thrown. The result that would be obtained by running the batch is returned by running the last transaction in the array
     *
     * @example
     *
     * ```typescript
     * const createAssetTx = await sdk.assets.createAsset(...);
     *
     * let ticker: string;
     *
     * if (isPolymeshTransactionBatch<Asset>(createAssetTx)) {
     *   const transactions = createAssetTx.splitTransactions();
     *
     *   for (let i = 0; i < length; i += 1) {
     *     const result = await transactions[i].run();
     *
     *     if (isAsset(result)) {
     *       ({ticker} = result)
     *     }
     *   }
     * } else {
     *   ({ ticker } = await createAssetTx.run());
     * }
     *
     * console.log(`New Asset created! Ticker: ${ticker}`);
     * ```
     */
    splitTransactions(): (PolymeshTransaction<void> | PolymeshTransaction<ReturnValue, TransformedReturnValue>)[];
    /**
     * @hidden
     */
    protected handleExtrinsicSuccess(resolve: (value: ISubmittableResult | PromiseLike<ISubmittableResult>) => void, reject: (reason?: unknown) => void, receipt: ISubmittableResult): void;
}
//# sourceMappingURL=PolymeshTransactionBatch.d.ts.map