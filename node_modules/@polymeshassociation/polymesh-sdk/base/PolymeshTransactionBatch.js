"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolymeshTransactionBatch = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bluebird_1 = __importDefault(require("bluebird"));
const internal_1 = require("../internal");
const types_1 = require("../types");
const internal_2 = require("../types/internal");
const conversion_1 = require("../utils/conversion");
const internal_3 = require("../utils/internal");
/**
 * Wrapper class for a batch of Polymesh Transactions
 */
class PolymeshTransactionBatch extends internal_1.PolymeshTransactionBase {
    /**
     * @hidden
     */
    constructor(transactionSpec, context) {
        const { transactions } = transactionSpec, rest = __rest(transactionSpec, ["transactions"]);
        super(rest, context);
        this.transactionData = transactions.map(({ transaction, args, feeMultiplier, fee }) => ({
            tag: (0, conversion_1.transactionToTxTag)(transaction),
            args,
            feeMultiplier,
            transaction,
            fee,
        }));
    }
    /**
     * @hidden
     */
    static toTransactionSpec(inputTransaction) {
        const spec = internal_1.PolymeshTransactionBase.toTransactionSpec(inputTransaction);
        const { transactionData } = inputTransaction;
        return Object.assign(Object.assign({}, spec), { transactions: transactionData.map(({ transaction, args, fee, feeMultiplier }) => ({
                transaction,
                args,
                fee,
                feeMultiplier,
            })) });
    }
    /**
     * transactions in the batch with their respective arguments
     */
    get transactions() {
        return this.transactionData.map(({ tag, args }) => ({
            tag,
            args,
        }));
    }
    /**
     * @hidden
     */
    composeTx() {
        const { context: { polymeshApi: { tx: { utility }, }, }, } = this;
        return utility.batchAll(this.transactionData.map(({ transaction, args }) => transaction(...args)));
    }
    /**
     * @hidden
     */
    getProtocolFees() {
        return bluebird_1.default.reduce(this.transactionData, (total, { tag, feeMultiplier = new bignumber_js_1.default(1), fee }) => __awaiter(this, void 0, void 0, function* () {
            let fees = fee;
            if (!fees) {
                [{ fees }] = yield this.context.getProtocolFees({ tags: [tag] });
            }
            return total.plus(fees.multipliedBy(feeMultiplier));
        }), new bignumber_js_1.default(0));
    }
    /**
     * @note batches can't be subsidized. If the caller is subsidized, they should use `splitTransactions` and
     *   run each transaction separately
     */
    supportsSubsidy() {
        return false;
    }
    /**
     * Splits this batch into its individual transactions to be run separately. This is useful if the caller is being subsidized,
     *   since batches cannot be run by subsidized Accounts
     *
     * @note the transactions returned by this method must be run in the same order they appear in the array to guarantee the same behavior. If run out of order,
     *   an error will be thrown. The result that would be obtained by running the batch is returned by running the last transaction in the array
     *
     * @example
     *
     * ```typescript
     * const createAssetTx = await sdk.assets.createAsset(...);
     *
     * let ticker: string;
     *
     * if (isPolymeshTransactionBatch<Asset>(createAssetTx)) {
     *   const transactions = createAssetTx.splitTransactions();
     *
     *   for (let i = 0; i < length; i += 1) {
     *     const result = await transactions[i].run();
     *
     *     if (isAsset(result)) {
     *       ({ticker} = result)
     *     }
     *   }
     * } else {
     *   ({ ticker } = await createAssetTx.run());
     * }
     *
     * console.log(`New Asset created! Ticker: ${ticker}`);
     * ```
     */
    splitTransactions() {
        const { signingAddress, signer, mortality, context } = this;
        const { transactions, resolver, transformer } = PolymeshTransactionBatch.toTransactionSpec(this);
        const receipts = [];
        const processedIndexes = [];
        return transactions.map(({ transaction, args }, index) => {
            const isLast = index === transactions.length - 1;
            const spec = {
                signer,
                signingAddress,
                transaction,
                args,
                mortality,
            };
            let newTransaction;
            /*
             * the last transaction's resolver will pass the merged receipt with all events to the batch's original resolver.
             *   Other transactions will just add their receipts to the list to be merged
             */
            if (isLast) {
                newTransaction = new internal_1.PolymeshTransaction(Object.assign(Object.assign({}, spec), { resolver: (receipt) => {
                        if ((0, internal_2.isResolverFunction)(resolver)) {
                            return resolver((0, internal_3.mergeReceipts)([...receipts, receipt], context));
                        }
                        return resolver;
                    }, transformer }), context);
            }
            else {
                newTransaction = new internal_1.PolymeshTransaction(Object.assign(Object.assign({}, spec), { resolver: (receipt) => {
                        processedIndexes.push(index);
                        receipts.push(receipt);
                    } }), context);
            }
            const originalRun = newTransaction.run.bind(newTransaction);
            newTransaction.run = (() => {
                const expectedIndex = index - 1;
                // we throw an error if the transactions aren't being run in order
                if (expectedIndex >= 0 && processedIndexes[expectedIndex] !== expectedIndex) {
                    throw new internal_1.PolymeshError({
                        code: types_1.ErrorCode.General,
                        message: 'Transactions resulting from splitting a batch must be run in order',
                    });
                }
                return originalRun();
            });
            return newTransaction;
        });
    }
    /**
     * @hidden
     */
    handleExtrinsicSuccess(resolve, reject, receipt) {
        // If one of the transactions in the batch fails, this event gets emitted
        const [failed] = (0, internal_3.filterEventRecords)(receipt, 'utility', 'BatchInterrupted', true);
        if (failed) {
            const { data: [, failedData], } = failed;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const failedIndex = (0, conversion_1.u32ToBigNumber)(failedData[0]).toNumber();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const dispatchError = failedData[1];
            this.handleExtrinsicFailure(resolve, reject, dispatchError, { failedIndex });
        }
        else {
            resolve(receipt);
        }
    }
}
exports.PolymeshTransactionBatch = PolymeshTransactionBatch;
//# sourceMappingURL=PolymeshTransactionBatch.js.map