import { Context } from "../internal";
import { GenericPolymeshTransaction, ProcedureAuthorizationStatus, ProcedureOpts } from "../types";
import { BaseTransactionSpec, ProcedureAuthorization } from "../types/internal";
/**
 * @hidden
 *
 * Represents an operation performed on the Polymesh blockchain.
 * A Procedure can be prepared to return a promise that resolves
 * to a {@link PolymeshTransaction} (or {@link PolymeshTransactionBatch}) that can be run
 */
export declare class Procedure<Args = void, ReturnValue = void, Storage = Record<string, unknown>> {
    private prepareTransactions;
    private getAuthorization;
    private prepareStorage;
    private _storage;
    private _context;
    /**
     * @hidden
     *
     * @param prepareTransactions - function that prepares the transaction queue
     * @param getAuthorization - can be a ProcedureAuthorization object or a function that returns a ProcedureAuthorization object
     */
    constructor(prepareTransactions: (this: Procedure<Args, ReturnValue, Storage>, args: Args) => Promise<BaseTransactionSpec<ReturnValue>>, getAuthorization?: ProcedureAuthorization | ((this: Procedure<Args, ReturnValue, Storage>, args: Args) => Promise<ProcedureAuthorization> | ProcedureAuthorization), prepareStorage?: (this: Procedure<Args, ReturnValue, Storage>, args: Args) => Promise<Storage> | Storage);
    /**
     * @hidden
     * Set the context and storage (if not already set), return the Context
     */
    private setup;
    /**
     * @hidden
     * Reset the procedure
     */
    private cleanup;
    /**
     * @hidden
     */
    private _checkAuthorization;
    /**
     * Check if the current user has sufficient authorization to run the procedure
     *
     * @param args - procedure arguments
     */
    checkAuthorization(args: Args, context: Context, opts?: ProcedureOpts): Promise<ProcedureAuthorizationStatus>;
    /**
     * Build a {@link PolymeshTransaction} or {@link PolymeshTransactionBatch} that can be run
     *
     * @param args.args - arguments required to prepare the queue
     * @param args.transformer - optional function that transforms the Procedure result
     * @param context - context in which the resulting queue will run
     * @param opts.signer - address that will be used as a signer for this procedure
     */
    prepare<TransformedReturnValue>(args: {
        args: Args;
        transformer?: (value: ReturnValue) => TransformedReturnValue | Promise<TransformedReturnValue>;
    }, context: Context, opts?: ProcedureOpts): Promise<GenericPolymeshTransaction<ReturnValue, TransformedReturnValue>>;
    /**
     * internal data container. Used to store common fetched/processed data that is
     *   used by both `prepareTransactions` and `checkAuthorization`
     */
    get storage(): Storage;
    /**
     * contains the data services, signing Account, etc. In short, the *context* in which
     *   the Procedure is being run
     */
    get context(): Context;
}
//# sourceMappingURL=Procedure.d.ts.map