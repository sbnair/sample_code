"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processType = void 0;
const types_1 = require("@polkadot/types");
const types_2 = require("@polkadot/types/types");
const definitions_1 = require("../polkadot/definitions");
const types_3 = require("../types");
const constants_1 = require("../utils/constants");
const { types } = definitions_1.polymesh;
const getRootType = (type) => {
    const rootType = constants_1.ROOT_TYPES[type];
    if (rootType) {
        return {
            type: rootType,
        };
    }
    if (type === 'Null') {
        return {
            type: types_3.TransactionArgumentType.Null,
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const definition = types[type];
    if (!definition) {
        return {
            type: types_3.TransactionArgumentType.Unknown,
        };
    }
    const typeDef = (0, types_1.getTypeDef)(JSON.stringify(definition));
    if (typeDef.info === types_2.TypeDefInfo.Plain) {
        return getRootType(definition);
    }
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return (0, exports.processType)(typeDef, '');
};
const processType = (rawType, name) => {
    const { type, info, sub } = rawType;
    const arg = {
        name,
        optional: false,
        _rawType: rawType,
    };
    switch (info) {
        case types_2.TypeDefInfo.Plain: {
            return Object.assign(Object.assign({}, getRootType(type)), arg);
        }
        case types_2.TypeDefInfo.Compact: {
            return Object.assign(Object.assign({}, (0, exports.processType)(sub, name)), arg);
        }
        case types_2.TypeDefInfo.Option: {
            return Object.assign(Object.assign(Object.assign({}, (0, exports.processType)(sub, name)), arg), { optional: true });
        }
        case types_2.TypeDefInfo.Tuple: {
            return Object.assign(Object.assign({ type: types_3.TransactionArgumentType.Tuple }, arg), { internal: sub.map((def, index) => (0, exports.processType)(def, `${index}`)) });
        }
        case types_2.TypeDefInfo.Vec: {
            return Object.assign(Object.assign({ type: types_3.TransactionArgumentType.Array }, arg), { internal: (0, exports.processType)(sub, '') });
        }
        case types_2.TypeDefInfo.VecFixed: {
            return Object.assign({ type: types_3.TransactionArgumentType.Text }, arg);
        }
        case types_2.TypeDefInfo.Enum: {
            const subTypes = sub;
            const isSimple = subTypes.every(({ type: subType }) => subType === 'Null');
            if (isSimple) {
                return Object.assign(Object.assign({ type: types_3.TransactionArgumentType.SimpleEnum }, arg), { 
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    internal: subTypes.map(({ name: subName }) => subName) });
            }
            return Object.assign(Object.assign({ type: types_3.TransactionArgumentType.RichEnum }, arg), { 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                internal: subTypes.map(def => (0, exports.processType)(def, def.name)) });
        }
        case types_2.TypeDefInfo.Struct: {
            return Object.assign(Object.assign({ type: types_3.TransactionArgumentType.Object }, arg), { 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                internal: sub.map(def => (0, exports.processType)(def, def.name)) });
        }
        default: {
            return Object.assign({ type: types_3.TransactionArgumentType.Unknown }, arg);
        }
    }
};
exports.processType = processType;
//# sourceMappingURL=utils.js.map