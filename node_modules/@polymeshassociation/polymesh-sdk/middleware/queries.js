"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.authorizationsQuery = exports.polyxTransactionsQuery = exports.assetTransactionQuery = exports.portfolioMovementsQuery = exports.settlementsQuery = exports.assetHoldersQuery = exports.distributionPaymentsQuery = exports.distributionQuery = exports.tickerExternalAgentActionsQuery = exports.tickerExternalAgentHistoryQuery = exports.tickerExternalAgentsQuery = exports.assetQuery = exports.portfolioQuery = exports.trustingAssetsQuery = exports.trustedClaimIssuerQuery = exports.extrinsicsByArgs = exports.extrinsicByHash = exports.eventsByArgs = exports.instructionsByDidQuery = exports.instructionsQuery = exports.investmentsQuery = exports.claimsQuery = exports.claimsGroupingQuery = exports.latestSqVersionQuery = exports.metadataQuery = exports.heartbeatQuery = exports.latestBlockQuery = void 0;
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const enums_1 = require("./enums");
const types_1 = require("./types");
/**
 * @hidden
 *
 * Get the latest processed block number
 */
function latestBlockQuery() {
    const query = (0, graphql_tag_1.default) `
    query latestBlock {
      blocks(first: 1, orderBy: [${types_1.BlocksOrderBy.BlockIdDesc}]) {
        nodes {
          blockId
        }
      }
    }
  `;
    return {
        query,
        variables: undefined,
    };
}
exports.latestBlockQuery = latestBlockQuery;
/**
 * @hidden
 *
 * Middleware V2 heartbeat
 */
function heartbeatQuery() {
    const query = (0, graphql_tag_1.default) `
    query {
      block(id: "1") {
        id
      }
    }
  `;
    return {
        query,
        variables: undefined,
    };
}
exports.heartbeatQuery = heartbeatQuery;
/**
 * @hidden
 *
 * Get details about the SubQuery indexer
 */
function metadataQuery() {
    const query = (0, graphql_tag_1.default) `
    query Metadata {
      _metadata {
        chain
        specName
        genesisHash
        lastProcessedHeight
        lastProcessedTimestamp
        targetHeight
        indexerHealthy
        indexerNodeVersion
        queryNodeVersion
        dynamicDatasources
      }
    }
  `;
    return {
        query,
        variables: undefined,
    };
}
exports.metadataQuery = metadataQuery;
/**
 * @hidden
 *
 * Get details about the latest Subquery version
 */
function latestSqVersionQuery() {
    const query = (0, graphql_tag_1.default) `
    query SubqueryVersions {
      subqueryVersions(orderBy: [${types_1.SubqueryVersionsOrderBy.UpdatedAtDesc}], first: 1) {
        nodes {
          id
          version
          createdAt
          updatedAt
        }
      }
    }
  `;
    return {
        query,
        variables: undefined,
    };
}
exports.latestSqVersionQuery = latestSqVersionQuery;
/**
 *  @hidden
 */
function createClaimsFilters(variables) {
    const args = ['$size: Int, $start: Int'];
    const filters = ['revokeDate: { isNull: true }'];
    const { dids, claimTypes, trustedClaimIssuers, scope, includeExpired } = variables;
    if (dids === null || dids === void 0 ? void 0 : dids.length) {
        args.push('$dids: [String!]');
        filters.push('targetId: { in: $dids }');
    }
    if (claimTypes) {
        args.push('$claimTypes: [ClaimTypeEnum!]!');
        filters.push('type: { in: $claimTypes }');
    }
    if (trustedClaimIssuers === null || trustedClaimIssuers === void 0 ? void 0 : trustedClaimIssuers.length) {
        args.push('$trustedClaimIssuers: [String!]');
        filters.push('issuerId: { in: $trustedClaimIssuers }');
    }
    if (scope !== undefined) {
        args.push('$scope: JSON!');
        filters.push('scope: { contains: $scope }');
    }
    if (!includeExpired) {
        args.push('$expiryTimestamp: BigFloat');
        filters.push('or: [{ filterExpiry: { lessThan: $expiryTimestamp } }, { expiry: { isNull: true } }]');
    }
    return {
        args: `(${args.join()})`,
        filter: `filter: { ${filters.join()} },`,
    };
}
/**
 * @hidden
 *
 * Get all dids with at least one claim for a given scope and from one of the given trusted claim issuers
 */
function claimsGroupingQuery(variables, orderBy = types_1.ClaimsOrderBy.TargetIdAsc, groupBy = types_1.ClaimsGroupBy.TargetId) {
    const { args, filter } = createClaimsFilters(variables);
    const query = (0, graphql_tag_1.default) `
    query claimsGroupingQuery
      ${args}
     {
      claims(
        ${filter}
        orderBy: [${orderBy}]
        first: $size
        offset: $start
      ) {
        groupedAggregates(groupBy: [${groupBy}], having: {}) {
          keys
        }
      }
    }
  `;
    return {
        query,
        variables,
    };
}
exports.claimsGroupingQuery = claimsGroupingQuery;
/**
 * @hidden
 *
 * Get all claims that a given target DID has, with a given scope and from one of the given trustedClaimIssuers
 */
function claimsQuery(filters, size, start) {
    const { args, filter } = createClaimsFilters(filters);
    const query = (0, graphql_tag_1.default) `
    query ClaimsQuery
      ${args}
      {
        claims(
          ${filter}
          orderBy: [${types_1.ClaimsOrderBy.TargetIdAsc}, ${types_1.ClaimsOrderBy.CreatedAtAsc}, ${types_1.ClaimsOrderBy.CreatedBlockIdAsc}, ${types_1.ClaimsOrderBy.EventIdxAsc}]
          first: $size
          offset: $start
        ) {
          totalCount
          nodes {
            targetId
            type
            scope
            cddId
            issuerId
            issuanceDate
            lastUpdateDate
            expiry
            jurisdiction
          }
        }
      }
    `;
    return {
        query,
        variables: Object.assign(Object.assign({}, filters), { expiryTimestamp: filters.includeExpired ? undefined : new Date().getTime(), size: size === null || size === void 0 ? void 0 : size.toNumber(), start: start === null || start === void 0 ? void 0 : start.toNumber() }),
    };
}
exports.claimsQuery = claimsQuery;
/**
 * @hidden
 *
 * Get all investments for a given offering
 */
function investmentsQuery(filters, size, start) {
    const query = (0, graphql_tag_1.default) `
    query InvestmentsQuery($stoId: Int!, $offeringToken: String!, $size: Int, $start: Int) {
      investments(
        filter: { stoId: { equalTo: $stoId }, offeringToken: { equalTo: $offeringToken } }
        first: $size
        offset: $start
        orderBy: [${types_1.InvestmentsOrderBy.CreatedAtAsc}, ${types_1.InvestmentsOrderBy.CreatedBlockIdAsc}]
      ) {
        totalCount
        nodes {
          investorId
          offeringToken
          raiseToken
          offeringTokenAmount
          raiseTokenAmount
        }
      }
    }
  `;
    return {
        query,
        variables: Object.assign(Object.assign({}, filters), { size: size === null || size === void 0 ? void 0 : size.toNumber(), start: start === null || start === void 0 ? void 0 : start.toNumber() }),
    };
}
exports.investmentsQuery = investmentsQuery;
/**
 * Create args and filters to be supplied to GQL query
 *
 * @param filters - filters to be applied
 * @param typeMap - Map defining the types corresponding to each attribute. All missing attributes whose types are not defined are considered to be `String`
 *
 * @hidden
 */
function createArgsAndFilters(filters, typeMap) {
    const args = ['$start: Int', '$size: Int'];
    const gqlFilters = [];
    Object.keys(filters).forEach(attribute => {
        if (filters[attribute]) {
            const type = typeMap[attribute] || 'String';
            const middlewareType = enums_1.middlewareEnumMap[type] || type;
            args.push(`$${attribute}: ${middlewareType}!`);
            gqlFilters.push(`${attribute}: { equalTo: $${attribute} }`);
        }
    });
    return {
        args: `(${args.join()})`,
        filter: gqlFilters.length ? `filter: { ${gqlFilters.join()} }` : '',
    };
}
/**
 * @hidden
 *
 * Get a specific instruction within a venue for a specific event
 */
function instructionsQuery(filters, size, start) {
    const { args, filter } = createArgsAndFilters(filters, {
        eventId: 'EventIdEnum',
        status: 'InstructionStatusEnum',
    });
    const query = (0, graphql_tag_1.default) `
    query InstructionsQuery
      ${args}
      {
      instructions(
        ${filter}
        first: $size
        offset: $start
        orderBy: [${types_1.InstructionsOrderBy.CreatedAtDesc}, ${types_1.InstructionsOrderBy.IdDesc}]
      ) {
        totalCount
        nodes {
          id
          eventIdx
          eventId
          status
          settlementType
          venueId
          endBlock
          tradeDate
          valueDate
          legs {
            nodes {
              fromId
              from {
                identityId
                number
              }
              toId
              to {
                identityId
                number
              }
              assetId
              amount
              addresses
            }
          }
          memo
          createdBlock {
            blockId
            hash
            datetime
          }
          updatedBlock {
            blockId
            hash
            datetime
          }
        }
      }
    }
  `;
    return {
        query,
        variables: Object.assign(Object.assign({}, filters), { size: size === null || size === void 0 ? void 0 : size.toNumber(), start: start === null || start === void 0 ? void 0 : start.toNumber() }),
    };
}
exports.instructionsQuery = instructionsQuery;
/**
 * @hidden
 *
 * Get Instructions where an identity is involved
 */
function instructionsByDidQuery(identityId) {
    const query = (0, graphql_tag_1.default) `
    query InstructionsByDidQuery($fromId: String!, $toId: String!)
     {
      legs(
        filter: { or: [{ fromId: { startsWith: $fromId } }, { toId: { startsWith: $toId } }] }
        orderBy: [${types_1.LegsOrderBy.CreatedAtAsc}, ${types_1.LegsOrderBy.InstructionIdAsc}]
      ) {
        nodes {
          instruction {
            id
            eventIdx
            eventId
            status
            settlementType
            venueId
            endBlock
            tradeDate
            valueDate
            legs {
              nodes {
                fromId
                from {
                  identityId
                  number
                }
                toId
                to {
                  identityId
                  number
                }
                assetId
                amount
                addresses
              }
            }
            memo
            createdBlock {
              blockId
              hash
              datetime
            }
            updatedBlock {
              blockId
              hash
              datetime
            }
          }
        }
      }
    }
  `;
    return {
        query,
        variables: { fromId: `${identityId}/`, toId: `${identityId}/` },
    };
}
exports.instructionsByDidQuery = instructionsByDidQuery;
/**
 * @hidden
 *
 * Get a single event by any of its indexed arguments
 */
function eventsByArgs(filters, size, start) {
    const { args, filter } = createArgsAndFilters(filters, {
        moduleId: 'ModuleIdEnum',
        eventId: 'EventIdEnum',
    });
    const query = (0, graphql_tag_1.default) `
    query EventsQuery
      ${args}
     {
      events(
        ${filter}
        orderBy: [${types_1.EventsOrderBy.CreatedAtAsc}, ${types_1.EventsOrderBy.BlockIdAsc}]
        first: $size
        offset: $start
      ) {
        nodes {
          eventIdx
          block {
            blockId
            hash
            datetime
          }
        }
      }
    }
  `;
    return {
        query,
        variables: Object.assign(Object.assign({}, filters), { size: size === null || size === void 0 ? void 0 : size.toNumber(), start: start === null || start === void 0 ? void 0 : start.toNumber() }),
    };
}
exports.eventsByArgs = eventsByArgs;
/**
 * @hidden
 *
 * Get a transaction by hash
 */
function extrinsicByHash(variables) {
    const query = (0, graphql_tag_1.default) `
    query TransactionByHashQuery($extrinsicHash: String!) {
      extrinsics(filter: { extrinsicHash: { equalTo: $extrinsicHash } }) {
        nodes {
          extrinsicIdx
          address
          nonce
          moduleId
          callId
          paramsTxt
          success
          specVersionId
          extrinsicHash
          block {
            blockId
            hash
            datetime
          }
        }
      }
    }
  `;
    return {
        query,
        variables,
    };
}
exports.extrinsicByHash = extrinsicByHash;
/**
 * @hidden
 *
 * Get transactions
 */
function extrinsicsByArgs(filters, size, start, orderBy = types_1.ExtrinsicsOrderBy.BlockIdAsc) {
    const { args, filter } = createArgsAndFilters(filters, {
        moduleId: 'ModuleIdEnum',
        callId: 'CallIdEnum',
        success: 'Int',
    });
    const query = (0, graphql_tag_1.default) `
    query TransactionsQuery
      ${args}
     {
      extrinsics(
        ${filter}
        orderBy: [${orderBy}]
        first: $size
        offset: $start
      ) {
        totalCount
        nodes {
          blockId
          extrinsicIdx
          address
          nonce
          moduleId
          callId
          paramsTxt
          success
          specVersionId
          extrinsicHash
          block {
            hash
            datetime
          }
        }
      }
    }
  `;
    return {
        query,
        variables: Object.assign(Object.assign({}, filters), { size: size === null || size === void 0 ? void 0 : size.toNumber(), start: start === null || start === void 0 ? void 0 : start.toNumber() }),
    };
}
exports.extrinsicsByArgs = extrinsicsByArgs;
/**
 * @hidden
 *
 * Get an trusted claim issuer event for an asset and an issuer
 */
function trustedClaimIssuerQuery(variables) {
    const query = (0, graphql_tag_1.default) `
    query TrustedClaimIssuerQuery($assetId: String!, $issuer: String!) {
      trustedClaimIssuers(
        filter: { assetId: { equalTo: $assetId }, issuer: { equalTo: $issuer } },
        orderBy: [${types_1.TrustedClaimIssuersOrderBy.CreatedAtDesc}, ${types_1.TrustedClaimIssuersOrderBy.CreatedBlockIdDesc}]
      ) {
        nodes {
          eventIdx
          createdBlock {
            blockId
            datetime
            hash
          }
        }
      }
    }
  `;
    return {
        query,
        variables,
    };
}
exports.trustedClaimIssuerQuery = trustedClaimIssuerQuery;
/**
 * @hidden
 *
 * Get an trusted claim issuer event for an asset and an issuer
 */
function trustingAssetsQuery(variables) {
    const query = (0, graphql_tag_1.default) `
    query TrustedClaimIssuerQuery($issuer: String!) {
      trustedClaimIssuers(
        filter: { issuer: { equalTo: $issuer } },
        orderBy: [${types_1.TrustedClaimIssuersOrderBy.AssetIdAsc}]
      ) {
        nodes {
          assetId
        }
      }
    }
  `;
    return {
        query,
        variables,
    };
}
exports.trustingAssetsQuery = trustingAssetsQuery;
/**
 * @hidden
 *
 * Get portfolio details for a given DID and portfolio number
 */
function portfolioQuery(variables) {
    const query = (0, graphql_tag_1.default) `
    query PortfolioQuery($identityId: String!, $number: Int!) {
      portfolios(filter: { identityId: { equalTo: $identityId }, number: { equalTo: $number } }) {
        nodes {
          eventIdx
          createdBlock {
            blockId
            datetime
            hash
          }
        }
      }
    }
  `;
    return {
        query,
        variables,
    };
}
exports.portfolioQuery = portfolioQuery;
/**
 * @hidden
 *
 * Get Asset details for a given ticker
 */
function assetQuery(variables) {
    const query = (0, graphql_tag_1.default) `
    query AssetQuery($ticker: String!) {
      assets(filter: { ticker: { equalTo: $ticker } }) {
        nodes {
          eventIdx
          createdBlock {
            blockId
            datetime
            hash
          }
        }
      }
    }
  `;
    return {
        query,
        variables,
    };
}
exports.assetQuery = assetQuery;
/**
 * @hidden
 *
 * Get the event details when external agent added for a ticker
 */
function tickerExternalAgentsQuery(variables) {
    const query = (0, graphql_tag_1.default) `
    query TickerExternalAgentQuery($assetId: String!) {
      tickerExternalAgents(
        filter: { assetId: { equalTo: $assetId } }
        orderBy: [${types_1.TickerExternalAgentsOrderBy.CreatedAtDesc}, ${types_1.TickerExternalAgentsOrderBy.CreatedBlockIdDesc}]
        first: 1
      ) {
        nodes {
          eventIdx
          createdBlock {
            blockId
            datetime
            hash
          }
        }
      }
    }
  `;
    return {
        query,
        variables,
    };
}
exports.tickerExternalAgentsQuery = tickerExternalAgentsQuery;
/**
 * @hidden
 *
 * Get the transaction history of each external agent of an Asset
 */
function tickerExternalAgentHistoryQuery(variables) {
    const query = (0, graphql_tag_1.default) `
    query TickerExternalAgentHistoryQuery($assetId: String!) {
      tickerExternalAgentHistories(
        filter: { assetId: { equalTo: $assetId } }
        orderBy: [${types_1.TickerExternalAgentHistoriesOrderBy.CreatedAtAsc}, ${types_1.TickerExternalAgentHistoriesOrderBy.CreatedBlockIdAsc}]
      ) {
        nodes {
          identityId
          assetId
          eventIdx
          createdBlock {
            blockId
            hash
            datetime
          }
        }
      }
    }
  `;
    return {
        query,
        variables,
    };
}
exports.tickerExternalAgentHistoryQuery = tickerExternalAgentHistoryQuery;
/**
 * @hidden
 *
 * Get list of Events triggered by actions (from the set of actions that can only be performed by external agents) that have been performed on a specific Asset
 */
function tickerExternalAgentActionsQuery(filters, size, start) {
    const { args, filter } = createArgsAndFilters(filters, { eventId: 'EventIdEnum' });
    const query = (0, graphql_tag_1.default) `
    query TickerExternalAgentActionsQuery
      ${args}
     {
      tickerExternalAgentActions(
        ${filter}
        first: $size
        offset: $start
        orderBy: [${types_1.TickerExternalAgentActionsOrderBy.CreatedAtDesc}, ${types_1.TickerExternalAgentActionsOrderBy.CreatedBlockIdDesc}]
      ) {
        totalCount
        nodes {
          eventIdx
          palletName
          eventId
          callerId
          createdBlock {
            blockId
            datetime
            hash
          }
        }
      }
    }
  `;
    return {
        query,
        variables: Object.assign(Object.assign({}, filters), { size: size === null || size === void 0 ? void 0 : size.toNumber(), start: start === null || start === void 0 ? void 0 : start.toNumber() }),
    };
}
exports.tickerExternalAgentActionsQuery = tickerExternalAgentActionsQuery;
/**
 * @hidden
 *
 * Get distribution details for a CAId
 */
function distributionQuery(variables) {
    const query = (0, graphql_tag_1.default) `
    query DistributionQuery($id: String!) {
      distribution(id: $id) {
        taxes
      }
    }
  `;
    return {
        query,
        variables,
    };
}
exports.distributionQuery = distributionQuery;
/**
 * @hidden
 *
 * Get history of claims for a distribution
 */
function distributionPaymentsQuery(filters, size, start) {
    const query = (0, graphql_tag_1.default) `
    query DistributionPaymentQuery($distributionId: String!, $size: Int, $start: Int) {
      distributionPayments(
        filter: { distributionId: { equalTo: $distributionId } }
        first: $size
        offset: $start
      ) {
        totalCount
        nodes {
          eventId
          targetId
          datetime
          amount
          tax
          createdBlock {
            blockId
            hash
          }
        }
      }
    }
  `;
    return {
        query,
        variables: Object.assign(Object.assign({}, filters), { size: size === null || size === void 0 ? void 0 : size.toNumber(), start: start === null || start === void 0 ? void 0 : start.toNumber() }),
    };
}
exports.distributionPaymentsQuery = distributionPaymentsQuery;
/**
 * @hidden
 *
 * Get asset held by a DID
 */
function assetHoldersQuery(filters, size, start, orderBy = types_1.AssetHoldersOrderBy.AssetIdAsc) {
    const query = (0, graphql_tag_1.default) `
    query AssetHoldersQuery($identityId: String!, $size: Int, $start: Int) {
      assetHolders(
        filter: { identityId: { equalTo: $identityId } }
        first: $size
        offset: $start
        orderBy: [${orderBy}]
      ) {
        totalCount
        nodes {
          assetId
        }
      }
    }
  `;
    return {
        query,
        variables: Object.assign(Object.assign({}, filters), { size: size === null || size === void 0 ? void 0 : size.toNumber(), start: start === null || start === void 0 ? void 0 : start.toNumber() }),
    };
}
exports.assetHoldersQuery = assetHoldersQuery;
/**
 *  @hidden
 */
function createLegFilters({ identityId, portfolioId, ticker, address }) {
    const args = ['$fromId: String!, $toId: String!'];
    const fromIdFilters = ['fromId: { equalTo: $fromId }'];
    const toIdFilters = ['toId: { equalTo: $toId }'];
    const portfolioNumber = portfolioId ? portfolioId.toNumber() : 0;
    const variables = {
        fromId: `${identityId}/${portfolioNumber}`,
        toId: `${identityId}/${portfolioNumber}`,
    };
    if (ticker) {
        variables.assetId = ticker;
        args.push('$assetId: String!');
        const assetIdFilter = 'assetId: { equalTo: $assetId }';
        toIdFilters.push(assetIdFilter);
        fromIdFilters.push(assetIdFilter);
    }
    if (address) {
        variables.addresses = [address];
        args.push('$addresses: [String!]!');
        const addressFilter = 'addresses: { in: $addresses }';
        toIdFilters.push(addressFilter);
        fromIdFilters.push(addressFilter);
    }
    return {
        args: `(${args.join()})`,
        filter: `filter: { or: [{ ${fromIdFilters.join()}, settlementId: { isNull: false } }, { ${toIdFilters.join()}, settlementId: { isNull: false } } ] }`,
        variables,
    };
}
/**
 * @hidden
 *
 * Get Settlements where a Portfolio is involved
 */
function settlementsQuery(filters) {
    const { args, filter, variables } = createLegFilters(filters);
    const query = (0, graphql_tag_1.default) `
    query SettlementsQuery
      ${args}
     {
      legs(
        ${filter}
        orderBy: [${types_1.LegsOrderBy.CreatedAtAsc}, ${types_1.LegsOrderBy.InstructionIdAsc}]
      ) {
        nodes {
          settlement {
            id
            createdBlock {
              blockId
              datetime
              hash
            }
            result
            legs {
              nodes {
                fromId
                from {
                  identityId
                  number
                }
                toId
                to {
                  identityId
                  number
                }
                assetId
                amount
                addresses
              }
            }
          }
        }
      }
    }
  `;
    return {
        query,
        variables,
    };
}
exports.settlementsQuery = settlementsQuery;
/**
 *  @hidden
 */
function createPortfolioMovementFilters({ identityId, portfolioId, ticker, address, }) {
    const args = ['$fromId: String!, $toId: String!'];
    const fromIdFilters = ['fromId: { equalTo: $fromId }'];
    const toIdFilters = ['toId: { equalTo: $toId }'];
    const portfolioNumber = portfolioId ? portfolioId.toNumber() : 0;
    const variables = {
        fromId: `${identityId}/${portfolioNumber}`,
        toId: `${identityId}/${portfolioNumber}`,
    };
    if (ticker) {
        variables.assetId = ticker;
        args.push('$assetId: String!');
        const assetIdFilter = 'assetId: { equalTo: $assetId }';
        toIdFilters.push(assetIdFilter);
        fromIdFilters.push(assetIdFilter);
    }
    if (address) {
        variables.address = address;
        args.push('$address: String!');
        const addressFilter = 'address: { equalTo: $address }';
        toIdFilters.push(addressFilter);
        fromIdFilters.push(addressFilter);
    }
    return {
        args: `(${args.join()})`,
        filter: `filter: { or: [ { ${fromIdFilters.join()} }, { ${toIdFilters.join()} } ] }`,
        variables,
    };
}
/**
 * @hidden
 *
 * Get Settlements where a Portfolio is involved
 */
function portfolioMovementsQuery(filters) {
    const { args, filter, variables } = createPortfolioMovementFilters(filters);
    const query = (0, graphql_tag_1.default) `
    query PortfolioMovementsQuery
      ${args}
     {
      portfolioMovements(
        ${filter}
        orderBy: [${types_1.PortfolioMovementsOrderBy.CreatedAtAsc}, ${types_1.PortfolioMovementsOrderBy.IdAsc}]
      ) {
        nodes {
          id
          fromId
          from {
            identityId
            number
          }
          toId
          to {
            identityId
            number
          }
          assetId
          amount
          address
          createdBlock {
            blockId
            datetime
            hash
          }
        }
      }
    }
  `;
    return {
        query,
        variables,
    };
}
exports.portfolioMovementsQuery = portfolioMovementsQuery;
/**
 *  @hidden
 */
function createPolyxTransactionFilters({ identityId, addresses }) {
    const args = ['$size: Int, $start: Int'];
    const fromIdFilters = [];
    const toIdFilters = [];
    const variables = {};
    if (identityId) {
        variables.identityId = identityId;
        args.push('$identityId: String!');
        fromIdFilters.push('identityId: { equalTo: $identityId }');
        toIdFilters.push('toId: { equalTo: $identityId }');
    }
    if (addresses === null || addresses === void 0 ? void 0 : addresses.length) {
        variables.addresses = addresses;
        args.push('$addresses: [String!]!');
        fromIdFilters.push('address: { in: $addresses }');
        toIdFilters.push('toAddress: { in: $addresses }');
    }
    return {
        args: `(${args.join()})`,
        filter: fromIdFilters.length && toIdFilters.length
            ? `filter: { or: [ { ${fromIdFilters.join()} }, { ${toIdFilters.join()} } ] }`
            : '',
        variables,
    };
}
/**
 * @hidden
 *
 * Get the balance history for an Asset
 */
function assetTransactionQuery(filters, size, start) {
    const query = (0, graphql_tag_1.default) `
    query AssetTransactionQuery($assetId: String!) {
      assetTransactions(
        filter: { assetId: { equalTo: $assetId } }
        orderBy: [${types_1.AssetTransactionsOrderBy.CreatedAtAsc}, ${types_1.AssetTransactionsOrderBy.CreatedBlockIdAsc}]
      ) {
        totalCount
        nodes {
          assetId
          amount
          fromPortfolioId
          fromPortfolio {
            identityId
            number
          }
          toPortfolioId
          toPortfolio {
            identityId
            number
          }
          eventId
          eventIdx
          extrinsicIdx
          fundingRound
          datetime
          createdBlock {
            blockId
            hash
            datetime
          }
        }
      }
    }
  `;
    return {
        query,
        variables: Object.assign(Object.assign({}, filters), { size: size === null || size === void 0 ? void 0 : size.toNumber(), start: start === null || start === void 0 ? void 0 : start.toNumber() }),
    };
}
exports.assetTransactionQuery = assetTransactionQuery;
/**
 * @hidden
 *
 * Get POLYX transactions where an Account or an Identity is involved
 */
function polyxTransactionsQuery(filters, size, start) {
    const { args, filter, variables } = createPolyxTransactionFilters(filters);
    const query = (0, graphql_tag_1.default) `
    query PolyxTransactionsQuery
      ${args}
     {
      polyxTransactions(
        ${filter}
        first: $size
        offset: $start
        orderBy: [${types_1.PolyxTransactionsOrderBy.CreatedAtAsc}, ${types_1.PolyxTransactionsOrderBy.CreatedBlockIdAsc}]
      ) {
        nodes {
          id
          identityId
          address
          toId
          toAddress
          amount
          type
          extrinsic {
            extrinsicIdx
          }
          callId
          eventId
          moduleId
          eventIdx
          memo
          datetime
          createdBlock {
            blockId
            datetime
            hash
          }
        }
      }
    }
  `;
    return {
        query,
        variables: Object.assign(Object.assign({}, variables), { size: size === null || size === void 0 ? void 0 : size.toNumber(), start: start === null || start === void 0 ? void 0 : start.toNumber() }),
    };
}
exports.polyxTransactionsQuery = polyxTransactionsQuery;
/**
 *  @hidden
 */
function createAuthorizationFilters(variables) {
    const args = ['$size: Int, $start: Int'];
    const filters = [];
    const { fromId, toId, toKey, status, type } = variables;
    if (fromId === null || fromId === void 0 ? void 0 : fromId.length) {
        args.push('$fromId: String!');
        filters.push('fromId: { equalTo: $fromId }');
    }
    if (toId === null || toId === void 0 ? void 0 : toId.length) {
        args.push('$toId: String!');
        filters.push('toId: { equalTo: $toId }');
    }
    if (toKey === null || toKey === void 0 ? void 0 : toKey.length) {
        args.push('$toKey: String!');
        filters.push('toKey: { equalTo: $toKey }');
    }
    if (type) {
        args.push(`$type: ${enums_1.middlewareEnumMap.AuthTypeEnum}!`);
        filters.push('type: { equalTo: $type }');
    }
    if (status) {
        args.push(`$status: ${enums_1.middlewareEnumMap.AuthorizationStatusEnum}!`);
        filters.push('status: { equalTo: $status }');
    }
    return {
        args: `(${args.join()})`,
        filter: filters.length ? `filter: { ${filters.join()} }` : '',
        variables,
    };
}
/**
 * @hidden
 *
 * Get all authorizations with specified filters
 */
function authorizationsQuery(filters, size, start) {
    const { args, filter } = createAuthorizationFilters(filters);
    const query = (0, graphql_tag_1.default) `
    query AuthorizationsQuery
      ${args}
      {
      authorizations(
        ${filter}
        first: $size
        offset: $start
        orderBy: [${types_1.AuthorizationsOrderBy.CreatedAtAsc}, ${types_1.AuthorizationsOrderBy.CreatedBlockIdAsc}]
      ) {
        totalCount
        nodes {
          id
          type
          fromId
          toId
          toKey
          data
          expiry
          status
          createdBlockId
          updatedBlockId
        }
      }
    }
  `;
    return {
        query,
        variables: Object.assign(Object.assign({}, filters), { size: size === null || size === void 0 ? void 0 : size.toNumber(), start: start === null || start === void 0 ? void 0 : start.toNumber() }),
    };
}
exports.authorizationsQuery = authorizationsQuery;
//# sourceMappingURL=queries.js.map