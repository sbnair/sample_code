"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.u32ToBigNumber = exports.bigNumberToU32 = exports.meshPermissionsToPermissions = exports.extrinsicPermissionsToTransactionPermissions = exports.permissionsToMeshPermissions = exports.transactionPermissionsToExtrinsicPermissions = exports.transactionPermissionsToTxGroups = exports.txGroupToTxTags = exports.textToString = exports.stringToText = exports.portfolioToPortfolioKind = exports.portfolioIdToMeshPortfolioId = exports.portfolioLikeToPortfolio = exports.portfolioIdToPortfolio = exports.portfolioLikeToPortfolioId = exports.portfolioToPortfolioId = exports.meshPortfolioIdToPortfolio = exports.claimPercentageToClaimPercentageRestrictionValue = exports.claimCountToClaimCountRestrictionValue = exports.meshClaimToInputStatClaim = exports.permillToBigNumber = exports.percentageToPermill = exports.bigNumberToU128 = exports.bigNumberToU64 = exports.u128ToBigNumber = exports.u64ToBigNumber = exports.signerToString = exports.signerToSignatory = exports.signerValueToSigner = exports.signerToSignerValue = exports.signatoryToSignerValue = exports.signerValueToSignatory = exports.identityIdToString = exports.stringToIdentityId = exports.stringToBlockHash = exports.stringToHash = exports.hashToString = exports.accountIdToString = exports.stringToAccountId = exports.momentToDate = exports.dateToMoment = exports.stringToU8aFixed = exports.tickerToString = exports.stringToTickerKey = exports.stringToTicker = exports.bytesToString = exports.stringToBytes = exports.boolToBoolean = exports.booleanToBool = exports.tickerToDid = void 0;
exports.txTagToExtrinsicIdentifier = exports.extrinsicIdentifierToTxTag = exports.txTagToProtocolOp = exports.complianceRequirementToRequirement = exports.complianceRequirementResultToRequirementCompliance = exports.requirementToComplianceRequirement = exports.trustedClaimIssuerToTrustedIssuer = exports.trustedIssuerToTrustedClaimIssuer = exports.meshClaimTypeToClaimType = exports.stringToTargetIdentity = exports.statsClaimToStatClaimInputType = exports.meshClaimToClaim = exports.middlewareEventDetailsToEventIdentifier = exports.scopeToMiddlewareScope = exports.middlewareScopeToScope = exports.claimToMeshClaim = exports.cddIdToString = exports.stringToCddId = exports.meshScopeToScope = exports.scopeToMeshScope = exports.canTransferResultToTransferStatus = exports.cddStatusToBoolean = exports.documentToAssetDocument = exports.assetDocumentToDocument = exports.documentHashToString = exports.stringToDocumentHash = exports.assetIdentifierToSecurityIdentifier = exports.securityIdentifierToAssetIdentifier = exports.isFigiValid = exports.isLeiValid = exports.isCusipValid = exports.isIsinValid = exports.fundingRoundToAssetFundingRound = exports.nameToAssetName = exports.posRatioToBigNumber = exports.assetTypeToKnownOrId = exports.internalNftTypeToNftType = exports.internalAssetTypeToAssetType = exports.u8ToTransferStatus = exports.stringToMemo = exports.authorizationDataToAuthorization = exports.agentGroupToPermissionGroup = exports.balanceToBigNumber = exports.bigNumberToBalance = exports.authorizationTypeToMeshAuthorizationType = exports.authorizationToAuthorizationData = exports.agentGroupToPermissionGroupIdentifier = exports.permissionGroupIdentifierToAgentGroup = exports.u8ToBigNumber = exports.u16ToBigNumber = void 0;
exports.sortTransferRestrictionByClaimValue = exports.createStat2ndKey = exports.transferRestrictionTypeToStatOpType = exports.statTypeToStatOpType = exports.meshStatToStatType = exports.statUpdatesToBtreeStatUpdate = exports.keyAndValueToStatUpdate = exports.transferConditionsToBtreeTransferConditions = exports.statisticStatTypesToBtreeStatType = exports.sortStatsByClaimType = exports.statisticsOpTypeToStatType = exports.corporateActionParamsToMeshCorporateActionArgs = exports.corporateActionIdentifierToCaId = exports.distributionToDividendDistributionParams = exports.caTaxWithholdingsToMeshTaxWithholdings = exports.targetsToTargetIdentities = exports.targetIdentitiesToCorporateActionTargets = exports.checkpointToRecordDateSpec = exports.corporateActionKindToCaKind = exports.meshCorporateActionToCorporateActionParams = exports.fundraiserToOfferingDetails = exports.fundraiserTierToTier = exports.middlewarePortfolioToPortfolio = exports.permissionsLikeToPermissions = exports.offeringTierToPriceTier = exports.granularCanTransferResultToTransferBreakdown = exports.transferConditionToTransferRestriction = exports.identitiesToBtreeSet = exports.transferRestrictionToPolymeshTransferCondition = exports.claimIssuerToMeshClaimIssuer = exports.claimTypeToMeshClaimType = exports.nftMovementToPortfolioFund = exports.fungibleMovementToPortfolioFund = exports.nftToMeshNft = exports.toIdentityWithClaimsArray = exports.middlewareClaimToClaimData = exports.endConditionToSettlementType = exports.meshSettlementTypeToEndCondition = exports.meshAffirmationStatusToAffirmationStatus = exports.meshInstructionStatusToInstructionStatus = exports.venueTypeToMeshVenueType = exports.meshVenueTypeToVenueType = exports.secondaryAccountToMeshSecondaryKey = exports.transactionToTxTag = exports.transactionHexToTxTag = exports.coerceHexToString = exports.addressToKey = exports.keyToAddress = exports.moduleAddressToString = exports.assetComplianceResultToCompliance = void 0;
exports.nftInputToNftMetadataVec = exports.nftInputToNftMetadataAttribute = exports.meshNftToNftId = exports.meshMetadataKeyToMetadataKey = exports.collectionKeysToMetadataKeys = exports.middlewareAuthorizationDataToAuthorization = exports.middlewarePermissionsDataToPermissions = exports.datesToScheduleCheckpoints = exports.middlewareAgentGroupDataToPermissionGroup = exports.legToSettlementLeg = exports.middlewarePortfolioDataToPortfolio = exports.expiryToMoment = exports.middlewareInstructionToHistoricInstruction = exports.instructionMemoToString = exports.metadataValueDetailToMeshMetadataValueDetail = exports.metadataValueToMeshMetadataValue = exports.meshMetadataValueToMetadataValue = exports.metadataToMeshMetadataKey = exports.meshMetadataSpecToMetadataSpec = exports.metadataSpecToMeshMetadataSpec = exports.meshProposalStatusToProposalStatus = exports.inputStatTypeToMeshStatType = exports.countStatInputToStatUpdates = exports.claimCountStatInputToStatUpdates = exports.toExemptKey = exports.complianceConditionsToBtreeSet = void 0;
const util_1 = require("@polkadot/util");
const util_crypto_1 = require("@polkadot/util-crypto");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const iso_7064_1 = require("iso-7064");
const lodash_1 = require("lodash");
const utils_1 = require("../api/procedures/utils");
const utils_2 = require("../generated/utils");
const internal_1 = require("../internal");
const enums_1 = require("../middleware/enums");
const typesV1_1 = require("../middleware/typesV1");
const types_1 = require("../types");
const internal_2 = require("../types/internal");
const utils_3 = require("../types/utils");
const constants_1 = require("./constants");
const internal_3 = require("./internal");
const typeguards_1 = require("./typeguards");
__exportStar(require("../generated/utils"), exports);
/**
 * Generate an Asset's DID from a ticker
 */
function tickerToDid(ticker) {
    return (0, util_crypto_1.blake2AsHex)((0, util_1.u8aConcat)((0, util_1.stringToU8a)('SECURITY_TOKEN:'), (0, util_1.u8aFixLength)((0, util_1.stringToU8a)(ticker), 96, true)));
}
exports.tickerToDid = tickerToDid;
/**
 * @hidden
 */
function booleanToBool(value, context) {
    return context.createType('bool', value);
}
exports.booleanToBool = booleanToBool;
/**
 * @hidden
 */
function boolToBoolean(value) {
    return value.isTrue;
}
exports.boolToBoolean = boolToBoolean;
/**
 * @hidden
 */
function stringToBytes(bytes, context) {
    return context.createType('Bytes', bytes);
}
exports.stringToBytes = stringToBytes;
/**
 * @hidden
 */
function bytesToString(bytes) {
    return (0, util_1.u8aToString)(bytes);
}
exports.bytesToString = bytesToString;
/**
 * @hidden
 */
function stringToTicker(ticker, context) {
    (0, internal_3.assertTickerValid)(ticker);
    return context.createType('PolymeshPrimitivesTicker', (0, internal_3.padString)(ticker, constants_1.MAX_TICKER_LENGTH));
}
exports.stringToTicker = stringToTicker;
/**
 * @hidden
 */
function stringToTickerKey(ticker, context) {
    return { Ticker: stringToTicker(ticker, context) };
}
exports.stringToTickerKey = stringToTickerKey;
/**
 * @hidden
 */
function tickerToString(ticker) {
    return (0, internal_3.removePadding)((0, util_1.u8aToString)(ticker));
}
exports.tickerToString = tickerToString;
/**
 * @hidden
 */
function stringToU8aFixed(value, context) {
    return context.createType('U8aFixed', value);
}
exports.stringToU8aFixed = stringToU8aFixed;
/**
 * @hidden
 */
function dateToMoment(date, context) {
    return context.createType('u64', date.getTime());
}
exports.dateToMoment = dateToMoment;
/**
 * @hidden
 */
function momentToDate(moment) {
    return new Date(moment.toNumber());
}
exports.momentToDate = momentToDate;
/**
 * @hidden
 */
function stringToAccountId(accountId, context) {
    (0, internal_3.assertAddressValid)(accountId, context.ss58Format);
    return context.createType('AccountId', accountId);
}
exports.stringToAccountId = stringToAccountId;
/**
 * @hidden
 */
function accountIdToString(accountId) {
    return accountId.toString();
}
exports.accountIdToString = accountIdToString;
/**
 * @hidden
 */
function hashToString(hash) {
    return hash.toString();
}
exports.hashToString = hashToString;
/**
 * @hidden
 */
function stringToHash(hash, context) {
    return context.createType('Hash', hash);
}
exports.stringToHash = stringToHash;
/**
 * @hidden
 */
function stringToBlockHash(blockHash, context) {
    return context.createType('BlockHash', blockHash);
}
exports.stringToBlockHash = stringToBlockHash;
/**
 * @hidden
 */
function stringToIdentityId(identityId, context) {
    return context.createType('PolymeshPrimitivesIdentityId', identityId);
}
exports.stringToIdentityId = stringToIdentityId;
/**
 * @hidden
 */
function identityIdToString(identityId) {
    return identityId.toString();
}
exports.identityIdToString = identityIdToString;
/**
 * @hidden
 */
function signerValueToSignatory(signer, context) {
    return context.createType('PolymeshPrimitivesSecondaryKeySignatory', {
        [signer.type]: signer.value,
    });
}
exports.signerValueToSignatory = signerValueToSignatory;
/**
 * @hidden
 */
function createSignerValue(type, value) {
    return {
        type,
        value,
    };
}
/**
 * @hidden
 */
function signatoryToSignerValue(signatory) {
    if (signatory.isAccount) {
        return createSignerValue(types_1.SignerType.Account, accountIdToString(signatory.asAccount));
    }
    return createSignerValue(types_1.SignerType.Identity, identityIdToString(signatory.asIdentity));
}
exports.signatoryToSignerValue = signatoryToSignerValue;
/**
 * @hidden
 */
function signerToSignerValue(signer) {
    if (signer instanceof internal_1.Account) {
        return createSignerValue(types_1.SignerType.Account, signer.address);
    }
    return createSignerValue(types_1.SignerType.Identity, signer.did);
}
exports.signerToSignerValue = signerToSignerValue;
/**
 * @hidden
 */
function signerValueToSigner(signerValue, context) {
    const { type, value } = signerValue;
    if (type === types_1.SignerType.Account) {
        return new internal_1.Account({ address: value }, context);
    }
    return new internal_1.Identity({ did: value }, context);
}
exports.signerValueToSigner = signerValueToSigner;
/**
 * @hidden
 */
function signerToSignatory(signer, context) {
    return signerValueToSignatory(signerToSignerValue(signer), context);
}
exports.signerToSignatory = signerToSignatory;
/**
 * @hidden
 */
function signerToString(signer) {
    if (typeof signer === 'string') {
        return signer;
    }
    return signerToSignerValue(signer).value;
}
exports.signerToString = signerToString;
/**
 * @hidden
 */
function u64ToBigNumber(value) {
    return new bignumber_js_1.default(value.toString());
}
exports.u64ToBigNumber = u64ToBigNumber;
/**
 * @hidden
 */
function u128ToBigNumber(value) {
    return new bignumber_js_1.default(value.toString());
}
exports.u128ToBigNumber = u128ToBigNumber;
/**
 * @hidden
 */
function bigNumberToU64(value, context) {
    (0, internal_3.assertIsInteger)(value);
    (0, internal_3.assertIsPositive)(value);
    return context.createType('u64', value.toString());
}
exports.bigNumberToU64 = bigNumberToU64;
/**
 * @hidden
 */
function bigNumberToU128(value, context) {
    (0, internal_3.assertIsInteger)(value);
    (0, internal_3.assertIsPositive)(value);
    return context.createType('u128', value.toString());
}
exports.bigNumberToU128 = bigNumberToU128;
/**
 * @hidden
 */
function percentageToPermill(value, context) {
    (0, internal_3.assertIsPositive)(value);
    if (value.gt(100)) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: "Percentage shouldn't exceed 100",
        });
    }
    return context.createType('Permill', value.shiftedBy(4).toString()); // (value : 100) * 10^6
}
exports.percentageToPermill = percentageToPermill;
/**
 * @hidden
 *
 * @note returns a percentage value ([0, 100])
 */
function permillToBigNumber(value) {
    return new bignumber_js_1.default(value.toString()).shiftedBy(-4); // (value : 10^6) * 100
}
exports.permillToBigNumber = permillToBigNumber;
/**
 *  @hidden
 */
function meshClaimToInputStatClaim(claim) {
    if (claim.isAccredited) {
        return {
            type: types_1.ClaimType.Accredited,
            accredited: boolToBoolean(claim.asAccredited),
        };
    }
    else if (claim.isAffiliate) {
        return {
            type: types_1.ClaimType.Affiliate,
            affiliate: boolToBoolean(claim.asAffiliate),
        };
    }
    else {
        return {
            type: types_1.ClaimType.Jurisdiction,
            countryCode: claim.asJurisdiction.isSome
                ? (0, utils_2.meshCountryCodeToCountryCode)(claim.asJurisdiction.unwrap())
                : undefined,
        };
    }
}
exports.meshClaimToInputStatClaim = meshClaimToInputStatClaim;
/**
 * @hidden
 */
function claimCountToClaimCountRestrictionValue(value, context) {
    const [claim, issuer, min, max] = value;
    return {
        claim: meshClaimToInputStatClaim(claim),
        issuer: new internal_1.Identity({ did: identityIdToString(issuer) }, context),
        min: u64ToBigNumber(min),
        max: max.isSome ? u64ToBigNumber(max.unwrap()) : undefined,
    };
}
exports.claimCountToClaimCountRestrictionValue = claimCountToClaimCountRestrictionValue;
/**
 * @hidden
 */
function claimPercentageToClaimPercentageRestrictionValue(value, context) {
    const [claim, issuer, min, max] = value;
    return {
        claim: meshClaimToInputStatClaim(claim),
        issuer: new internal_1.Identity({ did: identityIdToString(issuer) }, context),
        min: permillToBigNumber(min),
        max: permillToBigNumber(max),
    };
}
exports.claimPercentageToClaimPercentageRestrictionValue = claimPercentageToClaimPercentageRestrictionValue;
/**
 * @hidden
 */
function meshPortfolioIdToPortfolio(portfolioId, context) {
    const { did, kind } = portfolioId;
    const identityId = identityIdToString(did);
    if (kind.isDefault) {
        return new internal_1.DefaultPortfolio({ did: identityId }, context);
    }
    return new internal_1.NumberedPortfolio({ did: identityId, id: u64ToBigNumber(kind.asUser) }, context);
}
exports.meshPortfolioIdToPortfolio = meshPortfolioIdToPortfolio;
/**
 * @hidden
 */
function portfolioToPortfolioId(portfolio) {
    const { owner: { did }, } = portfolio;
    if (portfolio instanceof internal_1.DefaultPortfolio) {
        return { did };
    }
    else {
        const { id: number } = portfolio;
        return { did, number };
    }
}
exports.portfolioToPortfolioId = portfolioToPortfolioId;
/**
 * @hidden
 */
function portfolioLikeToPortfolioId(value) {
    let did;
    let number;
    if (typeof value === 'string') {
        did = value;
    }
    else if (value instanceof internal_1.Identity) {
        ({ did } = value);
    }
    else if (value instanceof internal_1.Portfolio) {
        ({ did, number } = portfolioToPortfolioId(value));
    }
    else {
        const { identity: valueIdentity } = value;
        ({ id: number } = value);
        did = (0, internal_3.asDid)(valueIdentity);
    }
    return { did, number };
}
exports.portfolioLikeToPortfolioId = portfolioLikeToPortfolioId;
/**
 * @hidden
 */
function portfolioIdToPortfolio(portfolioId, context) {
    const { did, number } = portfolioId;
    return number
        ? new internal_1.NumberedPortfolio({ did, id: number }, context)
        : new internal_1.DefaultPortfolio({ did }, context);
}
exports.portfolioIdToPortfolio = portfolioIdToPortfolio;
/**
 * @hidden
 */
function portfolioLikeToPortfolio(value, context) {
    return portfolioIdToPortfolio(portfolioLikeToPortfolioId(value), context);
}
exports.portfolioLikeToPortfolio = portfolioLikeToPortfolio;
/**
 * @hidden
 */
function portfolioIdToMeshPortfolioId(portfolioId, context) {
    const { did, number } = portfolioId;
    return context.createType('PolymeshPrimitivesIdentityIdPortfolioId', {
        did: stringToIdentityId(did, context),
        kind: number ? { User: bigNumberToU64(number, context) } : 'Default',
    });
}
exports.portfolioIdToMeshPortfolioId = portfolioIdToMeshPortfolioId;
/**
 * @hidden
 */
function portfolioToPortfolioKind(portfolio, context) {
    let portfolioKind;
    if ((0, typeguards_1.isNumberedPortfolio)(portfolio)) {
        portfolioKind = { User: bigNumberToU64(portfolio.id, context) };
    }
    else {
        portfolioKind = 'Default';
    }
    return context.createType('PolymeshPrimitivesIdentityIdPortfolioKind', portfolioKind);
}
exports.portfolioToPortfolioKind = portfolioToPortfolioKind;
/**
 * @hidden
 */
function stringToText(text, context) {
    return context.createType('Text', text);
}
exports.stringToText = stringToText;
/**
 * @hidden
 */
function textToString(value) {
    return value.toString();
}
exports.textToString = textToString;
/**
 * Retrieve every Transaction Tag associated to a Transaction Group
 */
function txGroupToTxTags(group) {
    switch (group) {
        case types_1.TxGroup.PortfolioManagement: {
            return [
                types_1.TxTags.identity.AddInvestorUniquenessClaim,
                types_1.TxTags.portfolio.MovePortfolioFunds,
                types_1.TxTags.settlement.AddInstruction,
                types_1.TxTags.settlement.AddInstructionWithMemo,
                types_1.TxTags.settlement.AddAndAffirmInstruction,
                types_1.TxTags.settlement.AddAndAffirmInstructionWithMemo,
                types_1.TxTags.settlement.AffirmInstruction,
                types_1.TxTags.settlement.RejectInstruction,
                types_1.TxTags.settlement.CreateVenue,
            ];
        }
        case types_1.TxGroup.AssetManagement: {
            return [
                types_1.TxTags.asset.MakeDivisible,
                types_1.TxTags.asset.RenameAsset,
                types_1.TxTags.asset.SetFundingRound,
                types_1.TxTags.asset.AddDocuments,
                types_1.TxTags.asset.RemoveDocuments,
            ];
        }
        case types_1.TxGroup.AdvancedAssetManagement: {
            return [
                types_1.TxTags.asset.Freeze,
                types_1.TxTags.asset.Unfreeze,
                types_1.TxTags.identity.AddAuthorization,
                types_1.TxTags.identity.RemoveAuthorization,
            ];
        }
        case types_1.TxGroup.Distribution: {
            return [
                types_1.TxTags.identity.AddInvestorUniquenessClaim,
                types_1.TxTags.settlement.CreateVenue,
                types_1.TxTags.settlement.AddInstruction,
                types_1.TxTags.settlement.AddInstructionWithMemo,
                types_1.TxTags.settlement.AddAndAffirmInstruction,
                types_1.TxTags.settlement.AddAndAffirmInstructionWithMemo,
            ];
        }
        case types_1.TxGroup.Issuance: {
            return [types_1.TxTags.asset.Issue];
        }
        case types_1.TxGroup.TrustedClaimIssuersManagement: {
            return [
                types_1.TxTags.complianceManager.AddDefaultTrustedClaimIssuer,
                types_1.TxTags.complianceManager.RemoveDefaultTrustedClaimIssuer,
            ];
        }
        case types_1.TxGroup.ClaimsManagement: {
            return [types_1.TxTags.identity.AddClaim, types_1.TxTags.identity.RevokeClaim];
        }
        case types_1.TxGroup.ComplianceRequirementsManagement: {
            return [
                types_1.TxTags.complianceManager.AddComplianceRequirement,
                types_1.TxTags.complianceManager.RemoveComplianceRequirement,
                types_1.TxTags.complianceManager.PauseAssetCompliance,
                types_1.TxTags.complianceManager.ResumeAssetCompliance,
                types_1.TxTags.complianceManager.ResetAssetCompliance,
            ];
        }
        case types_1.TxGroup.CorporateActionsManagement: {
            return [
                types_1.TxTags.checkpoint.CreateSchedule,
                types_1.TxTags.checkpoint.RemoveSchedule,
                types_1.TxTags.checkpoint.CreateCheckpoint,
                types_1.TxTags.corporateAction.InitiateCorporateAction,
                types_1.TxTags.capitalDistribution.Distribute,
                types_1.TxTags.capitalDistribution.Claim,
                types_1.TxTags.identity.AddInvestorUniquenessClaim,
            ];
        }
        case types_1.TxGroup.StoManagement: {
            return [
                types_1.TxTags.sto.CreateFundraiser,
                types_1.TxTags.sto.FreezeFundraiser,
                types_1.TxTags.sto.Invest,
                types_1.TxTags.sto.ModifyFundraiserWindow,
                types_1.TxTags.sto.Stop,
                types_1.TxTags.sto.UnfreezeFundraiser,
                types_1.TxTags.identity.AddInvestorUniquenessClaim,
                types_1.TxTags.asset.Issue,
                types_1.TxTags.settlement.CreateVenue,
            ];
        }
    }
}
exports.txGroupToTxTags = txGroupToTxTags;
/**
 * @hidden
 *
 * @note tags that don't belong to any group will be ignored.
 *   The same goes for tags that belong to a group that wasn't completed
 */
function transactionPermissionsToTxGroups(permissions) {
    if (!permissions) {
        return [];
    }
    const { values: transactionValues, type, exceptions = [] } = permissions;
    let includedTags;
    let excludedTags;
    if (type === types_1.PermissionType.Include) {
        includedTags = transactionValues;
        excludedTags = exceptions;
    }
    else {
        includedTags = exceptions;
        excludedTags = transactionValues;
    }
    return (0, lodash_1.values)(types_1.TxGroup)
        .sort()
        .filter(group => {
        const tagsInGroup = txGroupToTxTags(group);
        return tagsInGroup.every(tag => {
            const isExcluded = !!excludedTags.find(excluded => (0, internal_3.isModuleOrTagMatch)(excluded, tag));
            if (isExcluded) {
                return false;
            }
            return !!includedTags.find(included => (0, internal_3.isModuleOrTagMatch)(included, tag));
        });
    });
}
exports.transactionPermissionsToTxGroups = transactionPermissionsToTxGroups;
/**
 * @hidden
 */
function splitTag(tag) {
    const [modName, txName] = tag.split('.');
    const palletName = (0, util_1.stringUpperFirst)(modName);
    const dispatchableName = (0, lodash_1.snakeCase)(txName);
    return { palletName, dispatchableName };
}
/**
 * @hidden
 */
function initExtrinsicDict(txValues, message) {
    const extrinsicDict = {};
    (0, lodash_1.uniq)(txValues)
        .sort()
        .forEach(tag => {
        if (tag.includes('.')) {
            const { palletName, dispatchableName } = splitTag(tag);
            let pallet = extrinsicDict[palletName];
            if (pallet === null) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.ValidationError,
                    message,
                    data: {
                        module: palletName,
                        transactions: [dispatchableName],
                    },
                });
            }
            else if (pallet === undefined) {
                pallet = extrinsicDict[palletName] = { tx: [] };
            }
            pallet.tx.push(dispatchableName);
        }
        else {
            extrinsicDict[(0, util_1.stringUpperFirst)(tag)] = null;
        }
    });
    return extrinsicDict;
}
/**
 * @hidden
 */
function buildPalletPermissions(transactions) {
    let extrinsic;
    const message = 'Attempting to add permissions for specific transactions as well as the entire module';
    const { values: txValues, exceptions = [], type } = transactions;
    const extrinsicDict = initExtrinsicDict(txValues, message);
    exceptions.forEach(exception => {
        const { palletName, dispatchableName } = splitTag(exception);
        const pallet = extrinsicDict[palletName];
        if (pallet === undefined) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Attempting to add a transaction permission exception without its corresponding module being included/excluded',
            });
        }
        else if (pallet === null) {
            extrinsicDict[palletName] = { tx: [dispatchableName], exception: true };
        }
        else if (pallet.exception) {
            pallet.tx.push(dispatchableName);
        }
        else {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Cannot simultaneously include and exclude transactions belonging to the same module',
            });
        }
    });
    const pallets = (0, lodash_1.map)(extrinsicDict, (val, key) => {
        let dispatchables;
        if (val === null) {
            dispatchables = 'Whole';
        }
        else {
            const { tx, exception } = val;
            if (exception) {
                dispatchables = {
                    Except: tx,
                };
            }
            else {
                dispatchables = {
                    These: tx,
                };
            }
        }
        return {
            /* eslint-disable @typescript-eslint/naming-convention */
            pallet_name: key,
            dispatchable_names: dispatchables,
            /* eslint-enable @typescript-eslint/naming-convention */
        };
    });
    if (type === types_1.PermissionType.Include) {
        extrinsic = {
            These: pallets,
        };
    }
    else {
        extrinsic = {
            Except: pallets,
        };
    }
    return extrinsic;
}
/**
 * @hidden
 */
function transactionPermissionsToExtrinsicPermissions(transactionPermissions, context) {
    return context.createType('PolymeshPrimitivesSubsetSubsetRestrictionPalletPermissions', transactionPermissions ? buildPalletPermissions(transactionPermissions) : 'Whole');
}
exports.transactionPermissionsToExtrinsicPermissions = transactionPermissionsToExtrinsicPermissions;
/**
 * @hidden
 */
function permissionsToMeshPermissions(permissions, context) {
    const { assets, transactions, portfolios } = permissions;
    const extrinsic = transactionPermissionsToExtrinsicPermissions(transactions, context);
    let asset = 'Whole';
    if (assets) {
        const { values: assetValues, type } = assets;
        assetValues.sort(({ ticker: tickerA }, { ticker: tickerB }) => tickerA.localeCompare(tickerB));
        const tickers = assetValues.map(({ ticker }) => stringToTicker(ticker, context));
        if (type === types_1.PermissionType.Include) {
            asset = {
                These: tickers,
            };
        }
        else {
            asset = {
                Except: tickers,
            };
        }
    }
    let portfolio = 'Whole';
    if (portfolios) {
        const { values: portfolioValues, type } = portfolios;
        const portfolioIds = portfolioValues.map(pValue => portfolioIdToMeshPortfolioId(portfolioToPortfolioId(pValue), context));
        if (type === types_1.PermissionType.Include) {
            portfolio = {
                These: portfolioIds,
            };
        }
        else {
            portfolio = {
                Except: portfolioIds,
            };
        }
    }
    const value = {
        asset,
        extrinsic,
        portfolio,
    };
    return context.createType('PolymeshPrimitivesSecondaryKeyPermissions', value);
}
exports.permissionsToMeshPermissions = permissionsToMeshPermissions;
const formatTxTag = (dispatchable, moduleName) => {
    return `${moduleName}.${(0, lodash_1.camelCase)(dispatchable)}`;
};
/**
 * @hidden
 */
function extrinsicPermissionsToTransactionPermissions(permissions) {
    let extrinsicType;
    let pallets;
    if (permissions.isThese) {
        extrinsicType = types_1.PermissionType.Include;
        pallets = permissions.asThese;
    }
    else if (permissions.isExcept) {
        extrinsicType = types_1.PermissionType.Exclude;
        pallets = permissions.asExcept;
    }
    let txValues = [];
    let exceptions = [];
    if (pallets) {
        pallets.forEach(({ palletName, dispatchableNames }) => {
            const moduleName = (0, util_1.stringLowerFirst)(bytesToString(palletName));
            if (dispatchableNames.isExcept) {
                const dispatchables = [...dispatchableNames.asExcept];
                exceptions = [
                    ...exceptions,
                    ...dispatchables.map(name => formatTxTag(bytesToString(name), moduleName)),
                ];
                txValues = [...txValues, moduleName];
            }
            else if (dispatchableNames.isThese) {
                const dispatchables = [...dispatchableNames.asThese];
                txValues = [
                    ...txValues,
                    ...dispatchables.map(name => formatTxTag(bytesToString(name), moduleName)),
                ];
            }
            else {
                txValues = [...txValues, moduleName];
            }
        });
        const result = {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            type: extrinsicType,
            values: txValues,
        };
        return exceptions.length ? Object.assign(Object.assign({}, result), { exceptions }) : result;
    }
    return null;
}
exports.extrinsicPermissionsToTransactionPermissions = extrinsicPermissionsToTransactionPermissions;
/**
 * @hidden
 */
function meshPermissionsToPermissions(permissions, context) {
    const { asset, extrinsic, portfolio } = permissions;
    let assets = null;
    let transactions = null;
    let portfolios = null;
    let assetsType;
    let assetsPermissions;
    if (asset.isThese) {
        assetsType = types_1.PermissionType.Include;
        assetsPermissions = asset.asThese;
    }
    else if (asset.isExcept) {
        assetsType = types_1.PermissionType.Exclude;
        assetsPermissions = asset.asExcept;
    }
    if (assetsPermissions) {
        assets = {
            values: [...assetsPermissions].map(ticker => new internal_1.FungibleAsset({ ticker: tickerToString(ticker) }, context)),
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            type: assetsType,
        };
    }
    transactions = extrinsicPermissionsToTransactionPermissions(extrinsic);
    let portfoliosType;
    let portfolioIds;
    if (portfolio.isThese) {
        portfoliosType = types_1.PermissionType.Include;
        portfolioIds = portfolio.asThese;
    }
    else if (portfolio.isExcept) {
        portfoliosType = types_1.PermissionType.Exclude;
        portfolioIds = portfolio.asExcept;
    }
    if (portfolioIds) {
        portfolios = {
            values: [...portfolioIds].map(portfolioId => meshPortfolioIdToPortfolio(portfolioId, context)),
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            type: portfoliosType,
        };
    }
    return {
        assets,
        transactions,
        transactionGroups: transactions ? transactionPermissionsToTxGroups(transactions) : [],
        portfolios,
    };
}
exports.meshPermissionsToPermissions = meshPermissionsToPermissions;
/**
 * @hidden
 */
function bigNumberToU32(value, context) {
    (0, internal_3.assertIsInteger)(value);
    (0, internal_3.assertIsPositive)(value);
    return context.createType('u32', value.toString());
}
exports.bigNumberToU32 = bigNumberToU32;
/**
 * @hidden
 */
function u32ToBigNumber(value) {
    return new bignumber_js_1.default(value.toString());
}
exports.u32ToBigNumber = u32ToBigNumber;
/**
 * @hidden
 */
function u16ToBigNumber(value) {
    return new bignumber_js_1.default(value.toString());
}
exports.u16ToBigNumber = u16ToBigNumber;
/**
 * @hidden
 */
function u8ToBigNumber(value) {
    return new bignumber_js_1.default(value.toString());
}
exports.u8ToBigNumber = u8ToBigNumber;
/**
 * @hidden
 */
function permissionGroupIdentifierToAgentGroup(permissionGroup, context) {
    return context.createType('PolymeshPrimitivesAgentAgentGroup', typeof permissionGroup !== 'object'
        ? permissionGroup
        : { Custom: bigNumberToU32(permissionGroup.custom, context) });
}
exports.permissionGroupIdentifierToAgentGroup = permissionGroupIdentifierToAgentGroup;
/**
 * @hidden
 */
function agentGroupToPermissionGroupIdentifier(agentGroup) {
    if (agentGroup.isFull) {
        return types_1.PermissionGroupType.Full;
    }
    else if (agentGroup.isExceptMeta) {
        return types_1.PermissionGroupType.ExceptMeta;
    }
    else if (agentGroup.isPolymeshV1CAA) {
        return types_1.PermissionGroupType.PolymeshV1Caa;
    }
    else if (agentGroup.isPolymeshV1PIA) {
        return types_1.PermissionGroupType.PolymeshV1Pia;
    }
    else {
        return { custom: u32ToBigNumber(agentGroup.asCustom) };
    }
}
exports.agentGroupToPermissionGroupIdentifier = agentGroupToPermissionGroupIdentifier;
/**
 * @hidden
 */
function authorizationToAuthorizationData(auth, context) {
    let value;
    const { type } = auth;
    if (type === types_1.AuthorizationType.AttestPrimaryKeyRotation) {
        value = stringToIdentityId(auth.value.did, context);
    }
    else if (type === types_1.AuthorizationType.RotatePrimaryKey) {
        value = null;
    }
    else if (type === types_1.AuthorizationType.JoinIdentity) {
        value = permissionsToMeshPermissions(auth.value, context);
    }
    else if (type === types_1.AuthorizationType.PortfolioCustody) {
        value = portfolioIdToMeshPortfolioId(portfolioToPortfolioId(auth.value), context);
    }
    else if (auth.type === types_1.AuthorizationType.TransferAssetOwnership ||
        auth.type === types_1.AuthorizationType.TransferTicker) {
        value = stringToTicker(auth.value, context);
    }
    else if (type === types_1.AuthorizationType.RotatePrimaryKeyToSecondary) {
        value = permissionsToMeshPermissions(auth.value, context);
    }
    else if (type === types_1.AuthorizationType.BecomeAgent) {
        const ticker = stringToTicker(auth.value.asset.ticker, context);
        if (auth.value instanceof internal_1.CustomPermissionGroup) {
            const { id } = auth.value;
            value = [ticker, permissionGroupIdentifierToAgentGroup({ custom: id }, context)];
        }
        else {
            const { type: groupType } = auth.value;
            value = [ticker, permissionGroupIdentifierToAgentGroup(groupType, context)];
        }
    }
    else {
        value = auth.value;
    }
    return context.createType('PolymeshPrimitivesAuthorizationAuthorizationData', {
        [type]: value,
    });
}
exports.authorizationToAuthorizationData = authorizationToAuthorizationData;
/**
 * @hidden
 */
function authorizationTypeToMeshAuthorizationType(authorizationType, context) {
    return context.createType('AuthorizationType', authorizationType);
}
exports.authorizationTypeToMeshAuthorizationType = authorizationTypeToMeshAuthorizationType;
/**
 * @hidden
 */
function bigNumberToBalance(value, context, divisible = true) {
    var _a;
    (0, internal_3.assertIsPositive)(value);
    if (value.isGreaterThan(constants_1.MAX_BALANCE)) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: 'The value exceeds the maximum possible balance',
            data: {
                currentValue: value,
                amountLimit: constants_1.MAX_BALANCE,
            },
        });
    }
    if (divisible) {
        if (((_a = value.decimalPlaces()) !== null && _a !== void 0 ? _a : 0) > constants_1.MAX_DECIMALS) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'The value has more decimal places than allowed',
                data: {
                    currentValue: value,
                    decimalsLimit: constants_1.MAX_DECIMALS,
                },
            });
        }
    }
    else {
        if (value.decimalPlaces()) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'The value has decimals but the Asset is indivisible',
            });
        }
    }
    return context.createType('Balance', value.shiftedBy(6).toString());
}
exports.bigNumberToBalance = bigNumberToBalance;
/**
 * @hidden
 */
function balanceToBigNumber(balance) {
    return new bignumber_js_1.default(balance.toString()).shiftedBy(-6);
}
exports.balanceToBigNumber = balanceToBigNumber;
/**
 * Assembles permissions group identifier + ticker into appropriate permission group based on group identifier
 */
function assemblePermissionGroup(permissionGroupIdentifier, ticker, context) {
    switch (permissionGroupIdentifier) {
        case types_1.PermissionGroupType.ExceptMeta:
        case types_1.PermissionGroupType.Full:
        case types_1.PermissionGroupType.PolymeshV1Caa:
        case types_1.PermissionGroupType.PolymeshV1Pia: {
            return new internal_1.KnownPermissionGroup({ type: permissionGroupIdentifier, ticker }, context);
        }
        default: {
            const { custom: id } = permissionGroupIdentifier;
            return new internal_1.CustomPermissionGroup({ id, ticker }, context);
        }
    }
}
/**
 * @hidden
 */
function agentGroupToPermissionGroup(agentGroup, ticker, context) {
    const permissionGroupIdentifier = agentGroupToPermissionGroupIdentifier(agentGroup);
    return assemblePermissionGroup(permissionGroupIdentifier, ticker, context);
}
exports.agentGroupToPermissionGroup = agentGroupToPermissionGroup;
/**
 * @hidden
 */
function authorizationDataToAuthorization(auth, context) {
    if (auth.isAttestPrimaryKeyRotation) {
        return {
            type: types_1.AuthorizationType.AttestPrimaryKeyRotation,
            value: new internal_1.Identity({
                did: identityIdToString(auth.asAttestPrimaryKeyRotation),
            }, context),
        };
    }
    if (auth.isRotatePrimaryKey) {
        return {
            type: types_1.AuthorizationType.RotatePrimaryKey,
        };
    }
    if (auth.isTransferTicker) {
        return {
            type: types_1.AuthorizationType.TransferTicker,
            value: tickerToString(auth.asTransferTicker),
        };
    }
    if (auth.isAddMultiSigSigner) {
        return {
            type: types_1.AuthorizationType.AddMultiSigSigner,
            value: accountIdToString(auth.asAddMultiSigSigner),
        };
    }
    if (auth.isTransferAssetOwnership) {
        return {
            type: types_1.AuthorizationType.TransferAssetOwnership,
            value: tickerToString(auth.asTransferAssetOwnership),
        };
    }
    if (auth.isPortfolioCustody) {
        return {
            type: types_1.AuthorizationType.PortfolioCustody,
            value: meshPortfolioIdToPortfolio(auth.asPortfolioCustody, context),
        };
    }
    if (auth.isJoinIdentity) {
        return {
            type: types_1.AuthorizationType.JoinIdentity,
            value: meshPermissionsToPermissions(auth.asJoinIdentity, context),
        };
    }
    if (auth.isAddRelayerPayingKey) {
        const [userKey, payingKey, polyxLimit] = auth.asAddRelayerPayingKey;
        return {
            type: types_1.AuthorizationType.AddRelayerPayingKey,
            value: {
                beneficiary: new internal_1.Account({ address: accountIdToString(userKey) }, context),
                subsidizer: new internal_1.Account({ address: accountIdToString(payingKey) }, context),
                allowance: balanceToBigNumber(polyxLimit),
            },
        };
    }
    if (auth.isBecomeAgent) {
        const [ticker, agentGroup] = auth.asBecomeAgent;
        return {
            type: types_1.AuthorizationType.BecomeAgent,
            value: agentGroupToPermissionGroup(agentGroup, tickerToString(ticker), context),
        };
    }
    if (auth.isRotatePrimaryKeyToSecondary) {
        return {
            type: types_1.AuthorizationType.RotatePrimaryKeyToSecondary,
            value: meshPermissionsToPermissions(auth.asRotatePrimaryKeyToSecondary, context),
        };
    }
    throw new internal_1.PolymeshError({
        code: types_1.ErrorCode.UnexpectedError,
        message: 'Unsupported Authorization Type. Please contact the Polymesh team',
        data: {
            auth: JSON.stringify(auth, null, 2),
        },
    });
}
exports.authorizationDataToAuthorization = authorizationDataToAuthorization;
/**
 * @hidden
 */
function assertMemoValid(value) {
    if (value.length > constants_1.MAX_MEMO_LENGTH) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: 'Max memo length exceeded',
            data: {
                maxLength: constants_1.MAX_MEMO_LENGTH,
            },
        });
    }
}
/**
 * @hidden
 */
function stringToMemo(value, context) {
    assertMemoValid(value);
    return context.createType('PolymeshPrimitivesMemo', (0, internal_3.padString)(value, constants_1.MAX_MEMO_LENGTH));
}
exports.stringToMemo = stringToMemo;
/**
 * @hidden
 */
function u8ToTransferStatus(status) {
    const code = status.toNumber();
    switch (code) {
        case 81: {
            return types_1.TransferStatus.Success;
        }
        case 82: {
            return types_1.TransferStatus.InsufficientBalance;
        }
        case 83: {
            return types_1.TransferStatus.InsufficientAllowance;
        }
        case 84: {
            return types_1.TransferStatus.TransfersHalted;
        }
        case 85: {
            return types_1.TransferStatus.FundsLocked;
        }
        case 86: {
            return types_1.TransferStatus.InvalidSenderAddress;
        }
        case 87: {
            return types_1.TransferStatus.InvalidReceiverAddress;
        }
        case 88: {
            return types_1.TransferStatus.InvalidOperator;
        }
        case 160: {
            return types_1.TransferStatus.InvalidSenderIdentity;
        }
        case 161: {
            return types_1.TransferStatus.InvalidReceiverIdentity;
        }
        case 162: {
            return types_1.TransferStatus.ComplianceFailure;
        }
        case 163: {
            return types_1.TransferStatus.SmartExtensionFailure;
        }
        case 164: {
            return types_1.TransferStatus.InvalidGranularity;
        }
        case 165: {
            return types_1.TransferStatus.VolumeLimitReached;
        }
        case 166: {
            return types_1.TransferStatus.BlockedTransaction;
        }
        case 168: {
            return types_1.TransferStatus.FundsLimitReached;
        }
        case 169: {
            return types_1.TransferStatus.PortfolioFailure;
        }
        case 170: {
            return types_1.TransferStatus.CustodianError;
        }
        case 171: {
            return types_1.TransferStatus.ScopeClaimMissing;
        }
        case 172: {
            return types_1.TransferStatus.TransferRestrictionFailure;
        }
        case 80: {
            return types_1.TransferStatus.Failure;
        }
        default: {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.UnexpectedError,
                message: `Unsupported status code "${status.toString()}". Please report this issue to the Polymesh team`,
            });
        }
    }
}
exports.u8ToTransferStatus = u8ToTransferStatus;
/**
 * @hidden
 */
function internalAssetTypeToAssetType(type, context) {
    return context.createType('PolymeshPrimitivesAssetAssetType', type);
}
exports.internalAssetTypeToAssetType = internalAssetTypeToAssetType;
/**
 * @hidden
 */
function internalNftTypeToNftType(type, context) {
    return context.createType('PolymeshPrimitivesAssetNonFungibleType', type);
}
exports.internalNftTypeToNftType = internalNftTypeToNftType;
/**
 * @hidden
 */
function assetTypeToKnownOrId(assetType) {
    if (assetType.isNonFungible) {
        const type = 'NonFungible';
        const rawNftType = assetType.asNonFungible;
        if (rawNftType.isDerivative) {
            return { type, value: types_1.KnownNftType.Derivative };
        }
        else if (rawNftType.isFixedIncome) {
            return { type, value: types_1.KnownNftType.FixedIncome };
        }
        else if (rawNftType.isInvoice) {
            return { type, value: types_1.KnownNftType.Invoice };
        }
        return { type, value: u32ToBigNumber(rawNftType.asCustom) };
    }
    const type = 'Fungible';
    if (assetType.isEquityCommon) {
        return { type, value: types_1.KnownAssetType.EquityCommon };
    }
    if (assetType.isEquityPreferred) {
        return { type, value: types_1.KnownAssetType.EquityPreferred };
    }
    if (assetType.isCommodity) {
        return { type, value: types_1.KnownAssetType.Commodity };
    }
    if (assetType.isFixedIncome) {
        return { type, value: types_1.KnownAssetType.FixedIncome };
    }
    if (assetType.isReit) {
        return { type, value: types_1.KnownAssetType.Reit };
    }
    if (assetType.isFund) {
        return { type, value: types_1.KnownAssetType.Fund };
    }
    if (assetType.isRevenueShareAgreement) {
        return { type, value: types_1.KnownAssetType.RevenueShareAgreement };
    }
    if (assetType.isStructuredProduct) {
        return { type, value: types_1.KnownAssetType.StructuredProduct };
    }
    if (assetType.isDerivative) {
        return { type, value: types_1.KnownAssetType.Derivative };
    }
    if (assetType.isStableCoin) {
        return { type, value: types_1.KnownAssetType.StableCoin };
    }
    return { type, value: u32ToBigNumber(assetType.asCustom) };
}
exports.assetTypeToKnownOrId = assetTypeToKnownOrId;
/**
 * @hidden
 */
function posRatioToBigNumber(postRatio) {
    const [numerator, denominator] = postRatio.map(u32ToBigNumber);
    return numerator.dividedBy(denominator);
}
exports.posRatioToBigNumber = posRatioToBigNumber;
/**
 * @hidden
 */
function nameToAssetName(value, context) {
    const { polymeshApi: { consts: { asset: { assetNameMaxLength }, }, }, } = context;
    const nameMaxLength = u32ToBigNumber(assetNameMaxLength);
    if (nameMaxLength.lt(value.length)) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: 'Asset name length exceeded',
            data: {
                maxLength: nameMaxLength,
            },
        });
    }
    return stringToBytes(value, context);
}
exports.nameToAssetName = nameToAssetName;
/**
 * @hidden
 */
function fundingRoundToAssetFundingRound(value, context) {
    const { polymeshApi: { consts: { asset: { fundingRoundNameMaxLength }, }, }, } = context;
    const nameMaxLength = u32ToBigNumber(fundingRoundNameMaxLength);
    if (nameMaxLength.lt(value.length)) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: 'Asset funding round name length exceeded',
            data: {
                maxLength: nameMaxLength,
            },
        });
    }
    return stringToBytes(value, context);
}
exports.fundingRoundToAssetFundingRound = fundingRoundToAssetFundingRound;
/**
 * @hidden
 */
function isIsinValid(isin) {
    isin = isin.toUpperCase();
    if (!/^[0-9A-Z]{12}$/.test(isin)) {
        return false;
    }
    const v = [];
    (0, lodash_1.rangeRight)(11).forEach(i => {
        const c = parseInt(isin.charAt(i));
        if (isNaN(c)) {
            const letterCode = isin.charCodeAt(i) - 55;
            v.push(letterCode % 10);
            v.push(Math.floor(letterCode / 10));
        }
        else {
            v.push(Number(c));
        }
    });
    let sum = 0;
    (0, lodash_1.range)(v.length).forEach(i => {
        if (i % 2 === 0) {
            const d = v[i] * 2;
            sum += Math.floor(d / 10);
            sum += d % 10;
        }
        else {
            sum += v[i];
        }
    });
    return (10 - (sum % 10)) % 10 === Number(isin[isin.length - 1]);
}
exports.isIsinValid = isIsinValid;
/**
 * @hidden
 */
function validateCusipChecksum(cusip) {
    let sum = 0;
    // cSpell: disable-next-line
    const cusipChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ*@#'.split('');
    const cusipLength = cusip.length - 1;
    (0, lodash_1.range)(cusipLength).forEach(i => {
        const item = cusip[i];
        const code = item.charCodeAt(0);
        let num;
        if (code >= 'A'.charCodeAt(0) && code <= 'Z'.charCodeAt(0)) {
            num = cusipChars.indexOf(item) + 10;
        }
        else {
            num = Number(item);
        }
        if (i % 2 !== 0) {
            num *= 2;
        }
        num = (num % 10) + Math.floor(num / 10);
        sum += num;
    });
    return (10 - (sum % 10)) % 10 === Number(cusip[cusip.length - 1]);
}
/**
 * @hidden
 *
 * @note CINS and CUSIP use the same validation
 */
function isCusipValid(cusip) {
    cusip = cusip.toUpperCase();
    if (!/^[0-9A-Z@#*]{9}$/.test(cusip)) {
        return false;
    }
    return validateCusipChecksum(cusip);
}
exports.isCusipValid = isCusipValid;
/**
 * @hidden
 */
function isLeiValid(lei) {
    lei = lei.toUpperCase();
    if (!/^[0-9A-Z]{18}\d{2}$/.test(lei)) {
        return false;
    }
    return (0, iso_7064_1.computeWithoutCheck)(lei) === 1;
}
exports.isLeiValid = isLeiValid;
/**
 * Check if given string is a valid FIGI identifier
 *
 * A FIGI consists of three parts:
 *   - a two-character prefix which is a combination of upper case consonants with the following exceptions: BS, BM, GG, GB, GH, KY, VG
 *   - a 'G' as the third character;
 *   - an eight-character combination of upper case consonants and the numerals 0 – 9
 *   - a single check digit
 * @hidden
 */
function isFigiValid(figi) {
    figi = figi.toUpperCase();
    if (['BS', 'BM', 'GG', 'GB', 'GH', 'KY', 'VG'].includes(figi.substring(0, 2)) ||
        !/^[B-DF-HJ-NP-TV-Z]{2}G[B-DF-HJ-NP-TV-Z0-9]{8}\d$/.test(figi)) {
        return false;
    }
    return validateCusipChecksum(figi);
}
exports.isFigiValid = isFigiValid;
/**
 * @hidden
 */
function securityIdentifierToAssetIdentifier(identifier, context) {
    const { type, value } = identifier;
    let error = false;
    switch (type) {
        case types_1.SecurityIdentifierType.Isin: {
            if (!isIsinValid(value)) {
                error = true;
            }
            break;
        }
        case types_1.SecurityIdentifierType.Lei: {
            if (!isLeiValid(value)) {
                error = true;
            }
            break;
        }
        case types_1.SecurityIdentifierType.Figi: {
            if (!isFigiValid(value)) {
                error = true;
            }
            break;
        }
        // CINS and CUSIP use the same validation
        default: {
            if (!isCusipValid(value)) {
                error = true;
            }
        }
    }
    if (error) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: `Invalid security identifier ${value} of type ${type}`,
        });
    }
    return context.createType('PolymeshPrimitivesAssetIdentifier', { [type]: value });
}
exports.securityIdentifierToAssetIdentifier = securityIdentifierToAssetIdentifier;
/**
 * @hidden
 */
function assetIdentifierToSecurityIdentifier(identifier) {
    if (identifier.isCusip) {
        return {
            type: types_1.SecurityIdentifierType.Cusip,
            value: (0, util_1.u8aToString)(identifier.asCusip),
        };
    }
    if (identifier.isIsin) {
        return {
            type: types_1.SecurityIdentifierType.Isin,
            value: (0, util_1.u8aToString)(identifier.asIsin),
        };
    }
    if (identifier.isCins) {
        return {
            type: types_1.SecurityIdentifierType.Cins,
            value: (0, util_1.u8aToString)(identifier.asCins),
        };
    }
    if (identifier.isFigi) {
        return {
            type: types_1.SecurityIdentifierType.Figi,
            value: (0, util_1.u8aToString)(identifier.asFigi),
        };
    }
    return {
        type: types_1.SecurityIdentifierType.Lei,
        value: (0, util_1.u8aToString)(identifier.asLei),
    };
}
exports.assetIdentifierToSecurityIdentifier = assetIdentifierToSecurityIdentifier;
/**
 * @hidden
 */
function stringToDocumentHash(docHash, context) {
    if (docHash === undefined) {
        return context.createType('PolymeshPrimitivesDocumentHash', 'None');
    }
    if (!(0, util_1.isHex)(docHash, -1, true)) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: 'Document hash must be a hexadecimal string prefixed by 0x',
        });
    }
    const { length } = docHash;
    // array of Hash types (H128, H160, etc) and their corresponding hex lengths
    const hashTypes = [32, 40, 48, 56, 64, 80, 96, 128].map(max => ({
        maxLength: max + 2,
        key: `H${max * 4}`,
    }));
    const type = hashTypes.find(({ maxLength: max }) => length <= max);
    if (!type) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: 'Document hash exceeds max length',
        });
    }
    const { maxLength, key } = type;
    return context.createType('PolymeshPrimitivesDocumentHash', {
        [key]: (0, util_1.hexToU8a)(docHash.padEnd(maxLength, '0')),
    });
}
exports.stringToDocumentHash = stringToDocumentHash;
/**
 * @hidden
 */
function documentHashToString(docHash) {
    if (docHash.isNone) {
        return;
    }
    if (docHash.isH128) {
        return (0, util_1.u8aToHex)(docHash.asH128);
    }
    if (docHash.isH160) {
        return (0, util_1.u8aToHex)(docHash.asH160);
    }
    if (docHash.isH192) {
        return (0, util_1.u8aToHex)(docHash.asH192);
    }
    if (docHash.isH224) {
        return (0, util_1.u8aToHex)(docHash.asH224);
    }
    if (docHash.isH256) {
        return (0, util_1.u8aToHex)(docHash.asH256);
    }
    if (docHash.isH320) {
        return (0, util_1.u8aToHex)(docHash.asH320);
    }
    if (docHash.isH384) {
        return (0, util_1.u8aToHex)(docHash.asH384);
    }
    return (0, util_1.u8aToHex)(docHash.asH512);
}
exports.documentHashToString = documentHashToString;
/**
 * @hidden
 */
function assetDocumentToDocument({ uri, contentHash, name, filedAt, type }, context) {
    return context.createType('PolymeshPrimitivesDocument', {
        uri: stringToBytes(uri, context),
        name: stringToBytes(name, context),
        contentHash: stringToDocumentHash(contentHash, context),
        docType: (0, internal_3.optionize)(stringToBytes)(type, context),
        filingDate: (0, internal_3.optionize)(dateToMoment)(filedAt, context),
    });
}
exports.assetDocumentToDocument = assetDocumentToDocument;
/**
 * @hidden
 */
function documentToAssetDocument({ uri, contentHash: hash, name, docType, filingDate, }) {
    const filedAt = filingDate.unwrapOr(undefined);
    const type = docType.unwrapOr(undefined);
    const contentHash = documentHashToString(hash);
    let doc = {
        uri: bytesToString(uri),
        name: bytesToString(name),
    };
    if (contentHash) {
        doc = Object.assign(Object.assign({}, doc), { contentHash });
    }
    if (filedAt) {
        doc = Object.assign(Object.assign({}, doc), { filedAt: momentToDate(filedAt) });
    }
    if (type) {
        doc = Object.assign(Object.assign({}, doc), { type: bytesToString(type) });
    }
    return doc;
}
exports.documentToAssetDocument = documentToAssetDocument;
/**
 * @hidden
 */
function cddStatusToBoolean(cddStatus) {
    if (cddStatus.isOk) {
        return true;
    }
    return false;
}
exports.cddStatusToBoolean = cddStatusToBoolean;
/**
 * @hidden
 */
function canTransferResultToTransferStatus(canTransferResult) {
    if (canTransferResult.isErr) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.UnexpectedError,
            message: `Error while checking transfer validity: ${bytesToString(canTransferResult.asErr)}`,
        });
    }
    return u8ToTransferStatus(canTransferResult.asOk);
}
exports.canTransferResultToTransferStatus = canTransferResultToTransferStatus;
/**
 * @hidden
 */
function scopeToMeshScope(scope, context) {
    const { type, value } = scope;
    let scopeValue;
    switch (type) {
        case types_1.ScopeType.Ticker:
            scopeValue = stringToTicker(value, context);
            break;
        case types_1.ScopeType.Identity:
            scopeValue = stringToIdentityId(value, context);
            break;
        default:
            scopeValue = value;
            break;
    }
    return context.createType('Scope', {
        [type]: scopeValue,
    });
}
exports.scopeToMeshScope = scopeToMeshScope;
/**
 * @hidden
 */
function meshScopeToScope(scope) {
    if (scope.isTicker) {
        return {
            type: types_1.ScopeType.Ticker,
            value: tickerToString(scope.asTicker),
        };
    }
    if (scope.isIdentity) {
        return {
            type: types_1.ScopeType.Identity,
            value: identityIdToString(scope.asIdentity),
        };
    }
    return {
        type: types_1.ScopeType.Custom,
        value: (0, util_1.u8aToString)(scope.asCustom),
    };
}
exports.meshScopeToScope = meshScopeToScope;
/**
 * @hidden
 */
function stringToCddId(cddId, context) {
    return context.createType('PolymeshPrimitivesCddId', cddId);
}
exports.stringToCddId = stringToCddId;
/**
 * @hidden
 */
function cddIdToString(cddId) {
    return cddId.toString();
}
exports.cddIdToString = cddIdToString;
/**
 * @hidden
 */
function claimToMeshClaim(claim, context) {
    let value;
    switch (claim.type) {
        case types_1.ClaimType.CustomerDueDiligence: {
            value = stringToCddId(claim.id, context);
            break;
        }
        case types_1.ClaimType.Jurisdiction: {
            const { code, scope } = claim;
            value = (0, utils_3.tuple)(code, scopeToMeshScope(scope, context));
            break;
        }
        default: {
            value = scopeToMeshScope(claim.scope, context);
        }
    }
    return context.createType('PolymeshPrimitivesIdentityClaimClaim', { [claim.type]: value });
}
exports.claimToMeshClaim = claimToMeshClaim;
/**
 * @hidden
 */
function middlewareScopeToScope(scope) {
    const { type, value } = scope;
    switch (type) {
        case typesV1_1.ClaimScopeTypeEnum.Ticker:
            return { type: types_1.ScopeType.Ticker, value: (0, internal_3.removePadding)(value) };
        case typesV1_1.ClaimScopeTypeEnum.Identity:
        case typesV1_1.ClaimScopeTypeEnum.Custom:
            return { type: scope.type, value };
    }
    throw new internal_1.PolymeshError({
        code: types_1.ErrorCode.UnexpectedError,
        message: 'Unsupported Scope Type. Please contact the Polymesh team',
        data: {
            scope,
        },
    });
}
exports.middlewareScopeToScope = middlewareScopeToScope;
/**
 * @hidden
 */
function scopeToMiddlewareScope(scope, padTicker = true) {
    const { type, value } = scope;
    switch (type) {
        case types_1.ScopeType.Ticker:
            return {
                type: typesV1_1.ClaimScopeTypeEnum.Ticker,
                value: padTicker ? (0, lodash_1.padEnd)(value, 12, '\0') : value,
            };
        case types_1.ScopeType.Identity:
        case types_1.ScopeType.Custom:
            return { type: typesV1_1.ClaimScopeTypeEnum[scope.type], value };
    }
}
exports.scopeToMiddlewareScope = scopeToMiddlewareScope;
/**
 * @hidden
 */
function middlewareEventDetailsToEventIdentifier(block, eventIdx = 0) {
    const { blockId, datetime, hash } = block;
    return {
        blockNumber: new bignumber_js_1.default(blockId),
        blockHash: hash,
        blockDate: new Date(`${datetime}`),
        eventIndex: new bignumber_js_1.default(eventIdx),
    };
}
exports.middlewareEventDetailsToEventIdentifier = middlewareEventDetailsToEventIdentifier;
/**
 * @hidden
 */
function meshClaimToClaim(claim) {
    if (claim.isJurisdiction) {
        const [code, scope] = claim.asJurisdiction;
        return {
            type: types_1.ClaimType.Jurisdiction,
            code: (0, utils_2.meshCountryCodeToCountryCode)(code),
            scope: meshScopeToScope(scope),
        };
    }
    if (claim.isAccredited) {
        return {
            type: types_1.ClaimType.Accredited,
            scope: meshScopeToScope(claim.asAccredited),
        };
    }
    if (claim.isAffiliate) {
        return {
            type: types_1.ClaimType.Affiliate,
            scope: meshScopeToScope(claim.asAffiliate),
        };
    }
    if (claim.isBuyLockup) {
        return {
            type: types_1.ClaimType.BuyLockup,
            scope: meshScopeToScope(claim.asBuyLockup),
        };
    }
    if (claim.isSellLockup) {
        return {
            type: types_1.ClaimType.SellLockup,
            scope: meshScopeToScope(claim.asSellLockup),
        };
    }
    if (claim.isCustomerDueDiligence) {
        return {
            type: types_1.ClaimType.CustomerDueDiligence,
            id: cddIdToString(claim.asCustomerDueDiligence),
        };
    }
    if (claim.isKnowYourCustomer) {
        return {
            type: types_1.ClaimType.KnowYourCustomer,
            scope: meshScopeToScope(claim.asKnowYourCustomer),
        };
    }
    if (claim.isExempted) {
        return {
            type: types_1.ClaimType.Exempted,
            scope: meshScopeToScope(claim.asExempted),
        };
    }
    return {
        type: types_1.ClaimType.Blocked,
        scope: meshScopeToScope(claim.asBlocked),
    };
}
exports.meshClaimToClaim = meshClaimToClaim;
/**
 * @hidden
 */
function statsClaimToStatClaimInputType(claim) {
    if (claim.isJurisdiction) {
        return {
            type: types_1.ClaimType.Jurisdiction,
        };
    }
    else if (claim.isAccredited) {
        return { type: types_1.ClaimType.Accredited };
    }
    else {
        return { type: types_1.ClaimType.Affiliate };
    }
}
exports.statsClaimToStatClaimInputType = statsClaimToStatClaimInputType;
/**
 * @hidden
 */
function stringToTargetIdentity(did, context) {
    return context.createType('PolymeshPrimitivesConditionTargetIdentity', 
    // eslint-disable-next-line @typescript-eslint/naming-convention
    did ? { Specific: stringToIdentityId(did, context) } : 'ExternalAgent');
}
exports.stringToTargetIdentity = stringToTargetIdentity;
/**
 * @hidden
 */
function meshClaimTypeToClaimType(claimType) {
    if (claimType.isJurisdiction) {
        return types_1.ClaimType.Jurisdiction;
    }
    if (claimType.isAccredited) {
        return types_1.ClaimType.Accredited;
    }
    if (claimType.isAffiliate) {
        return types_1.ClaimType.Affiliate;
    }
    if (claimType.isBuyLockup) {
        return types_1.ClaimType.BuyLockup;
    }
    if (claimType.isSellLockup) {
        return types_1.ClaimType.SellLockup;
    }
    if (claimType.isCustomerDueDiligence) {
        return types_1.ClaimType.CustomerDueDiligence;
    }
    if (claimType.isKnowYourCustomer) {
        return types_1.ClaimType.KnowYourCustomer;
    }
    if (claimType.isExempted) {
        return types_1.ClaimType.Exempted;
    }
    return types_1.ClaimType.Blocked;
}
exports.meshClaimTypeToClaimType = meshClaimTypeToClaimType;
/**
 * @hidden
 */
function trustedIssuerToTrustedClaimIssuer(trustedIssuer, context) {
    const { issuer, trustedFor: claimTypes } = trustedIssuer;
    const identity = new internal_1.Identity({ did: identityIdToString(issuer) }, context);
    let trustedFor = null;
    if (claimTypes.isSpecific) {
        trustedFor = claimTypes.asSpecific.map(meshClaimTypeToClaimType);
    }
    return {
        identity,
        trustedFor,
    };
}
exports.trustedIssuerToTrustedClaimIssuer = trustedIssuerToTrustedClaimIssuer;
/**
 * @hidden
 */
function trustedClaimIssuerToTrustedIssuer(issuer, context) {
    const { trustedFor: claimTypes, identity } = issuer;
    const did = signerToString(identity);
    let trustedFor;
    if (!claimTypes) {
        trustedFor = 'Any';
    }
    else {
        trustedFor = { Specific: claimTypes };
    }
    return context.createType('PolymeshPrimitivesConditionTrustedIssuer', {
        issuer: stringToIdentityId(did, context),
        trustedFor,
    });
}
exports.trustedClaimIssuerToTrustedIssuer = trustedClaimIssuerToTrustedIssuer;
/**
 * @hidden
 */
function requirementToComplianceRequirement(requirement, context) {
    const senderConditions = [];
    const receiverConditions = [];
    requirement.conditions.forEach(condition => {
        let conditionContent;
        let { type } = condition;
        if ((0, typeguards_1.isSingleClaimCondition)(condition)) {
            const { claim } = condition;
            conditionContent = claimToMeshClaim(claim, context);
        }
        else if ((0, typeguards_1.isMultiClaimCondition)(condition)) {
            const { claims } = condition;
            conditionContent = claims.map(claim => claimToMeshClaim(claim, context));
        }
        else if ((0, typeguards_1.isIdentityCondition)(condition)) {
            const { identity } = condition;
            conditionContent = stringToTargetIdentity(signerToString(identity), context);
        }
        else {
            // IsExternalAgent does not exist as a condition type in Polymesh, it's SDK sugar
            type = types_1.ConditionType.IsIdentity;
            conditionContent = stringToTargetIdentity(null, context);
        }
        const { target, trustedClaimIssuers = [] } = condition;
        const meshCondition = context.createType('PolymeshPrimitivesCondition', {
            conditionType: {
                [type]: conditionContent,
            },
            issuers: trustedClaimIssuers.map(issuer => trustedClaimIssuerToTrustedIssuer(issuer, context)),
        });
        if ([types_1.ConditionTarget.Both, types_1.ConditionTarget.Receiver].includes(target)) {
            receiverConditions.push(meshCondition);
        }
        if ([types_1.ConditionTarget.Both, types_1.ConditionTarget.Sender].includes(target)) {
            senderConditions.push(meshCondition);
        }
    });
    return context.createType('PolymeshPrimitivesComplianceManagerComplianceRequirement', {
        senderConditions,
        receiverConditions,
        id: bigNumberToU32(requirement.id, context),
    });
}
exports.requirementToComplianceRequirement = requirementToComplianceRequirement;
/**
 * @hidden
 */
function meshConditionTypeToCondition(meshConditionType, context) {
    if (meshConditionType.isIsPresent) {
        return {
            type: types_1.ConditionType.IsPresent,
            claim: meshClaimToClaim(meshConditionType.asIsPresent),
        };
    }
    if (meshConditionType.isIsAbsent) {
        return {
            type: types_1.ConditionType.IsAbsent,
            claim: meshClaimToClaim(meshConditionType.asIsAbsent),
        };
    }
    if (meshConditionType.isIsAnyOf) {
        return {
            type: types_1.ConditionType.IsAnyOf,
            claims: meshConditionType.asIsAnyOf.map(claim => meshClaimToClaim(claim)),
        };
    }
    if (meshConditionType.isIsIdentity) {
        const target = meshConditionType.asIsIdentity;
        if (target.isExternalAgent) {
            return {
                type: types_1.ConditionType.IsExternalAgent,
            };
        }
        return {
            type: types_1.ConditionType.IsIdentity,
            identity: new internal_1.Identity({ did: identityIdToString(target.asSpecific) }, context),
        };
    }
    return {
        type: types_1.ConditionType.IsNoneOf,
        claims: meshConditionType.asIsNoneOf.map(claim => meshClaimToClaim(claim)),
    };
}
/**
 * @hidden
 * @note - the data for this method comes from an RPC call, which hasn't been updated to the camelCase types
 */
function complianceRequirementResultToRequirementCompliance(complianceRequirement, context) {
    const conditions = [];
    const conditionCompliancesAreEqual = ({ condition: aCondition, complies: aComplies }, { condition: bCondition, complies: bComplies }) => (0, internal_3.conditionsAreEqual)(aCondition, bCondition) && aComplies === bComplies;
    complianceRequirement.senderConditions.forEach(({ condition: { conditionType, issuers }, result }) => {
        const newCondition = {
            condition: Object.assign(Object.assign({}, meshConditionTypeToCondition(conditionType, context)), { target: types_1.ConditionTarget.Sender, trustedClaimIssuers: issuers.map(trustedIssuer => trustedIssuerToTrustedClaimIssuer(trustedIssuer, context)) }),
            complies: boolToBoolean(result),
        };
        const existingCondition = conditions.find(condition => conditionCompliancesAreEqual(condition, newCondition));
        if (!existingCondition) {
            conditions.push(newCondition);
        }
    });
    complianceRequirement.receiverConditions.forEach(({ condition: { conditionType, issuers }, result }) => {
        const newCondition = {
            condition: Object.assign(Object.assign({}, meshConditionTypeToCondition(conditionType, context)), { target: types_1.ConditionTarget.Receiver, trustedClaimIssuers: issuers.map(trustedIssuer => trustedIssuerToTrustedClaimIssuer(trustedIssuer, context)) }),
            complies: boolToBoolean(result),
        };
        const existingCondition = conditions.find(condition => conditionCompliancesAreEqual(condition, newCondition));
        if (existingCondition && existingCondition.condition.target === types_1.ConditionTarget.Sender) {
            existingCondition.condition.target = types_1.ConditionTarget.Both;
        }
        else {
            conditions.push(newCondition);
        }
    });
    return {
        id: u32ToBigNumber(complianceRequirement.id),
        conditions,
        complies: boolToBoolean(complianceRequirement.result),
    };
}
exports.complianceRequirementResultToRequirementCompliance = complianceRequirementResultToRequirementCompliance;
/**
 * @hidden
 */
function complianceRequirementToRequirement(complianceRequirement, context) {
    const conditions = [];
    complianceRequirement.senderConditions.forEach(({ conditionType, issuers }) => {
        const newCondition = Object.assign(Object.assign({}, meshConditionTypeToCondition(conditionType, context)), { target: types_1.ConditionTarget.Sender });
        if (issuers.length) {
            newCondition.trustedClaimIssuers = issuers.map(trustedIssuer => trustedIssuerToTrustedClaimIssuer(trustedIssuer, context));
        }
        const existingCondition = conditions.find(condition => (0, internal_3.conditionsAreEqual)(condition, newCondition));
        if (!existingCondition) {
            conditions.push(newCondition);
        }
    });
    complianceRequirement.receiverConditions.forEach(({ conditionType, issuers }) => {
        const newCondition = Object.assign(Object.assign({}, meshConditionTypeToCondition(conditionType, context)), { target: types_1.ConditionTarget.Receiver });
        if (issuers.length) {
            newCondition.trustedClaimIssuers = issuers.map(trustedIssuer => trustedIssuerToTrustedClaimIssuer(trustedIssuer, context));
        }
        const existingCondition = conditions.find(condition => (0, internal_3.conditionsAreEqual)(condition, newCondition));
        if (existingCondition && existingCondition.target === types_1.ConditionTarget.Sender) {
            existingCondition.target = types_1.ConditionTarget.Both;
        }
        else {
            conditions.push(newCondition);
        }
    });
    return {
        id: u32ToBigNumber(complianceRequirement.id),
        conditions,
    };
}
exports.complianceRequirementToRequirement = complianceRequirementToRequirement;
/**
 * @hidden
 */
function txTagToProtocolOp(tag, context) {
    const protocolOpTags = [
        types_1.TxTags.asset.RegisterTicker,
        types_1.TxTags.asset.Issue,
        types_1.TxTags.asset.AddDocuments,
        types_1.TxTags.asset.CreateAsset,
        types_1.TxTags.capitalDistribution.Distribute,
        types_1.TxTags.checkpoint.CreateSchedule,
        types_1.TxTags.complianceManager.AddComplianceRequirement,
        types_1.TxTags.identity.CddRegisterDid,
        types_1.TxTags.identity.AddClaim,
        types_1.TxTags.identity.AddSecondaryKeysWithAuthorization,
        types_1.TxTags.pips.Propose,
        types_1.TxTags.corporateBallot.AttachBallot,
        types_1.TxTags.capitalDistribution.Distribute,
    ];
    const [moduleName, extrinsicName] = tag.split('.');
    const value = `${(0, util_1.stringUpperFirst)(moduleName)}${(0, util_1.stringUpperFirst)(extrinsicName)}`;
    if (!(0, lodash_1.includes)(protocolOpTags, tag)) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: `${value} does not match any PolymeshCommonUtilitiesProtocolFeeProtocolOp`,
        });
    }
    return context.createType('PolymeshCommonUtilitiesProtocolFeeProtocolOp', value);
}
exports.txTagToProtocolOp = txTagToProtocolOp;
/**
 * @hidden
 */
function extrinsicIdentifierToTxTag(extrinsicIdentifier) {
    const { moduleId, callId } = extrinsicIdentifier;
    let moduleName;
    for (const txTagItem in types_1.TxTags) {
        if (txTagItem.toLowerCase() === moduleId) {
            moduleName = txTagItem;
        }
    }
    return `${moduleName}.${(0, lodash_1.camelCase)(callId)}`;
}
exports.extrinsicIdentifierToTxTag = extrinsicIdentifierToTxTag;
/**
 * @hidden
 */
function txTagToExtrinsicIdentifier(tag) {
    const [moduleName, extrinsicName] = tag.split('.');
    return {
        moduleId: moduleName.toLowerCase(),
        callId: (0, lodash_1.snakeCase)(extrinsicName),
    };
}
exports.txTagToExtrinsicIdentifier = txTagToExtrinsicIdentifier;
/**
 * @hidden
 */
function assetComplianceResultToCompliance(assetComplianceResult, context) {
    const { requirements: rawRequirements, result, paused } = assetComplianceResult;
    const requirements = rawRequirements.map(requirement => complianceRequirementResultToRequirementCompliance(requirement, context));
    return {
        requirements,
        complies: boolToBoolean(paused) || boolToBoolean(result),
    };
}
exports.assetComplianceResultToCompliance = assetComplianceResultToCompliance;
/**
 * @hidden
 */
function moduleAddressToString(moduleAddress, context) {
    return (0, util_crypto_1.encodeAddress)((0, util_1.stringToU8a)((0, internal_3.padString)(moduleAddress, constants_1.MAX_MODULE_LENGTH)), context.ss58Format.toNumber());
}
exports.moduleAddressToString = moduleAddressToString;
/**
 * @hidden
 */
function keyToAddress(key, context) {
    if (!key.startsWith('0x')) {
        key = `0x${key}`;
    }
    return (0, util_crypto_1.encodeAddress)(key, context.ss58Format.toNumber());
}
exports.keyToAddress = keyToAddress;
/**
 * @hidden
 */
function addressToKey(address, context) {
    return (0, util_1.u8aToHex)((0, util_crypto_1.decodeAddress)(address, constants_1.IGNORE_CHECKSUM, context.ss58Format.toNumber()));
}
exports.addressToKey = addressToKey;
/**
 *
 */
const coerceHexToString = (input) => {
    if ((0, util_1.hexHasPrefix)(input)) {
        return (0, internal_3.removePadding)((0, util_1.hexToString)(input));
    }
    return input;
};
exports.coerceHexToString = coerceHexToString;
/**
 * @hidden
 */
function transactionHexToTxTag(bytes, context) {
    const { section, method } = context.createType('Call', bytes);
    return extrinsicIdentifierToTxTag({
        moduleId: section.toLowerCase(),
        callId: method,
    });
}
exports.transactionHexToTxTag = transactionHexToTxTag;
/**
 * @hidden
 */
function transactionToTxTag(tx) {
    return `${tx.section}.${tx.method}`;
}
exports.transactionToTxTag = transactionToTxTag;
/**
 * @hidden
 */
function secondaryAccountToMeshSecondaryKey(secondaryKey, context) {
    const { account, permissions } = secondaryKey;
    return context.createType('PolymeshPrimitivesSecondaryKey', {
        signer: signerValueToSignatory(signerToSignerValue(account), context),
        permissions: permissionsToMeshPermissions(permissions, context),
    });
}
exports.secondaryAccountToMeshSecondaryKey = secondaryAccountToMeshSecondaryKey;
/**
 * @hidden
 */
function meshVenueTypeToVenueType(type) {
    if (type.isOther) {
        return types_1.VenueType.Other;
    }
    if (type.isDistribution) {
        return types_1.VenueType.Distribution;
    }
    if (type.isSto) {
        return types_1.VenueType.Sto;
    }
    return types_1.VenueType.Exchange;
}
exports.meshVenueTypeToVenueType = meshVenueTypeToVenueType;
/**
 * @hidden
 */
function venueTypeToMeshVenueType(type, context) {
    return context.createType('PolymeshPrimitivesSettlementVenueType', type);
}
exports.venueTypeToMeshVenueType = venueTypeToMeshVenueType;
/**
 * @hidden
 */
function meshInstructionStatusToInstructionStatus(instruction) {
    if (instruction.isPending) {
        return internal_2.InstructionStatus.Pending;
    }
    if (instruction.isFailed) {
        return internal_2.InstructionStatus.Failed;
    }
    if (instruction.isRejected) {
        return internal_2.InstructionStatus.Rejected;
    }
    if (instruction.isSuccess) {
        return internal_2.InstructionStatus.Success;
    }
    return internal_2.InstructionStatus.Unknown;
}
exports.meshInstructionStatusToInstructionStatus = meshInstructionStatusToInstructionStatus;
/**
 * @hidden
 */
function meshAffirmationStatusToAffirmationStatus(status) {
    if (status.isUnknown) {
        return types_1.AffirmationStatus.Unknown;
    }
    if (status.isPending) {
        return types_1.AffirmationStatus.Pending;
    }
    return types_1.AffirmationStatus.Affirmed;
}
exports.meshAffirmationStatusToAffirmationStatus = meshAffirmationStatusToAffirmationStatus;
/**
 * @hidden
 */
function meshSettlementTypeToEndCondition(type) {
    if (type.isSettleOnBlock) {
        return { type: types_1.InstructionType.SettleOnBlock, endBlock: u32ToBigNumber(type.asSettleOnBlock) };
    }
    if (type.isSettleManual) {
        return {
            type: types_1.InstructionType.SettleManual,
            endAfterBlock: u32ToBigNumber(type.asSettleManual),
        };
    }
    return { type: types_1.InstructionType.SettleOnAffirmation };
}
exports.meshSettlementTypeToEndCondition = meshSettlementTypeToEndCondition;
/**
 * @hidden
 */
function endConditionToSettlementType(endCondition, context) {
    let value;
    const { type } = endCondition;
    switch (type) {
        case types_1.InstructionType.SettleOnBlock:
            value = { [types_1.InstructionType.SettleOnBlock]: bigNumberToU32(endCondition.endBlock, context) };
            break;
        case types_1.InstructionType.SettleManual:
            value = {
                [types_1.InstructionType.SettleManual]: bigNumberToU32(endCondition.endAfterBlock, context),
            };
            break;
        default:
            value = types_1.InstructionType.SettleOnAffirmation;
    }
    return context.createType('PolymeshPrimitivesSettlementSettlementType', value);
}
exports.endConditionToSettlementType = endConditionToSettlementType;
/**
 * @hidden
 */
function middlewareClaimToClaimData(claim, context) {
    const { targetId, issuerId, issuanceDate, lastUpdateDate, expiry, type, jurisdiction, scope, cddId, } = claim;
    return {
        target: new internal_1.Identity({ did: targetId }, context),
        issuer: new internal_1.Identity({ did: issuerId }, context),
        issuedAt: new Date(parseFloat(issuanceDate)),
        lastUpdatedAt: new Date(parseFloat(lastUpdateDate)),
        expiry: expiry ? new Date(parseFloat(expiry)) : null,
        claim: (0, internal_3.createClaim)(type, jurisdiction, scope, cddId),
    };
}
exports.middlewareClaimToClaimData = middlewareClaimToClaimData;
/**
 * @hidden
 */
function toIdentityWithClaimsArray(data, context, groupByAttribute) {
    const groupedData = (0, lodash_1.groupBy)(data, groupByAttribute);
    return (0, lodash_1.map)(groupedData, (claims, did) => ({
        identity: new internal_1.Identity({ did }, context),
        claims: claims.map(claim => middlewareClaimToClaimData(claim, context)),
    }));
}
exports.toIdentityWithClaimsArray = toIdentityWithClaimsArray;
/**
 * @hidden
 */
function nftToMeshNft(ticker, ids, context) {
    return context.createType('PolymeshPrimitivesNftNfTs', {
        ticker: stringToTicker(ticker, context),
        ids: ids.map(id => bigNumberToU64(id, context)),
    });
}
exports.nftToMeshNft = nftToMeshNft;
/**
 * @hidden
 */
function fungibleMovementToPortfolioFund(portfolioItem, context) {
    const { asset, amount, memo } = portfolioItem;
    return context.createType('PolymeshPrimitivesPortfolioFund', {
        description: {
            Fungible: {
                ticker: stringToTicker((0, internal_3.asTicker)(asset), context),
                amount: bigNumberToBalance(amount, context),
            },
        },
        memo: (0, internal_3.optionize)(stringToMemo)(memo, context),
    });
}
exports.fungibleMovementToPortfolioFund = fungibleMovementToPortfolioFund;
/**
 * @hidden
 */
function nftMovementToPortfolioFund(portfolioItem, context) {
    const { asset, nfts, memo } = portfolioItem;
    return context.createType('PolymeshPrimitivesPortfolioFund', {
        description: {
            NonFungible: {
                ticker: stringToTicker((0, internal_3.asTicker)(asset), context),
                ids: nfts.map(nftId => bigNumberToU64((0, internal_3.asNftId)(nftId), context)),
            },
        },
        memo: (0, internal_3.optionize)(stringToMemo)(memo, context),
    });
}
exports.nftMovementToPortfolioFund = nftMovementToPortfolioFund;
/**
 * @hidden
 */
function claimTypeToMeshClaimType(claimType, context) {
    return context.createType('PolymeshPrimitivesIdentityClaimClaimType', claimType);
}
exports.claimTypeToMeshClaimType = claimTypeToMeshClaimType;
/**
 * @hidden
 */
function claimIssuerToMeshClaimIssuer(claimIssuer, context) {
    const claimType = claimTypeToMeshClaimType(claimIssuer.claimType, context);
    const identityId = stringToIdentityId(claimIssuer.issuer.did, context);
    return [claimType, identityId];
}
exports.claimIssuerToMeshClaimIssuer = claimIssuerToMeshClaimIssuer;
/**
 * @hidden
 */
function transferRestrictionToPolymeshTransferCondition(restriction, context) {
    const { type, value } = restriction;
    let restrictionType;
    let restrictionValue;
    const extractClaimValue = (claim) => {
        if (claim.type === types_1.ClaimType.Accredited) {
            return booleanToBool(claim.accredited, context);
        }
        else if (claim.type === types_1.ClaimType.Affiliate) {
            return booleanToBool(claim.affiliate, context);
        }
        else {
            return (0, internal_3.optionize)(utils_2.countryCodeToMeshCountryCode)(claim.countryCode, context);
        }
    };
    if (type === types_1.TransferRestrictionType.Count) {
        restrictionType = 'MaxInvestorCount';
        restrictionValue = bigNumberToU64(value, context);
    }
    else if (type === types_1.TransferRestrictionType.Percentage) {
        restrictionType = 'MaxInvestorOwnership';
        restrictionValue = percentageToPermill(value, context);
    }
    else if (type === types_1.TransferRestrictionType.ClaimCount ||
        type === types_1.TransferRestrictionType.ClaimPercentage) {
        let rawMin;
        let rawMax;
        const { min, max, claim, issuer } = value;
        if (type === types_1.TransferRestrictionType.ClaimCount) {
            restrictionType = 'ClaimCount';
            rawMin = bigNumberToU64(min, context);
            rawMax = (0, internal_3.optionize)(bigNumberToU64)(max, context);
        }
        else {
            // i.e. TransferRestrictionType.ClaimPercentage
            restrictionType = 'ClaimOwnership';
            rawMin = percentageToPermill(min, context);
            rawMax = percentageToPermill(value.max, context);
        }
        const val = extractClaimValue(claim);
        const claimValue = {
            [claim.type]: val,
        };
        const rawIdentityId = stringToIdentityId(issuer.did, context);
        restrictionValue = [claimValue, rawIdentityId, rawMin, rawMax];
    }
    else {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.UnexpectedError,
            message: `Unexpected transfer restriction type: "${type}". Please report this to the Polymesh team`,
        });
    }
    return context.createType('PolymeshPrimitivesTransferComplianceTransferCondition', {
        [restrictionType]: restrictionValue,
    });
}
exports.transferRestrictionToPolymeshTransferCondition = transferRestrictionToPolymeshTransferCondition;
/**
 * @hidden
 */
function identitiesToBtreeSet(identities, context) {
    const rawIds = identities.map(({ did }) => stringToIdentityId(did, context));
    return context.createType('BTreeSet<PolymeshPrimitivesIdentityId>', rawIds);
}
exports.identitiesToBtreeSet = identitiesToBtreeSet;
/**
 * @hidden
 */
function transferConditionToTransferRestriction(transferCondition, context) {
    if (transferCondition.isMaxInvestorCount) {
        return {
            type: types_1.TransferRestrictionType.Count,
            value: u64ToBigNumber(transferCondition.asMaxInvestorCount),
        };
    }
    else if (transferCondition.isMaxInvestorOwnership) {
        return {
            type: types_1.TransferRestrictionType.Percentage,
            value: permillToBigNumber(transferCondition.asMaxInvestorOwnership),
        };
    }
    else if (transferCondition.isClaimCount) {
        return {
            type: types_1.TransferRestrictionType.ClaimCount,
            value: claimCountToClaimCountRestrictionValue(transferCondition.asClaimCount, context),
        };
    }
    else if (transferCondition.isClaimOwnership) {
        return {
            type: types_1.TransferRestrictionType.ClaimPercentage,
            value: claimPercentageToClaimPercentageRestrictionValue(transferCondition.asClaimOwnership, context),
        };
    }
    else {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.FatalError,
            message: 'Unexpected transfer condition type',
        });
    }
}
exports.transferConditionToTransferRestriction = transferConditionToTransferRestriction;
/**
 * @hidden
 */
function granularCanTransferResultToTransferBreakdown(result, context) {
    const { invalid_granularity: invalidGranularity, self_transfer: selfTransfer, invalid_receiver_cdd: invalidReceiverCdd, invalid_sender_cdd: invalidSenderCdd, missing_scope_claim: missingScopeClaim, sender_insufficient_balance: insufficientBalance, asset_frozen: assetFrozen, portfolio_validity_result: { sender_portfolio_does_not_exist: senderPortfolioNotExists, receiver_portfolio_does_not_exist: receiverPortfolioNotExists, sender_insufficient_balance: senderInsufficientBalance, }, transfer_condition_result: transferConditionResult, compliance_result: complianceResult, result: finalResult, } = result;
    const general = [];
    if (boolToBoolean(invalidGranularity)) {
        general.push(types_1.TransferError.InvalidGranularity);
    }
    if (boolToBoolean(selfTransfer)) {
        general.push(types_1.TransferError.SelfTransfer);
    }
    if (boolToBoolean(invalidReceiverCdd)) {
        general.push(types_1.TransferError.InvalidReceiverCdd);
    }
    if (boolToBoolean(invalidSenderCdd)) {
        general.push(types_1.TransferError.InvalidSenderCdd);
    }
    if (boolToBoolean(missingScopeClaim)) {
        general.push(types_1.TransferError.ScopeClaimMissing);
    }
    if (boolToBoolean(insufficientBalance)) {
        general.push(types_1.TransferError.InsufficientBalance);
    }
    if (boolToBoolean(assetFrozen)) {
        general.push(types_1.TransferError.TransfersFrozen);
    }
    if (boolToBoolean(senderPortfolioNotExists)) {
        general.push(types_1.TransferError.InvalidSenderPortfolio);
    }
    if (boolToBoolean(receiverPortfolioNotExists)) {
        general.push(types_1.TransferError.InvalidReceiverPortfolio);
    }
    if (boolToBoolean(senderInsufficientBalance)) {
        general.push(types_1.TransferError.InsufficientPortfolioBalance);
    }
    const restrictions = transferConditionResult.map(({ condition, result: tmResult }) => {
        return {
            restriction: transferConditionToTransferRestriction(condition, context),
            result: boolToBoolean(tmResult),
        };
    });
    return {
        general,
        compliance: assetComplianceResultToCompliance(complianceResult, context),
        restrictions,
        result: boolToBoolean(finalResult),
    };
}
exports.granularCanTransferResultToTransferBreakdown = granularCanTransferResultToTransferBreakdown;
/**
 * @hidden
 */
function offeringTierToPriceTier(tier, context) {
    const { price, amount } = tier;
    return context.createType('PalletStoPriceTier', {
        total: bigNumberToBalance(amount, context),
        price: bigNumberToBalance(price, context),
    });
}
exports.offeringTierToPriceTier = offeringTierToPriceTier;
/**
 * @hidden
 */
function permissionsLikeToPermissions(permissionsLike, context) {
    let assetPermissions = {
        values: [],
        type: types_1.PermissionType.Include,
    };
    let transactionPermissions = {
        values: [],
        type: types_1.PermissionType.Include,
    };
    let transactionGroupPermissions = [];
    let portfolioPermissions = {
        values: [],
        type: types_1.PermissionType.Include,
    };
    let transactions;
    let transactionGroups;
    if ('transactions' in permissionsLike) {
        ({ transactions } = permissionsLike);
    }
    if ('transactionGroups' in permissionsLike) {
        ({ transactionGroups } = permissionsLike);
    }
    const { assets, portfolios } = permissionsLike;
    if (assets === null) {
        assetPermissions = null;
    }
    else if (assets) {
        assetPermissions = Object.assign(Object.assign({}, assets), { values: assets.values.map(ticker => typeof ticker !== 'string' ? ticker : new internal_1.FungibleAsset({ ticker }, context)) });
    }
    if (transactions !== undefined) {
        transactionPermissions = transactions;
    }
    else if (transactionGroups !== undefined) {
        transactionGroupPermissions = (0, lodash_1.uniq)(transactionGroups);
        const groupTags = (0, lodash_1.flatten)(transactionGroups.map(txGroupToTxTags));
        transactionPermissions = Object.assign(Object.assign({}, transactionPermissions), { values: groupTags });
    }
    if (portfolios === null) {
        portfolioPermissions = null;
    }
    else if (portfolios) {
        portfolioPermissions = Object.assign(Object.assign({}, portfolios), { values: portfolios.values.map(portfolio => portfolioLikeToPortfolio(portfolio, context)) });
    }
    return {
        assets: assetPermissions,
        transactions: transactionPermissions && Object.assign(Object.assign({}, transactionPermissions), { values: [...transactionPermissions.values].sort((a, b) => a.localeCompare(b)) }),
        transactionGroups: transactionGroupPermissions,
        portfolios: portfolioPermissions,
    };
}
exports.permissionsLikeToPermissions = permissionsLikeToPermissions;
/**
 * @hidden
 */
function middlewarePortfolioToPortfolio(portfolio, context) {
    const { identityId: did, number } = portfolio;
    if (number) {
        return new internal_1.NumberedPortfolio({ did, id: new bignumber_js_1.default(number) }, context);
    }
    return new internal_1.DefaultPortfolio({ did }, context);
}
exports.middlewarePortfolioToPortfolio = middlewarePortfolioToPortfolio;
/**
 * @hidden
 */
function fundraiserTierToTier(fundraiserTier) {
    const { total, price, remaining } = fundraiserTier;
    return {
        amount: balanceToBigNumber(total),
        price: balanceToBigNumber(price),
        remaining: balanceToBigNumber(remaining),
    };
}
exports.fundraiserTierToTier = fundraiserTierToTier;
/**
 * @hidden
 */
function fundraiserToOfferingDetails(fundraiser, name, context) {
    const { creator, offeringPortfolio, raisingPortfolio, raisingAsset, tiers: rawTiers, venueId, start: rawStart, end: rawEnd, status: rawStatus, minimumInvestment: rawMinInvestment, } = fundraiser;
    const tiers = [];
    let totalRemaining = new bignumber_js_1.default(0);
    let totalAmount = new bignumber_js_1.default(0);
    let totalRemainingValue = new bignumber_js_1.default(0);
    rawTiers.forEach(rawTier => {
        const tier = fundraiserTierToTier(rawTier);
        tiers.push(tier);
        const { amount, remaining, price } = tier;
        totalAmount = totalAmount.plus(amount);
        totalRemaining = totalRemaining.plus(remaining);
        totalRemainingValue = totalRemainingValue.plus(price.multipliedBy(remaining));
    });
    const start = momentToDate(rawStart);
    const end = rawEnd.isSome ? momentToDate(rawEnd.unwrap()) : null;
    const now = new Date();
    const isStarted = now > start;
    const isExpired = end && now > end;
    const minInvestment = balanceToBigNumber(rawMinInvestment);
    let timing = types_1.OfferingTimingStatus.NotStarted;
    let balance = types_1.OfferingBalanceStatus.Available;
    let sale = types_1.OfferingSaleStatus.Live;
    if (isExpired) {
        timing = types_1.OfferingTimingStatus.Expired;
    }
    else if (isStarted) {
        timing = types_1.OfferingTimingStatus.Started;
    }
    if (totalRemainingValue.isZero()) {
        balance = types_1.OfferingBalanceStatus.SoldOut;
    }
    else if (totalRemainingValue.lt(minInvestment)) {
        balance = types_1.OfferingBalanceStatus.Residual;
    }
    if (rawStatus.isClosedEarly) {
        sale = types_1.OfferingSaleStatus.ClosedEarly;
    }
    else if (rawStatus.isClosed) {
        sale = types_1.OfferingSaleStatus.Closed;
    }
    else if (rawStatus.isFrozen) {
        sale = types_1.OfferingSaleStatus.Frozen;
    }
    return {
        creator: new internal_1.Identity({ did: identityIdToString(creator) }, context),
        name: bytesToString(name),
        offeringPortfolio: meshPortfolioIdToPortfolio(offeringPortfolio, context),
        raisingPortfolio: meshPortfolioIdToPortfolio(raisingPortfolio, context),
        raisingCurrency: tickerToString(raisingAsset),
        tiers,
        venue: new internal_1.Venue({ id: u64ToBigNumber(venueId) }, context),
        start,
        end,
        status: {
            timing,
            balance,
            sale,
        },
        minInvestment,
        totalAmount,
        totalRemaining,
    };
}
exports.fundraiserToOfferingDetails = fundraiserToOfferingDetails;
/**
 * @hidden
 */
function meshCorporateActionToCorporateActionParams(corporateAction, details, context) {
    const { kind: rawKind, declDate, targets: { identities, treatment }, defaultWithholdingTax, withholdingTax, } = corporateAction;
    let kind;
    if (rawKind.isIssuerNotice) {
        kind = types_1.CorporateActionKind.IssuerNotice;
    }
    else if (rawKind.isPredictableBenefit) {
        kind = types_1.CorporateActionKind.PredictableBenefit;
    }
    else if (rawKind.isUnpredictableBenefit) {
        kind = types_1.CorporateActionKind.UnpredictableBenefit;
    }
    else if (rawKind.isReorganization) {
        kind = types_1.CorporateActionKind.Reorganization;
    }
    else {
        kind = types_1.CorporateActionKind.Other;
    }
    const targets = {
        identities: identities.map(identityId => new internal_1.Identity({ did: identityIdToString(identityId) }, context)),
        treatment: treatment.isExclude ? types_1.TargetTreatment.Exclude : types_1.TargetTreatment.Include,
    };
    const taxWithholdings = withholdingTax.map(([identityId, tax]) => ({
        identity: new internal_1.Identity({ did: identityIdToString(identityId) }, context),
        percentage: permillToBigNumber(tax),
    }));
    return {
        kind,
        declarationDate: momentToDate(declDate),
        description: bytesToString(details),
        targets,
        defaultTaxWithholding: permillToBigNumber(defaultWithholdingTax),
        taxWithholdings,
    };
}
exports.meshCorporateActionToCorporateActionParams = meshCorporateActionToCorporateActionParams;
/**
 * @hidden
 */
function corporateActionKindToCaKind(kind, context) {
    return context.createType('PalletCorporateActionsCaKind', kind);
}
exports.corporateActionKindToCaKind = corporateActionKindToCaKind;
/**
 * @hidden
 */
function checkpointToRecordDateSpec(checkpoint, context) {
    let value;
    if (checkpoint instanceof internal_1.Checkpoint) {
        /* eslint-disable @typescript-eslint/naming-convention */
        value = { Existing: bigNumberToU64(checkpoint.id, context) };
    }
    else if (checkpoint instanceof Date) {
        value = { Scheduled: dateToMoment(checkpoint, context) };
    }
    else {
        value = { ExistingSchedule: bigNumberToU64(checkpoint.id, context) };
        /* eslint-enable @typescript-eslint/naming-convention */
    }
    return context.createType('PalletCorporateActionsRecordDateSpec', value);
}
exports.checkpointToRecordDateSpec = checkpointToRecordDateSpec;
/**
 * @hidden
 */
function targetIdentitiesToCorporateActionTargets(targetIdentities, context) {
    const { identities, treatment } = targetIdentities;
    return {
        identities: identities.map(identity => new internal_1.Identity({ did: identityIdToString(identity) }, context)),
        treatment: treatment.isInclude ? types_1.TargetTreatment.Include : types_1.TargetTreatment.Exclude,
    };
}
exports.targetIdentitiesToCorporateActionTargets = targetIdentitiesToCorporateActionTargets;
/**
 * @hidden
 */
function targetsToTargetIdentities(targets, context) {
    const { treatment, identities } = targets;
    const { maxTargetIds } = context.polymeshApi.consts.corporateAction;
    const maxTargets = u32ToBigNumber(maxTargetIds);
    if (maxTargets.lt(targets.identities.length)) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: 'Too many target Identities',
            data: {
                maxTargets,
            },
        });
    }
    return context.createType('PalletCorporateActionsTargetIdentities', {
        identities: identities.map(identity => stringToIdentityId(signerToString(identity), context)),
        treatment: context.createType('TargetTreatment', treatment),
    });
}
exports.targetsToTargetIdentities = targetsToTargetIdentities;
/**
 * @hidden
 */
function caTaxWithholdingsToMeshTaxWithholdings(taxWithholdings, context) {
    (0, utils_1.assertCaTaxWithholdingsValid)(taxWithholdings, context);
    return taxWithholdings.map(({ identity, percentage }) => (0, utils_3.tuple)(stringToIdentityId(signerToString(identity), context), percentageToPermill(percentage, context)));
}
exports.caTaxWithholdingsToMeshTaxWithholdings = caTaxWithholdingsToMeshTaxWithholdings;
/**
 * @hidden
 */
function distributionToDividendDistributionParams(distribution, context) {
    const { from, currency, perShare, amount, expiresAt: expiryDate, paymentAt: paymentDate, } = distribution;
    return {
        origin: meshPortfolioIdToPortfolio(from, context),
        currency: tickerToString(currency),
        perShare: balanceToBigNumber(perShare),
        maxAmount: balanceToBigNumber(amount),
        expiryDate: expiryDate.isNone ? null : momentToDate(expiryDate.unwrap()),
        paymentDate: momentToDate(paymentDate),
    };
}
exports.distributionToDividendDistributionParams = distributionToDividendDistributionParams;
/**
 * @hidden
 */
function corporateActionIdentifierToCaId(corporateActionIdentifier, context) {
    const { ticker, localId } = corporateActionIdentifier;
    return context.createType('PalletCorporateActionsCaId', {
        ticker: stringToTicker(ticker, context),
        localId: bigNumberToU32(localId, context),
    });
}
exports.corporateActionIdentifierToCaId = corporateActionIdentifierToCaId;
/**
 * @hidden
 */
function corporateActionParamsToMeshCorporateActionArgs(params, context) {
    const { ticker, kind, declarationDate, checkpoint, description, targets, defaultTaxWithholding, taxWithholdings, } = params;
    const rawTicker = stringToTicker(ticker, context);
    const rawKind = corporateActionKindToCaKind(kind, context);
    const rawDeclDate = dateToMoment(declarationDate, context);
    const rawRecordDate = (0, internal_3.optionize)(checkpointToRecordDateSpec)(checkpoint, context);
    const rawDetails = stringToBytes(description, context);
    const rawTargets = (0, internal_3.optionize)(targetsToTargetIdentities)(targets, context);
    const rawTax = (0, internal_3.optionize)(percentageToPermill)(defaultTaxWithholding, context);
    const rawWithholdings = (0, internal_3.optionize)(caTaxWithholdingsToMeshTaxWithholdings)(taxWithholdings, context);
    return context.createType('PalletCorporateActionsInitiateCorporateActionArgs', {
        ticker: rawTicker,
        kind: rawKind,
        declDate: rawDeclDate,
        recordDate: rawRecordDate,
        details: rawDetails,
        targets: rawTargets,
        defaultWithholdingTax: rawTax,
        withholdingTax: rawWithholdings,
    });
}
exports.corporateActionParamsToMeshCorporateActionArgs = corporateActionParamsToMeshCorporateActionArgs;
/**
 * @hidden
 */
function statisticsOpTypeToStatType(args, context) {
    const { op, claimIssuer } = args;
    return context.createType('PolymeshPrimitivesStatisticsStatType', { op, claimIssuer });
}
exports.statisticsOpTypeToStatType = statisticsOpTypeToStatType;
/**
 * @hidden
 *
 * The chain requires BTreeSets to be sorted, Polkadot.js will shallow sort elements when calling `createType`,
 * however it will not look deeper at claimType. This function works around this short fall by sorting based on `claimType`
 * `createType` built in sorting is relied on otherwise.
 */
function sortStatsByClaimType(stats) {
    return [...stats].sort((a, b) => {
        if (a.claimIssuer.isNone && b.claimIssuer.isNone) {
            return 0;
        }
        if (a.claimIssuer.isNone) {
            return 1;
        }
        if (b.claimIssuer.isNone) {
            return -1;
        }
        const [aClaim] = a.claimIssuer.unwrap();
        const [bClaim] = b.claimIssuer.unwrap();
        return aClaim.index - bClaim.index;
    });
}
exports.sortStatsByClaimType = sortStatsByClaimType;
/**
 * @hidden
 */
function statisticStatTypesToBtreeStatType(stats, context) {
    const sortedStats = sortStatsByClaimType(stats);
    return context.createType('BTreeSet<PolymeshPrimitivesStatisticsStatType>', sortedStats);
}
exports.statisticStatTypesToBtreeStatType = statisticStatTypesToBtreeStatType;
/**
 * @hidden
 */
function transferConditionsToBtreeTransferConditions(conditions, context) {
    return context.createType('BTreeSet<PolymeshPrimitivesTransferComplianceTransferCondition>', conditions);
}
exports.transferConditionsToBtreeTransferConditions = transferConditionsToBtreeTransferConditions;
/**
 * @hidden
 */
function keyAndValueToStatUpdate(key2, value, context) {
    return context.createType('PolymeshPrimitivesStatisticsStatUpdate', { key2, value });
}
exports.keyAndValueToStatUpdate = keyAndValueToStatUpdate;
/**
 * @hidden
 */
function statUpdatesToBtreeStatUpdate(statUpdates, context) {
    return context.createType('BTreeSet<PolymeshPrimitivesStatisticsStatUpdate>', statUpdates);
}
exports.statUpdatesToBtreeStatUpdate = statUpdatesToBtreeStatUpdate;
/**
 * @hidden
 */
function meshStatToStatType(rawStat) {
    const { op: { type }, claimIssuer, } = rawStat;
    if (claimIssuer.isNone) {
        if (type === 'Count') {
            return types_1.StatType.Count;
        }
        else {
            return types_1.StatType.Balance;
        }
    }
    if (type === 'Count') {
        return types_1.StatType.ScopedCount;
    }
    else {
        return types_1.StatType.ScopedBalance;
    }
}
exports.meshStatToStatType = meshStatToStatType;
/**
 * @hidden
 */
function statTypeToStatOpType(type, context) {
    if (type === types_1.StatType.Count || type === types_1.StatType.ScopedCount) {
        return context.createType('PolymeshPrimitivesStatisticsStatOpType', types_1.StatType.Count);
    }
    return context.createType('PolymeshPrimitivesStatisticsStatOpType', types_1.StatType.Balance);
}
exports.statTypeToStatOpType = statTypeToStatOpType;
/**
 * @hidden
 */
function transferRestrictionTypeToStatOpType(type, context) {
    if (type === types_1.TransferRestrictionType.Count || type === types_1.TransferRestrictionType.ClaimCount) {
        return context.createType('PolymeshPrimitivesStatisticsStatOpType', types_1.StatType.Count);
    }
    return context.createType('PolymeshPrimitivesStatisticsStatOpType', types_1.StatType.Balance);
}
exports.transferRestrictionTypeToStatOpType = transferRestrictionTypeToStatOpType;
/**
 * Scoped stats are a map of maps, e.g. Jurisdiction has a counter for each CountryCode. a 2ndKey specifies what Country count to use
 * @hidden
 */
function createStat2ndKey(type, context, claimStat) {
    if (type === 'NoClaimStat') {
        return context.createType('PolymeshPrimitivesStatisticsStat2ndKey', type);
    }
    else {
        let value;
        if (claimStat === 'yes') {
            value = true;
        }
        else if (claimStat === 'no') {
            value = false;
        }
        else {
            value = claimStat;
        }
        return context.createType('PolymeshPrimitivesStatisticsStat2ndKey', {
            claim: { [type]: value },
        });
    }
}
exports.createStat2ndKey = createStat2ndKey;
/**
 * @hidden
 * The chain requires BTreeSets to be sorted. While polkadot.js createType will provide shallow sorting
 * it fails to consider the nested CountryCode values. This works around the shortfall, but relies on `createType`
 * sorting for otherwise
 */
function sortTransferRestrictionByClaimValue(conditions) {
    const getJurisdictionValue = (condition) => {
        const { isClaimCount, isClaimOwnership } = condition;
        if (isClaimCount) {
            if (!condition.asClaimCount[0].isJurisdiction) {
                return undefined;
            }
            else {
                return condition.asClaimCount[0].asJurisdiction;
            }
        }
        else if (isClaimOwnership) {
            if (!condition.asClaimOwnership[0].isJurisdiction) {
                return undefined;
            }
            return condition.asClaimOwnership[0].asJurisdiction;
        }
        else {
            return undefined;
        }
    };
    return [...conditions].sort((a, b) => {
        const aClaim = getJurisdictionValue(a);
        if (!aClaim) {
            return 1;
        }
        const bClaim = getJurisdictionValue(b);
        if (!bClaim) {
            return -1;
        }
        if (aClaim.isNone && bClaim.isNone) {
            return 0;
        }
        if (aClaim.isNone) {
            return -1;
        }
        if (bClaim.isNone) {
            return 1;
        }
        const aCode = (0, utils_2.meshCountryCodeToCountryCode)(aClaim.unwrap());
        const bCode = (0, utils_2.meshCountryCodeToCountryCode)(bClaim.unwrap());
        const countryOrder = Object.values(types_1.CountryCode);
        return countryOrder.indexOf(aCode) - countryOrder.indexOf(bCode);
    });
}
exports.sortTransferRestrictionByClaimValue = sortTransferRestrictionByClaimValue;
/**
 * @hidden
 */
function complianceConditionsToBtreeSet(conditions, context) {
    const sortedConditions = sortTransferRestrictionByClaimValue(conditions);
    return context.createType('BTreeSet<PolymeshPrimitivesTransferComplianceTransferCondition>', sortedConditions);
}
exports.complianceConditionsToBtreeSet = complianceConditionsToBtreeSet;
/**
 * @hidden
 */
function toExemptKey(tickerKey, op, claimType) {
    return { asset: tickerKey, op, claimType };
}
exports.toExemptKey = toExemptKey;
/**
 * @hidden
 */
function claimCountStatInputToStatUpdates(args, context) {
    const { value, claimType: type } = args;
    let updateArgs;
    if (type === types_1.ClaimType.Jurisdiction) {
        updateArgs = value.map(({ countryCode, count }) => {
            const rawSecondKey = createStat2ndKey(type, context, countryCode);
            return keyAndValueToStatUpdate(rawSecondKey, bigNumberToU128(count, context), context);
        });
    }
    else {
        let yes, no;
        if (type === types_1.ClaimType.Accredited) {
            ({ accredited: yes, nonAccredited: no } = value);
        }
        else {
            ({ affiliate: yes, nonAffiliate: no } = value);
        }
        const yes2ndKey = createStat2ndKey(type, context, 'yes');
        const yesCount = bigNumberToU128(yes, context);
        const no2ndKey = createStat2ndKey(type, context, 'no');
        const noCount = bigNumberToU128(no, context);
        updateArgs = [
            keyAndValueToStatUpdate(yes2ndKey, yesCount, context),
            keyAndValueToStatUpdate(no2ndKey, noCount, context),
        ];
    }
    return statUpdatesToBtreeStatUpdate(updateArgs, context);
}
exports.claimCountStatInputToStatUpdates = claimCountStatInputToStatUpdates;
/**
 * @hidden
 * transforms a non scoped count stat to a StatUpdate type
 */
function countStatInputToStatUpdates(args, context) {
    const { count } = args;
    const secondKey = createStat2ndKey('NoClaimStat', context);
    const stat = keyAndValueToStatUpdate(secondKey, bigNumberToU128(count, context), context);
    return statUpdatesToBtreeStatUpdate([stat], context);
}
exports.countStatInputToStatUpdates = countStatInputToStatUpdates;
/**
 * @hidden
 */
function inputStatTypeToMeshStatType(input, context) {
    const { type } = input;
    const op = statTypeToStatOpType(type, context);
    let claimIssuer;
    if (type === types_1.StatType.ScopedCount || type === types_1.StatType.ScopedBalance) {
        claimIssuer = claimIssuerToMeshClaimIssuer(input.claimIssuer, context);
    }
    return statisticsOpTypeToStatType({ op, claimIssuer }, context);
}
exports.inputStatTypeToMeshStatType = inputStatTypeToMeshStatType;
/**
 * @hidden
 */
function meshProposalStatusToProposalStatus(status, expiry) {
    const { type } = status;
    switch (type) {
        case 'ActiveOrExpired':
            if (!expiry || expiry > new Date()) {
                return types_1.ProposalStatus.Active;
            }
            else {
                return types_1.ProposalStatus.Expired;
            }
        case 'Invalid':
            return types_1.ProposalStatus.Invalid;
        case 'ExecutionSuccessful':
            return types_1.ProposalStatus.Successful;
        case 'ExecutionFailed':
            return types_1.ProposalStatus.Failed;
        case 'Rejected':
            return types_1.ProposalStatus.Rejected;
        default:
            throw new utils_1.UnreachableCaseError(type);
    }
}
exports.meshProposalStatusToProposalStatus = meshProposalStatusToProposalStatus;
/**
 * @hidden
 */
function metadataSpecToMeshMetadataSpec(specs, context) {
    const { url, description, typeDef } = specs;
    const { polymeshApi: { consts: { asset: { assetMetadataTypeDefMaxLength }, }, }, } = context;
    const metadataTypeDefMaxLength = u32ToBigNumber(assetMetadataTypeDefMaxLength);
    if (typeDef && metadataTypeDefMaxLength.lt(typeDef.length)) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: '"typeDef" length exceeded for given Asset Metadata spec',
            data: {
                maxLength: metadataTypeDefMaxLength,
            },
        });
    }
    return context.createType('PolymeshPrimitivesAssetMetadataAssetMetadataSpec', {
        url: (0, internal_3.optionize)(stringToBytes)(url, context),
        description: (0, internal_3.optionize)(stringToBytes)(description, context),
        typeDef: (0, internal_3.optionize)(stringToBytes)(typeDef, context),
    });
}
exports.metadataSpecToMeshMetadataSpec = metadataSpecToMeshMetadataSpec;
/**
 * @hidden
 */
function meshMetadataSpecToMetadataSpec(rawSpecs) {
    const specs = {};
    if (rawSpecs === null || rawSpecs === void 0 ? void 0 : rawSpecs.isSome) {
        const { url: rawUrl, description: rawDescription, typeDef: rawTypeDef } = rawSpecs.unwrap();
        if (rawUrl.isSome) {
            specs.url = bytesToString(rawUrl.unwrap());
        }
        if (rawDescription.isSome) {
            specs.description = bytesToString(rawDescription.unwrap());
        }
        if (rawTypeDef.isSome) {
            specs.typeDef = bytesToString(rawTypeDef.unwrap());
        }
    }
    return specs;
}
exports.meshMetadataSpecToMetadataSpec = meshMetadataSpecToMetadataSpec;
/**
 * @hidden
 */
function metadataToMeshMetadataKey(type, id, context) {
    const rawId = bigNumberToU64(id, context);
    let metadataKey;
    if (type === types_1.MetadataType.Local) {
        metadataKey = { Local: rawId };
    }
    else {
        metadataKey = { Global: rawId };
    }
    return context.createType('PolymeshPrimitivesAssetMetadataAssetMetadataKey', metadataKey);
}
exports.metadataToMeshMetadataKey = metadataToMeshMetadataKey;
/**
 * @hidden
 */
function meshMetadataValueToMetadataValue(rawValue, rawDetails) {
    if (rawValue.isNone) {
        return null;
    }
    let metadataValue = {
        value: bytesToString(rawValue.unwrap()),
        lockStatus: types_1.MetadataLockStatus.Unlocked,
        expiry: null,
    };
    if (rawDetails.isSome) {
        const { lockStatus: rawLockStatus, expire } = rawDetails.unwrap();
        metadataValue = Object.assign(Object.assign({}, metadataValue), { expiry: (0, internal_3.optionize)(momentToDate)(expire.unwrapOr(null)) });
        if (rawLockStatus.isLocked) {
            metadataValue = Object.assign(Object.assign({}, metadataValue), { lockStatus: types_1.MetadataLockStatus.Locked });
        }
        if (rawLockStatus.isLockedUntil) {
            metadataValue = Object.assign(Object.assign({}, metadataValue), { lockStatus: types_1.MetadataLockStatus.LockedUntil, lockedUntil: momentToDate(rawLockStatus.asLockedUntil) });
        }
    }
    return metadataValue;
}
exports.meshMetadataValueToMetadataValue = meshMetadataValueToMetadataValue;
/**
 * @hidden
 */
function metadataValueToMeshMetadataValue(value, context) {
    const { polymeshApi: { consts: { asset: { assetMetadataValueMaxLength }, }, }, } = context;
    const metadataValueMaxLength = u32ToBigNumber(assetMetadataValueMaxLength);
    if (metadataValueMaxLength.lt(value.length)) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.ValidationError,
            message: 'Asset Metadata value length exceeded',
            data: {
                maxLength: metadataValueMaxLength,
            },
        });
    }
    return stringToBytes(value, context);
}
exports.metadataValueToMeshMetadataValue = metadataValueToMeshMetadataValue;
/**
 * @hidden
 */
function metadataValueDetailToMeshMetadataValueDetail(details, context) {
    const { lockStatus, expiry } = details;
    let meshLockStatus;
    if (lockStatus === types_1.MetadataLockStatus.LockedUntil) {
        const { lockedUntil } = details;
        if (lockedUntil < new Date()) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.UnmetPrerequisite,
                message: 'Locked until date must be in the future',
            });
        }
        meshLockStatus = { LockedUntil: dateToMoment(lockedUntil, context) };
    }
    else {
        meshLockStatus = lockStatus;
    }
    if (expiry && expiry < new Date()) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.UnmetPrerequisite,
            message: 'Expiry date must be in the future',
        });
    }
    return context.createType('PolymeshPrimitivesAssetMetadataAssetMetadataValueDetail', {
        expire: (0, internal_3.optionize)(dateToMoment)(expiry, context),
        lockStatus: meshLockStatus,
    });
}
exports.metadataValueDetailToMeshMetadataValueDetail = metadataValueDetailToMeshMetadataValueDetail;
/**
 * @hidden
 */
function instructionMemoToString(value) {
    return (0, internal_3.removePadding)((0, util_1.hexToString)(value.toString()));
}
exports.instructionMemoToString = instructionMemoToString;
/**
 * @hidden
 */
function middlewareInstructionToHistoricInstruction(instruction, context) {
    /* eslint-disable @typescript-eslint/no-non-null-assertion */
    const { id: instructionId, status, settlementType, endBlock, tradeDate, valueDate, legs: { nodes: legs }, memo, createdBlock, venueId, } = instruction;
    const { blockId, hash, datetime } = createdBlock;
    let typeDetails;
    if (settlementType === types_1.InstructionType.SettleOnAffirmation) {
        typeDetails = {
            type: types_1.InstructionType.SettleOnAffirmation,
        };
    }
    else {
        typeDetails = {
            type: settlementType,
            endBlock: new bignumber_js_1.default(endBlock),
        };
    }
    return Object.assign(Object.assign({ id: new bignumber_js_1.default(instructionId), blockNumber: new bignumber_js_1.default(blockId), blockHash: hash, status,
        tradeDate,
        valueDate }, typeDetails), { memo: memo !== null && memo !== void 0 ? memo : null, venueId: new bignumber_js_1.default(venueId), createdAt: new Date(datetime), legs: legs.map(({ from, to, assetId, amount }) => ({
            asset: new internal_1.FungibleAsset({ ticker: assetId }, context),
            amount: new bignumber_js_1.default(amount).shiftedBy(-6),
            from: middlewarePortfolioToPortfolio(from, context),
            to: middlewarePortfolioToPortfolio(to, context),
        })) });
    /* eslint-enable @typescript-eslint/no-non-null-assertion */
}
exports.middlewareInstructionToHistoricInstruction = middlewareInstructionToHistoricInstruction;
/**
 * @hidden
 */
function expiryToMoment(expiry, context) {
    if (expiry && expiry <= new Date()) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.UnmetPrerequisite,
            message: 'Expiry date must be in the future',
        });
    }
    return (0, internal_3.optionize)(dateToMoment)(expiry, context);
}
exports.expiryToMoment = expiryToMoment;
/**
 * @hidden
 * Note: currently only supports fungible legs, see `portfolioToPortfolioKind` for exemplary API
 */
function middlewarePortfolioDataToPortfolio(data, context) {
    const { did, kind } = data;
    if ('default' in kind) {
        return new internal_1.DefaultPortfolio({ did }, context);
    }
    return new internal_1.NumberedPortfolio({ did, id: new bignumber_js_1.default(kind.user) }, context);
}
exports.middlewarePortfolioDataToPortfolio = middlewarePortfolioDataToPortfolio;
/**
 * @hidden
 */
function legToSettlementLeg(leg, context) {
    return context.createType('PolymeshPrimitivesSettlementLeg', leg);
}
exports.legToSettlementLeg = legToSettlementLeg;
/**
 * @hidden
 */
function middlewareAgentGroupDataToPermissionGroup(agentGroupData, context) {
    const asset = Object.keys(agentGroupData)[0];
    const agentGroup = agentGroupData[asset];
    let permissionGroupIdentifier;
    if ('full' in agentGroup) {
        permissionGroupIdentifier = types_1.PermissionGroupType.Full;
    }
    else if ('exceptMeta' in agentGroup) {
        permissionGroupIdentifier = types_1.PermissionGroupType.ExceptMeta;
    }
    else if ('polymeshV1CAA' in agentGroup) {
        permissionGroupIdentifier = types_1.PermissionGroupType.PolymeshV1Caa;
    }
    else if ('polymeshV1PIA' in agentGroup) {
        permissionGroupIdentifier = types_1.PermissionGroupType.PolymeshV1Pia;
    }
    else {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        permissionGroupIdentifier = { custom: new bignumber_js_1.default(agentGroup.custom) };
    }
    const ticker = (0, exports.coerceHexToString)(asset);
    return assemblePermissionGroup(permissionGroupIdentifier, ticker, context);
}
exports.middlewareAgentGroupDataToPermissionGroup = middlewareAgentGroupDataToPermissionGroup;
/**
 * @hidden
 */
function middlewareExtrinsicPermissionsDataToTransactionPermissions(permissions) {
    let extrinsicType;
    let pallets;
    if ('these' in permissions) {
        extrinsicType = types_1.PermissionType.Include;
        pallets = permissions.these;
    }
    else if ('except' in permissions) {
        extrinsicType = types_1.PermissionType.Exclude;
        pallets = permissions.except;
    }
    let txValues = [];
    let exceptions = [];
    if (pallets) {
        pallets.forEach(({ palletName, dispatchableNames }) => {
            const moduleName = (0, util_1.stringLowerFirst)((0, exports.coerceHexToString)(palletName));
            if ('except' in dispatchableNames) {
                const dispatchables = [...dispatchableNames.except];
                exceptions = [
                    ...exceptions,
                    ...dispatchables.map(name => formatTxTag((0, exports.coerceHexToString)(name), moduleName)),
                ];
                txValues = [...txValues, moduleName];
            }
            else if ('these' in dispatchableNames) {
                const dispatchables = [...dispatchableNames.these];
                txValues = [
                    ...txValues,
                    ...dispatchables.map(name => formatTxTag((0, exports.coerceHexToString)(name), moduleName)),
                ];
            }
            else {
                txValues = [...txValues, moduleName];
            }
        });
        const result = {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            type: extrinsicType,
            values: txValues,
        };
        return exceptions.length ? Object.assign(Object.assign({}, result), { exceptions }) : result;
    }
    return null;
}
/**
 * @hidden
 */
function datesToScheduleCheckpoints(points, context) {
    const rawPoints = points.map(point => dateToMoment(point, context));
    const pending = context.createType('BTreeSet<Moment>', rawPoints);
    return context.createType('PolymeshCommonUtilitiesCheckpointScheduleCheckpoints', { pending });
}
exports.datesToScheduleCheckpoints = datesToScheduleCheckpoints;
/**
 * @hidden
 */
function middlewarePermissionsDataToPermissions(permissionsData, context) {
    const { asset, extrinsic, portfolio } = JSON.parse(permissionsData);
    let assets = null;
    let transactions = null;
    let portfolios = null;
    let assetsType;
    let assetsPermissions;
    if ('these' in asset) {
        assetsType = types_1.PermissionType.Include;
        assetsPermissions = asset.these;
    }
    else if ('except' in asset) {
        assetsType = types_1.PermissionType.Exclude;
        assetsPermissions = asset.except;
    }
    if (assetsPermissions) {
        assets = {
            values: [...assetsPermissions].map(ticker => new internal_1.FungibleAsset({ ticker: (0, exports.coerceHexToString)(ticker) }, context)),
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            type: assetsType,
        };
    }
    transactions = middlewareExtrinsicPermissionsDataToTransactionPermissions(extrinsic);
    let portfoliosType;
    let portfolioIds;
    if ('these' in portfolio) {
        portfoliosType = types_1.PermissionType.Include;
        portfolioIds = portfolio.these;
    }
    else if ('except' in portfolio) {
        portfoliosType = types_1.PermissionType.Exclude;
        portfolioIds = portfolio.except;
    }
    if (portfolioIds) {
        portfolios = {
            values: [...portfolioIds].map(portfolioId => middlewarePortfolioDataToPortfolio(portfolioId, context)),
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            type: portfoliosType,
        };
    }
    return {
        assets,
        transactions,
        transactionGroups: transactions ? transactionPermissionsToTxGroups(transactions) : [],
        portfolios,
    };
}
exports.middlewarePermissionsDataToPermissions = middlewarePermissionsDataToPermissions;
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * @hidden
 */
function middlewareAuthorizationDataToAuthorization(context, type, data) {
    switch (type) {
        case enums_1.AuthTypeEnum.AttestPrimaryKeyRotation:
            return {
                type: types_1.AuthorizationType.AttestPrimaryKeyRotation,
                value: new internal_1.Identity({ did: data }, context),
            };
        case enums_1.AuthTypeEnum.RotatePrimaryKey: {
            return {
                type: types_1.AuthorizationType.RotatePrimaryKey,
            };
        }
        case enums_1.AuthTypeEnum.RotatePrimaryKeyToSecondary: {
            return {
                type: types_1.AuthorizationType.RotatePrimaryKeyToSecondary,
                value: middlewarePermissionsDataToPermissions(data, context),
            };
        }
        case enums_1.AuthTypeEnum.JoinIdentity: {
            return {
                type: types_1.AuthorizationType.JoinIdentity,
                value: middlewarePermissionsDataToPermissions(data, context),
            };
        }
        case enums_1.AuthTypeEnum.AddMultiSigSigner:
            return {
                type: types_1.AuthorizationType.AddMultiSigSigner,
                value: data,
            };
        case enums_1.AuthTypeEnum.AddRelayerPayingKey: {
            // data is received in the format - {"5Ci94GCJC2JBM8U1PCkpHX6HkscWmucN9XwUrjb7o4TDgVns","5DZp1QYH49MKZhCtDupNaAeHp8xtqetuSzgf2p2cUWoxW3iu","1000000000"}
            const [beneficiary, subsidizer, allowance] = data
                .substring(1, data.length - 1)
                .replace(/"/g, '')
                .split(',');
            return {
                type: types_1.AuthorizationType.AddRelayerPayingKey,
                value: {
                    beneficiary: new internal_1.Account({ address: beneficiary }, context),
                    subsidizer: new internal_1.Account({ address: subsidizer }, context),
                    allowance: new bignumber_js_1.default(allowance).shiftedBy(-6),
                },
            };
        }
        case enums_1.AuthTypeEnum.BecomeAgent: {
            const becomeAgentData = JSON.parse(data.replace(',', ':'));
            return {
                type: types_1.AuthorizationType.BecomeAgent,
                value: middlewareAgentGroupDataToPermissionGroup(becomeAgentData, context),
            };
        }
        case enums_1.AuthTypeEnum.TransferTicker:
            return {
                type: types_1.AuthorizationType.TransferTicker,
                value: (0, exports.coerceHexToString)(data),
            };
        case enums_1.AuthTypeEnum.TransferAssetOwnership: {
            return {
                type: types_1.AuthorizationType.TransferAssetOwnership,
                value: (0, exports.coerceHexToString)(data),
            };
        }
        case enums_1.AuthTypeEnum.PortfolioCustody: {
            return {
                type: types_1.AuthorizationType.PortfolioCustody,
                value: middlewarePortfolioDataToPortfolio(JSON.parse(data), context),
            };
        }
    }
    throw new internal_1.PolymeshError({
        code: types_1.ErrorCode.UnexpectedError,
        message: 'Unsupported Authorization Type. Please contact the Polymesh team',
        data: {
            auth: data,
        },
    });
}
exports.middlewareAuthorizationDataToAuthorization = middlewareAuthorizationDataToAuthorization;
/* eslint-enable @typescript-eslint/no-non-null-assertion */
/**
 * @hidden
 */
function collectionKeysToMetadataKeys(keys, context) {
    const metadataKeys = keys.map(({ type, id }) => {
        return metadataToMeshMetadataKey(type, id, context);
    });
    return context.createType('Vec<PolymeshPrimitivesAssetMetadataAssetMetadataKey>', metadataKeys);
}
exports.collectionKeysToMetadataKeys = collectionKeysToMetadataKeys;
/**
 * @hidden
 */
function meshMetadataKeyToMetadataKey(rawKey, ticker) {
    if (rawKey.isGlobal) {
        return { type: types_1.MetadataType.Global, id: u64ToBigNumber(rawKey.asGlobal) };
    }
    else {
        return { type: types_1.MetadataType.Local, id: u64ToBigNumber(rawKey.asLocal), ticker };
    }
}
exports.meshMetadataKeyToMetadataKey = meshMetadataKeyToMetadataKey;
/**
 * @hidden
 */
function meshNftToNftId(rawInfo) {
    const { ticker: rawTicker, ids: rawIds } = rawInfo;
    return {
        ticker: tickerToString(rawTicker),
        ids: rawIds.map(rawId => u64ToBigNumber(rawId)),
    };
}
exports.meshNftToNftId = meshNftToNftId;
/**
 * @hidden
 */
function nftInputToNftMetadataAttribute(nftInfo, context) {
    const { type, id, value } = nftInfo;
    const rawKey = metadataToMeshMetadataKey(type, id, context);
    const rawValue = metadataValueToMeshMetadataValue(value, context);
    return context.createType('PolymeshPrimitivesNftNftMetadataAttribute', {
        key: rawKey,
        value: rawValue,
    });
}
exports.nftInputToNftMetadataAttribute = nftInputToNftMetadataAttribute;
/**
 * @hidden
 */
function nftInputToNftMetadataVec(nftInfo, context) {
    const rawItems = nftInfo.map(item => nftInputToNftMetadataAttribute(item, context));
    return context.createType('Vec<PolymeshPrimitivesNftNftMetadataAttribute>', rawItems);
}
exports.nftInputToNftMetadataVec = nftInputToNftMetadataVec;
//# sourceMappingURL=conversion.js.map