import { ApiDecoration, AugmentedEvent, AugmentedQueries, AugmentedQuery, AugmentedQueryDoubleMap, ObsInnerType } from '@polkadot/api/types';
import { BTreeSet, Bytes, Option, StorageKey } from '@polkadot/types';
import { EventRecord } from '@polkadot/types/interfaces';
import { BlockHash } from '@polkadot/types/interfaces/chain';
import { PalletAssetSecurityToken, PolymeshPrimitivesIdentityId, PolymeshPrimitivesSecondaryKeyKeyRecord, PolymeshPrimitivesStatisticsStatType, PolymeshPrimitivesTransferComplianceTransferCondition } from "../polkadot/types-lookup.ts";
import type { Callback, Observable } from '@polkadot/types/types';
import { AnyFunction, AnyTuple, IEvent, ISubmittableResult } from '@polkadot/types/types';
import BigNumber from 'bignumber.js';
import { Account, BaseAsset, Checkpoint, CheckpointSchedule, ChildIdentity, Context, FungibleAsset, Identity, Nft, NftCollection } from "../internal";
import { MiddlewareScope } from "../middleware/typesV1";
import { Claim, Condition, InputCaCheckpoint, InputCondition, ModuleName, NextKey, NoArgsProcedureMethod, OptionalArgsProcedureMethod, PaginationOptions, PermissionedAccount, ProcedureMethod, RemoveAssetStatParams, StatType, SubCallback, TransferRestriction, TransferRestrictionType, TxTag, UnsubCallback } from "../types";
import { Events, Falsyable, MapTxWithArgs, PolymeshTx, StatClaimIssuer, TxWithArgs } from "../types/internal";
import { HumanReadableType, ProcedureFunc, QueryFunction, UnionOfProcedureFuncs } from "../types/utils";
export * from "../generated/utils";
/**
 * @hidden
 * Promisified version of a timeout
 *
 * @param amount - time to wait
 */
export declare function delay(amount: number): Promise<void>;
/**
 * @hidden
 * Convert an entity type and its unique Identifiers to a base64 string
 */
export declare function serialize<UniqueIdentifiers>(entityType: string, uniqueIdentifiers: UniqueIdentifiers): string;
/**
 * @hidden
 * Convert a uuid string to an Identifier object
 */
export declare function unserialize<UniqueIdentifiers>(id: string): UniqueIdentifiers;
/**
 * @hidden
 * Extract the DID from an Identity, or return the DID of the signing Identity if no Identity is passed
 */
export declare function getDid(value: string | Identity | undefined, context: Context): Promise<string>;
/**
 * @hidden
 * Given a DID return the corresponding Identity, given an Identity return the Identity
 */
export declare function asIdentity(value: string | Identity, context: Context): Identity;
/**
 * @hidden
 * Given a DID return the corresponding ChildIdentity, given an ChildIdentity return the ChildIdentity
 */
export declare function asChildIdentity(value: string | ChildIdentity, context: Context): ChildIdentity;
/**
 * @hidden
 * Given an address return the corresponding Account, given an Account return the Account
 */
export declare function asAccount(value: string | Account, context: Context): Account;
/**
 * @hidden
 * DID | Identity -> DID
 */
export declare function asDid(value: string | Identity): string;
/**
 * @hidden
 * Given an Identity, return the Identity, given a DID returns the corresponding Identity, if value is falsy, then return currentIdentity
 */
export declare function getIdentity(value: string | Identity | undefined, context: Context): Promise<Identity>;
/**
 * @hidden
 */
export declare function createClaim(claimType: string, jurisdiction: Falsyable<string>, middlewareScope: Falsyable<MiddlewareScope>, cddId: Falsyable<string>): Claim;
/**
 * @hidden
 */
declare type EventData<Event> = Event extends AugmentedEvent<'promise', infer Data> ? Data : never;
/**
 * @hidden
 * Find every occurrence of a specific event inside a receipt
 *
 * @param skipError - optional. If true, no error will be thrown if the event is not found,
 *   and the function will return an empty array
 */
export declare function filterEventRecords<ModuleName extends keyof Events, EventName extends keyof Events[ModuleName]>(receipt: ISubmittableResult, mod: ModuleName, eventName: EventName, skipError?: true): IEvent<EventData<Events[ModuleName][EventName]>>[];
/**
 * @hidden
 *
 *   Segment a batch transaction receipt's events into arrays, each representing a specific extrinsic's
 *   associated events. This is useful for scenarios where we need to isolate and process events
 *   for individual extrinsics in a batch.
 *
 *   In a batch transaction receipt, events corresponding to multiple extrinsics are listed sequentially.
 *   This function identifies boundaries between these event sequences, typically demarcated by
 *   events like 'utility.ItemCompleted', to segment events into individual arrays.
 *
 *   A key use case is when we want to slice or filter events for a subset of the extrinsics. By
 *   segmenting events this way, it becomes simpler to apply operations or analyses to events
 *   corresponding to specific extrinsics in the batch.
 *
 * @param events - array of events from a batch transaction receipt
 *
 * @returns an array of arrays, where each inner array contains events specific to an extrinsic in the batch.
 *
 * @note this function does not mutate the input events
 */
export declare function segmentEventsByTransaction(events: EventRecord[]): EventRecord[][];
/**
 * @hidden
 *
 * Return a clone of a batch transaction receipt that only contains events for a subset of the
 *   extrinsics in the batch. This is useful when a batch has several extrinsics that emit
 *   the same events and we want `filterEventRecords` to only search among the events emitted by
 *   some of them.
 *
 * A good example of this is when merging similar batches together. If we wish to preserve the return
 *   value of each batch, this is a good way of ensuring that the resolver function of a batch has
 *   access to the events that correspond only to the extrinsics in said batch
 *
 * @param from - index of the first transaction in the subset
 * @param to - end index of the subset (not included)
 *
 * @note this function does not mutate the original receipt
 */
export declare function sliceBatchReceipt(receipt: ISubmittableResult, from: number, to: number): ISubmittableResult;
/**
 * Return a clone of the last receipt in the passes array, containing the accumulated events
 *   of all receipts
 */
export declare function mergeReceipts(receipts: ISubmittableResult[], context: Context): ISubmittableResult;
/**
 * @hidden
 */
export declare function padString(value: string, length: number): string;
/**
 * @hidden
 */
export declare function removePadding(value: string): string;
/**
 * @hidden
 *
 * Return whether the string is fully printable ASCII
 */
export declare function isPrintableAscii(value: string): boolean;
/**
 * @hidden
 *
 * Return whether the string is fully alphanumeric
 */
export declare function isAlphanumeric(value: string): boolean;
/**
 * @hidden
 *
 * Makes an entries request to the chain. If pagination options are supplied,
 *  the request will be paginated. Otherwise, all entries will be requested at once
 */
export declare function requestPaginated<F extends AnyFunction, T extends AnyTuple>(query: AugmentedQuery<'promise', F, T> | AugmentedQueryDoubleMap<'promise', F, T>, opts: {
    paginationOpts?: PaginationOptions;
    arg?: Parameters<F>[0];
}): Promise<{
    entries: [StorageKey<T>, ObsInnerType<ReturnType<F>>][];
    lastKey: NextKey;
}>;
/**
 * @hidden
 *
 * Gets Polymesh API instance at a particular block
 */
export declare function getApiAtBlock(context: Context, blockHash: string | BlockHash): Promise<ApiDecoration<'promise'>>;
declare type QueryMultiParam<T extends AugmentedQuery<'promise', AnyFunction>[]> = {
    [index in keyof T]: T[index] extends AugmentedQuery<'promise', infer Fun> ? Fun extends (firstArg: infer First, ...restArg: infer Rest) => ReturnType<Fun> ? Rest extends never[] ? [T[index], First] : [T[index], Parameters<Fun>] : never : never;
};
declare type QueryMultiReturnType<T extends AugmentedQuery<'promise', AnyFunction>[]> = {
    [index in keyof T]: T[index] extends AugmentedQuery<'promise', infer Fun> ? ReturnType<Fun> extends Observable<infer R> ? R : never : never;
};
/**
 * @hidden
 *
 * Makes an multi request to the chain
 */
export declare function requestMulti<T extends AugmentedQuery<'promise', AnyFunction>[]>(context: Context, queries: QueryMultiParam<T>): Promise<QueryMultiReturnType<T>>;
export declare function requestMulti<T extends AugmentedQuery<'promise', AnyFunction>[]>(context: Context, queries: QueryMultiParam<T>, callback: Callback<QueryMultiReturnType<T>>): Promise<UnsubCallback>;
/**
 * @hidden
 *
 * Makes a request to the chain. If a block hash is supplied,
 *   the request will be made at that block. Otherwise, the most recent block will be queried
 */
export declare function requestAtBlock<ModuleName extends keyof AugmentedQueries<'promise'>, QueryName extends keyof AugmentedQueries<'promise'>[ModuleName]>(moduleName: ModuleName, queryName: QueryName, opts: {
    blockHash?: string | BlockHash;
    args: Parameters<QueryFunction<ModuleName, QueryName>>;
}, context: Context): Promise<ObsInnerType<ReturnType<QueryFunction<ModuleName, QueryName>>>>;
/**
 * @hidden
 *
 * Calculates next page number for paginated GraphQL ResultSet.
 * Returns null if there is no next page.
 *
 * @param size - page size requested
 * @param start - start index requested
 * @param totalCount - total amount of elements returned by query
 *
 * @hidden
 *
 */
export declare function calculateNextKey(totalCount: BigNumber, size: number, start?: BigNumber): NextKey;
/**
 * Create a method that prepares a procedure
 */
export declare function createProcedureMethod<ProcedureArgs, ProcedureReturnValue, Storage = Record<string, unknown>>(args: {
    getProcedureAndArgs: () => [
        (UnionOfProcedureFuncs<ProcedureArgs, ProcedureReturnValue, Storage> | ProcedureFunc<ProcedureArgs, ProcedureReturnValue, Storage>),
        ProcedureArgs
    ];
    voidArgs: true;
}, context: Context): NoArgsProcedureMethod<ProcedureReturnValue, ProcedureReturnValue>;
export declare function createProcedureMethod<ProcedureArgs, ProcedureReturnValue, ReturnValue, Storage = Record<string, unknown>>(args: {
    getProcedureAndArgs: () => [
        (UnionOfProcedureFuncs<ProcedureArgs, ProcedureReturnValue, Storage> | ProcedureFunc<ProcedureArgs, ProcedureReturnValue, Storage>),
        ProcedureArgs
    ];
    voidArgs: true;
    transformer: (value: ProcedureReturnValue) => ReturnValue | Promise<ReturnValue>;
}, context: Context): NoArgsProcedureMethod<ProcedureReturnValue, ReturnValue>;
export declare function createProcedureMethod<MethodArgs, ProcedureArgs, ProcedureReturnValue, Storage = Record<string, unknown>>(args: {
    getProcedureAndArgs: (methodArgs?: MethodArgs) => [
        (UnionOfProcedureFuncs<ProcedureArgs, ProcedureReturnValue, Storage> | ProcedureFunc<ProcedureArgs, ProcedureReturnValue, Storage>),
        ProcedureArgs
    ];
    optionalArgs: true;
}, context: Context): OptionalArgsProcedureMethod<MethodArgs, ProcedureReturnValue, ProcedureReturnValue>;
export declare function createProcedureMethod<MethodArgs, ProcedureArgs, ProcedureReturnValue, ReturnValue, Storage = Record<string, unknown>>(args: {
    getProcedureAndArgs: (methodArgs: MethodArgs) => [
        (UnionOfProcedureFuncs<ProcedureArgs, ProcedureReturnValue, Storage> | ProcedureFunc<ProcedureArgs, ProcedureReturnValue, Storage>),
        ProcedureArgs
    ];
    optionalArgs: true;
    transformer: (value: ProcedureReturnValue) => ReturnValue | Promise<ReturnValue>;
}, context: Context): OptionalArgsProcedureMethod<MethodArgs, ProcedureReturnValue, ReturnValue>;
export declare function createProcedureMethod<MethodArgs extends {}, ProcedureArgs, ProcedureReturnValue, Storage = Record<string, unknown>>(args: {
    getProcedureAndArgs: (methodArgs: MethodArgs) => [
        (UnionOfProcedureFuncs<ProcedureArgs, ProcedureReturnValue, Storage> | ProcedureFunc<ProcedureArgs, ProcedureReturnValue, Storage>),
        ProcedureArgs
    ];
}, context: Context): ProcedureMethod<MethodArgs, ProcedureReturnValue, ProcedureReturnValue>;
export declare function createProcedureMethod<MethodArgs extends {}, ProcedureArgs, ProcedureReturnValue, ReturnValue, Storage = Record<string, unknown>>(args: {
    getProcedureAndArgs: (methodArgs: MethodArgs) => [
        (UnionOfProcedureFuncs<ProcedureArgs, ProcedureReturnValue, Storage> | ProcedureFunc<ProcedureArgs, ProcedureReturnValue, Storage>),
        ProcedureArgs
    ];
    transformer: (value: ProcedureReturnValue) => ReturnValue | Promise<ReturnValue>;
}, context: Context): ProcedureMethod<MethodArgs, ProcedureReturnValue, ReturnValue>;
/**
 * @hidden
 */
export declare function assertIsInteger(value: BigNumber): void;
/**
 * @hidden
 */
export declare function assertIsPositive(value: BigNumber): void;
/**
 * @hidden
 */
export declare function assertAddressValid(address: string, ss58Format: BigNumber): void;
/**
 * @hidden
 */
export declare function asTicker(asset: string | BaseAsset): string;
/**
 * @hidden
 */
export declare function asAsset(asset: string | BaseAsset, context: Context): BaseAsset;
/**
 * @hidden
 * Transforms asset or ticker into a `FungibleAsset` entity
 */
export declare function asFungibleAsset(asset: string | BaseAsset, context: Context): FungibleAsset;
/**
 * @hidden
 */
export declare function xor(a: boolean, b: boolean): boolean;
/**
 * @hidden
 * Transform a conversion util into a version that returns null if the input is falsy
 */
export declare function optionize<InputType, OutputType, RestType extends unknown[]>(converter: (input: InputType, ...rest: RestType) => OutputType): (val: InputType | null | undefined, ...rest: RestType) => OutputType | null;
/**
 * @hidden
 * Compare two tags/modules and return true if they are equal, or if one is the other one's module
 */
export declare function isModuleOrTagMatch(a: TxTag | ModuleName, b: TxTag | ModuleName): boolean;
/**
 * @hidden
 *
 * Recursively convert a value into a human readable (JSON compliant) version:
 *   - Entities are converted via their `.toHuman` method
 *   - Dates are converted to ISO strings
 *   - BigNumbers are converted to numerical strings
 */
export declare function toHumanReadable<T>(obj: T): HumanReadableType<T>;
/**
 * @hidden
 *
 * Return whether the two arrays have same elements.
 * It uses a `comparator` function to check if elements are equal.
 * If no comparator function is provided, it uses `isEqual` function of `lodash`
 */
export declare function hasSameElements<T>(first: T[], second: T[], comparator?: (a: T, b: T) => boolean): boolean;
/**
 * @hidden
 *
 * Perform a deep comparison between two compliance conditions
 */
export declare function conditionsAreEqual(a: Condition | InputCondition, b: Condition | InputCondition): boolean;
/**
 * @hidden
 *
 * Transforms `InputCACheckpoint` values to `Checkpoint | CheckpointSchedule | Date` for easier processing
 */
export declare function getCheckpointValue(checkpoint: InputCaCheckpoint, asset: string | FungibleAsset, context: Context): Promise<Checkpoint | CheckpointSchedule | Date>;
interface TxAndArgsArray<Args extends Readonly<unknown[]> = Readonly<unknown[]>> {
    transaction: PolymeshTx<Args>;
    argsArray: Args[];
}
declare type MapTxAndArgsArray<Args extends Readonly<unknown[][]>> = {
    [K in keyof Args]: Args[K] extends unknown[] ? TxAndArgsArray<Args[K]> : never;
};
/**
 * Assemble the `transactions` array that is expected in a `BatchTransactionSpec` from a set of parameter arrays with their
 *   respective transaction
 *
 * @note This method ensures type safety for batches with a variable amount of transactions
 */
export declare function assembleBatchTransactions<ArgsArray extends Readonly<unknown[][]>>(txsAndArgs: MapTxAndArgsArray<ArgsArray>): MapTxWithArgs<unknown[][]>;
/**
 * @hidden
 *
 * Returns portfolio numbers for a set of portfolio names
 */
export declare function getPortfolioIdsByName(rawIdentityId: PolymeshPrimitivesIdentityId, rawNames: Bytes[], context: Context): Promise<(BigNumber | null)[]>;
/**
 * @hidden
 *
 * Check if a transaction matches the type of its args. Returns the same value but stripped of the types. This function has no logic, it's strictly
 *   for type safety when returning a `BatchTransactionSpec` with a variable amount of transactions
 */
export declare function checkTxType<Args extends unknown[]>(tx: TxWithArgs<Args>): TxWithArgs<unknown[]>;
/**
 * @hidden
 *
 * Add an empty handler to a promise to avoid false positive unhandled promise errors. The original promise
 *   is returned, so rejections are still bubbled up and caught properly. This is an ugly hack and should be used
 *   sparingly and only if you KNOW that rejections will be handled properly down the line
 *
 * More info:
 *
 * - https://github.com/facebook/jest/issues/6028#issuecomment-567851031
 * - https://stackoverflow.com/questions/59060508/how-to-handle-an-unhandled-promise-rejection-asynchronously
 * - https://stackoverflow.com/questions/40920179/should-i-refrain-from-handling-promise-rejection-asynchronously/40921505#40921505
 */
export declare function defusePromise<T>(promise: Promise<T>): Promise<T>;
/**
 * @hidden
 *
 * Transform an array of Identities into exempted IDs for Transfer Managers.
 *
 * @note even though the signature for `addExemptedEntities` requires `ScopeId`s as parameters,
 *   it accepts and handles `PolymeshPrimitivesIdentityId` parameters as well. Nothing special has to be done typing-wise since they're both aliases
 *   for `U8aFixed`
 *
 * @throws
 *   - if there are duplicated Identities/ScopeIDs
 */
export declare function getExemptedIds(identities: (string | Identity)[], context: Context): Promise<string[]>;
/**
 * @hidden
 *
 * Checks SQ version compatibility with the SDK
 */
export declare function assertExpectedSqVersion(context: Context): Promise<void>;
/**
 * @hidden
 *
 * Checks chain version. This function uses a websocket as it's intended to be called during initialization
 * @param nodeUrl - URL for the chain node
 * @returns A promise that resolves if the version is in the expected range, otherwise it will reject
 */
export declare function assertExpectedChainVersion(nodeUrl: string): Promise<void>;
/**
 * @hidden
 *
 * Validates a ticker value
 */
export declare function assertTickerValid(ticker: string): void;
/**
 * @hidden
 * @returns true is the given stat is able to track the data for the given args
 */
export declare function compareStatsToInput(rawStatType: PolymeshPrimitivesStatisticsStatType, args: RemoveAssetStatParams): boolean;
/**
 * @hidden
 * @returns true if the given StatType is able to track the data for the given transfer condition
 */
export declare function compareTransferRestrictionToStat(transferCondition: PolymeshPrimitivesTransferComplianceTransferCondition, type: StatType, claimIssuer?: StatClaimIssuer): boolean;
/**
 * @hidden
 */
export declare function compareTransferRestrictionToInput(rawRestriction: PolymeshPrimitivesTransferComplianceTransferCondition, inputRestriction: TransferRestriction): boolean;
/**
 * @hidden
 */
export declare function compareStatTypeToTransferRestrictionType(statType: PolymeshPrimitivesStatisticsStatType, transferRestrictionType: TransferRestrictionType): boolean;
/**
 * @hidden
 * @param args.type TransferRestriction type that was given
 * @param args.claimIssuer optional Issuer and ClaimType for the scope of the Stat
 * @param context
 * @returns encoded StatType needed for the TransferRestriction to be enabled
 */
export declare function neededStatTypeForRestrictionInput(args: {
    type: TransferRestrictionType;
    claimIssuer?: StatClaimIssuer;
}, context: Context): PolymeshPrimitivesStatisticsStatType;
/**
 * @hidden
 * @throws if stat is not found in the given set
 */
export declare function assertStatIsSet(currentStats: BTreeSet<PolymeshPrimitivesStatisticsStatType>, neededStat: PolymeshPrimitivesStatisticsStatType): void;
/**
 * @hidden
 *
 * Fetches Account permissions for the given secondary Accounts
 *
 * @note non secondary Accounts will be skipped, so there maybe less PermissionedAccounts returned than Accounts given
 *
 * @param args.accounts a list of accounts to fetch permissions for
 * @param args.identity optional. If passed, Accounts that are not part of the given Identity will be filtered out
 */
export declare function getSecondaryAccountPermissions(args: {
    accounts: Account[];
    identity?: Identity;
}, context: Context, callback: SubCallback<PermissionedAccount[]>): Promise<UnsubCallback>;
export declare function getSecondaryAccountPermissions(args: {
    accounts: Account[];
    identity?: Identity;
}, context: Context): Promise<PermissionedAccount[]>;
/**
 * @hidden
 */
export declare function getExemptedBtreeSet(identities: (string | Identity)[], ticker: string, context: Context): Promise<BTreeSet<PolymeshPrimitivesIdentityId>>;
/**
 * @hidden
 */
export declare function getIdentityFromKeyRecord(keyRecord: PolymeshPrimitivesSecondaryKeyKeyRecord, context: Context): Promise<Identity | null>;
/**
 * @hidden
 *
 * helper to construct proper type asset
 *
 * @note `assetDetails` and `tickers` must have the same offset
 */
export declare function assembleAssetQuery(assetDetails: Option<PalletAssetSecurityToken>[], tickers: string[], context: Context): (FungibleAsset | NftCollection)[];
/**
 * @hidden
 */
export declare function asNftId(nft: Nft | BigNumber): BigNumber;
//# sourceMappingURL=internal.d.ts.map